<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>javase | WhX</title><meta name="author" content="王浩学"><meta name="copyright" content="王浩学"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="一，基础知识1，注释说明性信息  单行注释 格式:&#x2F;&#x2F;注释信息  多行注释 格式：&#x2F;注释信息&#x2F; 2,关键字 有特定含义 字母全都小写 编辑器对关键字有颜色特殊标注 3，常量1，字符串常量：“helloworld” 2，整数常量：不带小数的数字 3、小数常量：带小数的数字 4，字符常量：‘a’   ‘0‘ 5，布尔常量：true false 6，空常量：nul">
<meta property="og:type" content="article">
<meta property="og:title" content="javase">
<meta property="og:url" content="http://example.com/2024/09/10/javase/index.html">
<meta property="og:site_name" content="WhX">
<meta property="og:description" content="一，基础知识1，注释说明性信息  单行注释 格式:&#x2F;&#x2F;注释信息  多行注释 格式：&#x2F;注释信息&#x2F; 2,关键字 有特定含义 字母全都小写 编辑器对关键字有颜色特殊标注 3，常量1，字符串常量：“helloworld” 2，整数常量：不带小数的数字 3、小数常量：带小数的数字 4，字符常量：‘a’   ‘0‘ 5，布尔常量：true false 6，空常量：nul">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ts1.cn.mm.bing.net/th?id=OIP-C.Ig7_AHVk9TLxH7-p9riLHAHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.5&pid=3.1&rm=2">
<meta property="article:published_time" content="2024-09-10T12:17:26.000Z">
<meta property="article:modified_time" content="2024-09-13T11:28:30.257Z">
<meta property="article:author" content="王浩学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ts1.cn.mm.bing.net/th?id=OIP-C.Ig7_AHVk9TLxH7-p9riLHAHaHa&w=250&h=250&c=8&rs=1&qlt=90&o=6&dpr=1.5&pid=3.1&rm=2"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/09/10/javase/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'javase',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-13 19:28:30'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://ts1.cn.mm.bing.net/th?id=OIP-C.Ig7_AHVk9TLxH7-p9riLHAHaHa&amp;w=250&amp;h=250&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;dpr=1.5&amp;pid=3.1&amp;rm=2" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="WhX"><span class="site-name">WhX</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">javase</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-10T12:17:26.000Z" title="发表于 2024-09-10 20:17:26">2024-09-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-13T11:28:30.257Z" title="更新于 2024-09-13 19:28:30">2024-09-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="javase"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一，基础知识"><a href="#一，基础知识" class="headerlink" title="一，基础知识"></a>一，基础知识</h1><h3 id="1，注释"><a href="#1，注释" class="headerlink" title="1，注释"></a>1，注释</h3><p>说明性信息</p>
<hr>
<p>单行注释</p>
<p>格式:&#x2F;&#x2F;注释信息</p>
<hr>
<p>多行注释</p>
<p>格式：&#x2F;<em>注释信息</em>&#x2F;</p>
<h3 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2,关键字"></a>2,关键字</h3><p> 有特定含义</p>
<p>字母全都小写</p>
<p>编辑器对关键字有颜色特殊标注</p>
<h3 id="3，常量"><a href="#3，常量" class="headerlink" title="3，常量"></a>3，常量</h3><p>1，字符串常量：“helloworld”</p>
<p>2，整数常量：不带小数的数字</p>
<p>3、小数常量：带小数的数字</p>
<p>4，字符常量：‘a’   ‘0‘</p>
<p>5，布尔常量：true false</p>
<p>6，空常量：null 不能直接输出</p>
<h3 id="4，数据类型"><a href="#4，数据类型" class="headerlink" title="4，数据类型"></a>4，数据类型</h3><p>最小信息单元：位（bit）b  </p>
<p>最小存储单元字节(byte) B</p>
<p>1B&#x3D;8bit</p>
<p>1KB&#x3D;1024B</p>
<p>1MB&#x3D;1024KB</p>
<p>1GB&#x3D;1024MB</p>
<p>1TB&#x3D;1024GB</p>
<h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1,基本数据类型"></a>1,基本数据类型</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 103350.png)</p>
<h3 id="5，变量"><a href="#5，变量" class="headerlink" title="5，变量"></a>5，变量</h3><p>值可以改变的量</p>
<p>存续在内存上</p>
<p>数据类型 变量名&#x3D;变量值</p>
<p>eg：int a&#x3D;10；</p>
<p>取值：变量名 eg：a</p>
<p>修改值：变量名&#x3D;变量值</p>
<p>如：a&#x3D;20；</p>
<p><em><strong>注意事项</strong></em>：</p>
<p>由于整数默认int  浮点数默认double所以数字后要加大写首字母</p>
<p>eg：float f &#x3D;14.12F</p>
<p>​		long 1&#x3D;10324234820L</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 110416.png)</p>
<h3 id="6，标识符"><a href="#6，标识符" class="headerlink" title="6，标识符"></a>6，标识符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 110731.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 111003.png)</p>
<p>小驼峰是变量，方法；大驼峰是类</p>
<h3 id="7，类型转换"><a href="#7，类型转换" class="headerlink" title="7，类型转换"></a>7，类型转换</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 111551.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 111633.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 112009.png) </p>
<h3 id="8，算术运算符"><a href="#8，算术运算符" class="headerlink" title="8，算术运算符"></a>8，算术运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 142516.png)</p>
<h3 id="9，字符串"><a href="#9，字符串" class="headerlink" title="9，字符串"></a>9，字符串</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 143911.png)</p>
<h3 id="10，赋值运算"><a href="#10，赋值运算" class="headerlink" title="10，赋值运算"></a>10，赋值运算</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 144709.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 145005.png)</p>
<h3 id="11，自增自减运算符"><a href="#11，自增自减运算符" class="headerlink" title="11，自增自减运算符"></a>11，自增自减运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 145542.png)</p>
<h3 id="12，关系运算符"><a href="#12，关系运算符" class="headerlink" title="12，关系运算符"></a>12，关系运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 150129.png)</p>
<p>![ ](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 150309.png)</p>
<h3 id="13，逻辑运算符"><a href="#13，逻辑运算符" class="headerlink" title="13，逻辑运算符"></a>13，逻辑运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 151005.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 151101.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 152056.png)</p>
<h3 id="14，3元运算符"><a href="#14，3元运算符" class="headerlink" title="14，3元运算符"></a>14，3元运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 153518.png)</p>
<h3 id="15，数据输入"><a href="#15，数据输入" class="headerlink" title="15，数据输入"></a>15，数据输入</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 160251.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 160522.png)</p>
<p>例子，3个和尚</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 161131.png)</p>
<h1 id="二，分支语句"><a href="#二，分支语句" class="headerlink" title="二，分支语句"></a>二，分支语句</h1><h3 id="1，流程控制"><a href="#1，流程控制" class="headerlink" title="1，流程控制"></a>1，流程控制</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162032.png)</p>
<h3 id="2，分支结构"><a href="#2，分支结构" class="headerlink" title="2，分支结构"></a>2，分支结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162150.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162407.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162515.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162736.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 164831.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 165229.png)</p>
<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 171550.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 171726.png)</p>
<h3 id="case穿透"><a href="#case穿透" class="headerlink" title="case穿透"></a>case穿透</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172248.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172324.png)</p>
<h3 id="3，循环语句"><a href="#3，循环语句" class="headerlink" title="3，循环语句"></a>3，循环语句</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172640.png)</p>
<h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172913.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172945.png)</p>
<p>eg</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 174341.png)</p>
<h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 174702.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 174936.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 191512.png)</p>
<p><img src="/">![屏幕截图 2024-07-08 191620](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 191620.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 192107.png)</p>
<h3 id="挑战控制语句"><a href="#挑战控制语句" class="headerlink" title="挑战控制语句"></a>挑战控制语句</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 193155.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 193231.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 193301.png)</p>
<h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 194016.png)</p>
<h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 194226.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 194510.png)</p>
<p>​                                                                                                       <em><strong>idea</strong></em></p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 204829.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 205243.png)</p>
<h1 id="五，数组"><a href="#五，数组" class="headerlink" title="五，数组"></a>五，数组</h1><h3 id="1，数组定义"><a href="#1，数组定义" class="headerlink" title="1，数组定义"></a>1，数组定义</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 210034.png)</p>
<h3 id="3、动态初始化"><a href="#3、动态初始化" class="headerlink" title="3、动态初始化"></a>3、动态初始化</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 210501.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 210643.png)</p>
<h3 id="new-int-是创建整型数组的基本用法"><a href="#new-int-是创建整型数组的基本用法" class="headerlink" title="new int[]是创建整型数组的基本用法"></a>new int[]是创建整型数组的基本用法</h3><h3 id="4，数组元素访问"><a href="#4，数组元素访问" class="headerlink" title="4，数组元素访问"></a>4，数组元素访问</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 212046.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 212143.png)</p>
<h3 id="5，内存分配"><a href="#5，内存分配" class="headerlink" title="5，内存分配"></a>5，内存分配</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 213607.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 213937.png)</p>
<h3 id="6，数组内存图"><a href="#6，数组内存图" class="headerlink" title="6，数组内存图"></a>6，数组内存图</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 214357.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 214813.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 215146.png)</p>
<h3 id="7，静态初始化"><a href="#7，静态初始化" class="headerlink" title="7，静态初始化"></a>7，静态初始化</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 215418.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 215832.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 215854.png)</p>
<h6 id="静态：int-arr-new-int-1-2-3"><a href="#静态：int-arr-new-int-1-2-3" class="headerlink" title="静态：int[] arr &#x3D;new int{1,2,3}"></a>静态：int[] arr &#x3D;new int{1,2,3}</h6><p>动态：int[] arr&#x3D;new int[3]</p>
<h3 id="8，问题"><a href="#8，问题" class="headerlink" title="8，问题"></a>8，问题</h3><h4 id="索引越界：访问了数组中不存在的索引对应的元素"><a href="#索引越界：访问了数组中不存在的索引对应的元素" class="headerlink" title="索引越界：访问了数组中不存在的索引对应的元素"></a>索引越界：访问了数组中不存在的索引对应的元素</h4><h5 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 070959.png)</p>
<h3 id="9，遍历"><a href="#9，遍历" class="headerlink" title="9，遍历"></a>9，遍历</h3><h2 id="格式：数组名-length"><a href="#格式：数组名-length" class="headerlink" title="格式：数组名.length"></a>格式：数组名.length</h2><h4 id="范例：arr-length"><a href="#范例：arr-length" class="headerlink" title="范例：arr.length"></a>范例：arr.length</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 071914.png)</p>
<h3 id="遍历通用格式"><a href="#遍历通用格式" class="headerlink" title="遍历通用格式"></a>遍历通用格式</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 071950.png)</p>
<h1 id="六，方法"><a href="#六，方法" class="headerlink" title="六，方法"></a>六，方法</h1><h2 id="1，概念"><a href="#1，概念" class="headerlink" title="1，概念"></a>1，概念</h2><h3 id="方法：将具有独立功能的代码块组织成为1个整体，使具有特殊功能的代码集"><a href="#方法：将具有独立功能的代码块组织成为1个整体，使具有特殊功能的代码集" class="headerlink" title="方法：将具有独立功能的代码块组织成为1个整体，使具有特殊功能的代码集"></a>方法：将具有独立功能的代码块组织成为1个整体，使具有特殊功能的代码集</h3><p>注意：</p>
<p>方法必须先创建才可以使用，该过程称为方法定义</p>
<p>方法创建后并不是直接运行的，需要手动使用后才执行，该过程称为方法调用</p>
<h2 id="2，方法定义与调用"><a href="#2，方法定义与调用" class="headerlink" title="2，方法定义与调用"></a>2，方法定义与调用</h2><p>①，方法定义</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 074659.png)</p>
<p>②.方法调用</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 075139.png)</p>
<h3 id="注意，方法必须先定义后调用"><a href="#注意，方法必须先定义后调用" class="headerlink" title="注意，方法必须先定义后调用"></a>注意，方法必须先定义后调用</h3><p>案例：</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 080453.png)</p>
<h3 id="3，带参数方法定义与调用"><a href="#3，带参数方法定义与调用" class="headerlink" title="3，带参数方法定义与调用"></a>3，带参数方法定义与调用</h3><p>定义</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 080625.png)</p>
<p>注意：</p>
<p>方法定义时，参数的数据类型与变量名都不能缺少，缺少任意1个程序将报错</p>
<p>方法定义时，多个参数之间使用逗号（，）分隔</p>
<p>调用</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 081014.png)</p>
<p>注意</p>
<p>方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 081812.png)</p>
<h3 id="4-形参与实参"><a href="#4-形参与实参" class="headerlink" title="4.形参与实参"></a>4.形参与实参</h3><p>形参：方法定义中的参数</p>
<p>如 int number</p>
<p>实参：方法调用中的参数</p>
<p>如10    number</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 082142.png)</p>
<h3 id="5-带返回值方法定义"><a href="#5-带返回值方法定义" class="headerlink" title="5.带返回值方法定义"></a>5.带返回值方法定义</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 082702.png)</p>
<p>注意：方法定义时return后面的返回值与方法定义上的数据类型要匹，否则程序将报错</p>
<p>调用</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 083024.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 083148.png)</p>
<p>在 main()方法中调用定义好的方法可直接打印结果</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 083513.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 083728.png)</p>
<h2 id="6，方法注意事项"><a href="#6，方法注意事项" class="headerlink" title="6，方法注意事项"></a>6，方法注意事项</h2><p>①.方法不能嵌套定义</p>
<p>②.void表示无返回值，可以省略return,也可以单独书写return，后面不加数据。</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 084140.png)</p>
<p>return表结束</p>
<h5 id="③"><a href="#③" class="headerlink" title="③."></a>③.</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 084443.png)</p>
<p>④.![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 084553.png)</p>
<p>参数是数据类型 变量名</p>
<h2 id="7，方法重载"><a href="#7，方法重载" class="headerlink" title="7，方法重载"></a>7，方法重载</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 084930.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 085636.png)</p>
<h2 id="8，方法参数传递"><a href="#8，方法参数传递" class="headerlink" title="8，方法参数传递"></a>8，方法参数传递</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 092541.png)</p>
<p>原因，并没有将其值调用回（return）main函数  </p>
<p>而对于引用类型参数穿递，引用类型变量存储的是内存地址，传参后形参和实参指向内存中同1位置，形参改变自然会影响实参</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 094516.png)</p>
<h2 id="9，数组遍历"><a href="#9，数组遍历" class="headerlink" title="9，数组遍历"></a>9，数组遍历</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 094709.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 095410.png)</p>
<h3 id="10-求数组最大值"><a href="#10-求数组最大值" class="headerlink" title="10.求数组最大值"></a>10.求数组最大值</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 101623.png)</p>
<h1 id="六，debug"><a href="#六，debug" class="headerlink" title="六，debug"></a>六，debug</h1><h2 id="1，概述"><a href="#1，概述" class="headerlink" title="1，概述"></a>1，概述</h2><p>是供程序使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 102211.png)</p>
<p><img src="/">![屏幕截图 2024-07-09 102217](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 102217.png)</p>
<p>1，加断点</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 102316.png)</p>
<p>2，右键</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 102418.png)</p>
<p>3，看debugger窗口，console窗口（执行结果）</p>
<p>4，f7继续执行</p>
<p>5，左键删除</p>
<h3 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h3><p>查找</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 144516.png)</p>
<h1 id="七，面向对象基础"><a href="#七，面向对象基础" class="headerlink" title="七，面向对象基础"></a>七，面向对象基础</h1><h2 id="1，类与对象"><a href="#1，类与对象" class="headerlink" title="1，类与对象"></a>1，类与对象</h2><p>类是对现实生活中1类具有共同属性和行为的事物的抽象</p>
<p>特点1，类是对象的数据类型</p>
<p>2.类是具有相同<strong>属性</strong>和<strong>行为</strong>的1组对象的集合</p>
<p>行为对象执行的操作</p>
<p>类的定义（不用加static）</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 163459.png)</p>
<p>成员变量的使用如图所示：</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 161252.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 162347.png)</p>
<p>eg：</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 164354.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 164410.png)</p>
<p>这说明上1个类是下1个类的容器</p>
<h3 id="2-对象内存图"><a href="#2-对象内存图" class="headerlink" title="2.对象内存图"></a>2.对象内存图</h3><h3 id="①，多个对象"><a href="#①，多个对象" class="headerlink" title="①，多个对象"></a>①，多个对象</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 170753.png)</p>
<h3 id="②，多个对象指向相同"><a href="#②，多个对象指向相同" class="headerlink" title="②，多个对象指向相同"></a>②，多个对象指向相同</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 171830.png)</p>
<p>首先是堆内存装的是林青霞后s2&#x3D;s1将s1的地址赋值给s2之后，s2的地址也变成001，经过后续修改直接改变001存放的值，变为张曼玉</p>
<h3 id="③，成员变量与局部变量"><a href="#③，成员变量与局部变量" class="headerlink" title="③，成员变量与局部变量"></a>③，成员变量与局部变量</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 173540.png)</p>
<p>区别</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 173630.png)</p>
<h3 id="④，封装"><a href="#④，封装" class="headerlink" title="④，封装"></a>④，封装</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 174559.png)</p>
<h3 id="⑤，this关键字"><a href="#⑤，this关键字" class="headerlink" title="⑤，this关键字"></a>⑤，this关键字</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 191653.png)</p>
<h1 id="八，构造方法"><a href="#八，构造方法" class="headerlink" title="八，构造方法"></a>八，构造方法</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>特殊方法，作用为创造对象</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 215406.png)</p>
<p>功能：主要是完成对象数据的初始化</p>
<p>当你没有构造方法时，系统会有一个默认无参的构造方法，就可以在其他类实例化对象，如果定义了构造方法，系统将不再提供默认的构造方法</p>
<p>只要有无参构造方法，实例化对象就不需要参数，否则实例化一定有参数</p>
<p>构造方法的作用是 类实例化创建对象 类中的成员变量赋上默认值 也可以对类中的成员变量进行初始化 </p>
<p>推荐无论是否使用，都手工书写无参构造方法</p>
<p>实例化时自动调用其方法或变量</p>
<p>2，标准类制作</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 074801.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 075001.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 075041.png)</p>
<h1 id="八，字符串"><a href="#八，字符串" class="headerlink" title="八，字符串"></a>八，字符串</h1><h3 id="1，string"><a href="#1，string" class="headerlink" title="1，string"></a>1，string</h3><p>string类代表字符串 </p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 204746.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 204859.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 211459.png)</p>
<h3 id="2，string的特点"><a href="#2，string的特点" class="headerlink" title="2，string的特点"></a>2，string的特点</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 212720.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 212737.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 213014.png)</p>
<h2 id="3，字符串的比较"><a href="#3，字符串的比较" class="headerlink" title="3，字符串的比较"></a>3，字符串的比较</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 214429.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 214500.png)</p>
<h3 id="4，举例"><a href="#4，举例" class="headerlink" title="4，举例"></a>4，举例</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 085539.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 090417.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 093406.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 093423.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 100607.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 100634.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 100652.png)</p>
<h3 id="5，StringBuilder"><a href="#5，StringBuilder" class="headerlink" title="5，StringBuilder"></a>5，StringBuilder</h3><p>避免由于拼接导致的内存占用浪费</p>
<p>是1个可变的字符串类，可以看成1个容器，可变指的是StringBuilder对象中的内容是可变的</p>
<p>String：内容不可变而StringBuilder:内容是可变的</p>
<h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 102303.png)</p>
<h4 id="添加与反转"><a href="#添加与反转" class="headerlink" title="添加与反转"></a>添加与反转</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 104954.png)</p>
<h4 id="StringBuilder和String相互转换"><a href="#StringBuilder和String相互转换" class="headerlink" title="StringBuilder和String相互转换"></a>StringBuilder和String相互转换</h4><h5 id="1，StringBuilder转换为String"><a href="#1，StringBuilder转换为String" class="headerlink" title="1，StringBuilder转换为String"></a>1，StringBuilder转换为String</h5><p>public String to String():通过toString()就可以实现把StringBuilder转换为String</p>
<h5 id="2-String转换为StringBuilder"><a href="#2-String转换为StringBuilder" class="headerlink" title="2,String转换为StringBuilder"></a>2,String转换为StringBuilder</h5><p>public StringBuilder(String s):通过构造方法就可以实把String转换为StringBuilder</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 110723.png)</p>
<p>用Springbuildr构造字符串拼接</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 111553.png)</p>
<p>反转</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 112722.png)&#x3D;![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 112751.png)</p>
<h1 id="C-Users-31502-Pictures-Screenshots-屏幕截图-2024-07-10-112853-png-九，集合"><a href="#C-Users-31502-Pictures-Screenshots-屏幕截图-2024-07-10-112853-png-九，集合" class="headerlink" title="![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 112853.png)                                                                                九，集合"></a>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 112853.png)                                                                                九，集合</h1><h3 id="1，概述-1"><a href="#1，概述-1" class="headerlink" title="1，概述"></a>1，概述</h3><p>提供1种存储空间可变的存储模型，存储的数据量可以发生改变</p>
<p>ArrayList<E> </p>
<p>可调整大小的数组实现</p>
<p><E>是1种数据类型&#x2F;f泛型类如ArrayList<String>,ArrayList<Student></p>
<h2 id="2，ArrayList构造方法和添加方法"><a href="#2，ArrayList构造方法和添加方法" class="headerlink" title="2，ArrayList构造方法和添加方法"></a>2，ArrayList构造方法和添加方法</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 143859.png)</p>
<p>这其中的方法是已经有的，在调用完对象可直接使用</p>
<p>变量名.add():将元素加到集合末尾</p>
<p>如array.add(“hello”);</p>
<p>array.add(“word”);</p>
<p>输出helloword</p>
<p>变量名.add(数字，元素)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 145857.png)</p>
<p>将“元素”插到第“数字”位置</p>
<h2 id="3，ArrayList集合常用方法"><a href="#3，ArrayList集合常用方法" class="headerlink" title="3，ArrayList集合常用方法"></a>3，ArrayList集合常用方法</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 150848.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 150926.png)</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 152733.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 154213.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 154131.png)</p>
<h1 id="十，继承"><a href="#十，继承" class="headerlink" title="十，继承"></a>十，继承</h1><h3 id="1，概述-2"><a href="#1，概述-2" class="headerlink" title="1，概述"></a>1，概述</h3><p>继承是面向对象的3大特征之1，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法。</p>
<p>继承是指在原有类的基础上，进行功能扩展，创建新的类型。</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 102141.png)</p>
<p> 例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//public 公共的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">1_0000_0000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//student is person</span></span><br><span class="line"><span class="comment">//Teacher student也叫派生类或者子类</span></span><br><span class="line"><span class="comment">//子类可以继承父类的所有方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();</span><br><span class="line">        System.out.println(student.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子类继承父类后，测试可直接创建子类对象，调用父类方法</p>
<p>子类有父类的内容，还可以有自己的内容</p>
<h4 id="2，继承的优缺点"><a href="#2，继承的优缺点" class="headerlink" title="2，继承的优缺点"></a>2，继承的优缺点</h4><p>继承好处：</p>
<p>实现了数据和方法的共享<br>提高了代码的复用性(多个类相同的成员可以放到同1个类中)<br>提高了代码的维护性(如果方法的代码需要修改，修改1处即可)<br>提高了代码的可扩展性<br>继承缺点：</p>
<p>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟看变化，削弱了子类的独立性</p>
<p>什么时候使用继承？</p>
<p>假设法：我有两个类A和B，如果他们满足A（B）是B（A）的1种，就说明他们存在继承关系，这个时候就可以考虑使用继承来体现，否则就不能滥用继承</p>
<p>如：苹果和水果，猫和狗</p>
<h2 id="3，继承中变量的访问特点"><a href="#3，继承中变量的访问特点" class="headerlink" title="3，继承中变量的访问特点"></a>3，继承中变量的访问特点</h2><p>在子类方法中访问1个变量</p>
<p>最先在子类局部范围找，如果没有就在子类成员范围找，最后在父类成员范围找，如果都没有就报错(不考虑父亲的父亲…)。</p>
<p>例如：创建1个父类Fu</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Fu &#123;</span><br><span class="line">	public int age = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建1个子类Zi</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Zi extends Fu &#123;</span><br><span class="line">	public int heigth = 180;</span><br><span class="line">	public int age = 20;// 若果没有这句，和下面那句，输入的是10</span><br><span class="line">	public void show() &#123;</span><br><span class="line">		int age = 30;// 若果没有这句，输入的是20</span><br><span class="line">		System.out.println(age);</span><br><span class="line">		System.out.println(heigth);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建1个测试类Test</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		// 创建对象调用方法</span><br><span class="line">		Zi z = new Zi();</span><br><span class="line">		z.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：30 80</p>
<h3 id="4，Super"><a href="#4，Super" class="headerlink" title="4，Super"></a>4，Super</h3><p>super 关键字的用法和 this 关键字的用法相似</p>
<ul>
<li>this:代表本类对象的引用（this关键字指向调用该方法的对象1般我们是在当前类中使用this关键字所以我们常说this代表本类对象的引用）</li>
<li>super:代表父类存储空间的标识(可以理解为父类对象引用)</li>
</ul>
<p>1，this.成员变量访问本类成员变量	</p>
<p>this(…)访问本类构造方法	</p>
<p>this.成员方法(…)访问本类成员方法<br>super.成员变量访问父类成员变量	</p>
<p>super(…)访问父类构造方法	</p>
<p>super.成员方法(…)访问父类成员方法</p>
<p>定义1个父类Fu</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Fu &#123;</span><br><span class="line">	public int age = 10;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义1个子类Zi</p>
<p>public class Zi extends Fu {<br>    public int age &#x3D; 20;</p>
<pre><code>public void show() &#123;
    int age = 30;
    System.out.println(age); // 30
    // 访问本类中的成员变量age
    System.out.println(this.age);
    // 访问Fu类中的成员变量age
    System.out.println(super.age);
&#125;
</code></pre>
<p>}<br>测试：Test</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Zi z = new Zi();</span><br><span class="line">		z.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：30 20 10</p>
<h3 id="5，继承中构造方法的访问特点"><a href="#5，继承中构造方法的访问特点" class="headerlink" title="5，继承中构造方法的访问特点"></a>5，继承中构造方法的访问特点</h3><p>子类中所有的构造方法默认都会访问父类中无参的构造方法。</p>
<ol>
<li>因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，1定要先完成父类数据的初始化</li>
<li>每1个子类构造方法的第1条语句默认都是: super()</li>
</ol>
<p>例如：创建1个父类Fu</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Fu &#123;</span><br><span class="line">	public Fu() &#123;</span><br><span class="line">		System.out.println(&quot;Fu中无参构造方法被调用&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Fu(int age) &#123;</span><br><span class="line">		System.out.println(&quot;Fu中带参构造方法被调用&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建1个子类Zi</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Zi extends Fu &#123;</span><br><span class="line">	public Zi() &#123;</span><br><span class="line">		// super();</span><br><span class="line">		System.out.println(&quot;Zi中无参构造方法被调用&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public Zi(int age) &#123;</span><br><span class="line">		// super();</span><br><span class="line">		System.out.println(&quot;Zi中带参构造方法被调用&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：Test</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Zi z = new Zi();</span><br><span class="line">		System.out.println(&quot;-------------------&quot;);</span><br><span class="line">		Zi zi = new Zi(18);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果父类中没有无参构造方法，只有带参构造方法<br>1.通过super关键字去显示的调用父类的带参构造方法</p>
<p>2.在父类中自己提供1个无参构造方法</p>
<h3 id="6，继承中成员方法的访问特点"><a href="#6，继承中成员方法的访问特点" class="headerlink" title="6，继承中成员方法的访问特点"></a>6，继承中成员方法的访问特点</h3><p>通过子类对象访问1个方法：</p>
<p>先子类成员范围找，如果找不到就在父类成员范围找，如果都没有就报错(不考虑父亲的父亲…)‘</p>
<p>注意：Java中类只支持单继承，不支持多继承</p>
<p>Java中类支持多层继承（意思是Java中儿子不能继承妈妈和爸爸，但爸爸可以继承爷爷，进而让儿子继承爸爸</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 161548.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 161631.png)</p>
<h3 id="7，方法重写"><a href="#7，方法重写" class="headerlink" title="7，方法重写"></a>7，方法重写</h3><p>方法重写概述：子类中出现了和父类中1模1样的方法声明<br>方法重写的应用：当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容</p>
<p>定义1个手机类Phone</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">	public void call(String name) &#123;</span><br><span class="line">		System.out.println(&quot;给&quot; + name + &quot;打电话&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义1个新手机类NewPhone</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class NewPhone extends Phone &#123;</span><br><span class="line">	public void call(String name) &#123;</span><br><span class="line">		System.out.println(&quot;开启视频功能&quot;);</span><br><span class="line">		// System.out.println(&quot;给&quot; + name + &quot;打电话&quot;);</span><br><span class="line">		super.call(name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：PersonTest </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class PersonTest &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		Phone p = new Phone();</span><br><span class="line">		p.call(&quot;张3&quot;);</span><br><span class="line">		System.out.println(&quot;--------&quot;);</span><br><span class="line">		NewPhone np = new NewPhone();</span><br><span class="line">		np.call(&quot;张3&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>给张3打电话</p>
<hr>
<p>开启视频功能</p>
<p>给张3打电话super.</p>
<p>注意：</p>
<p>私有方法不能被重写(父类私有成员子类是不能继承的)</p>
<p>子类方法访问权限不能更低(public&gt;默认&gt;私有)</p>
<h1 id="十一，修饰符"><a href="#十一，修饰符" class="headerlink" title="十一，修饰符"></a>十一，修饰符</h1><h3 id="1，包"><a href="#1，包" class="headerlink" title="1，包"></a>1，包</h3><h4 id="1，其实就是文件夹"><a href="#1，其实就是文件夹" class="headerlink" title="1，其实就是文件夹"></a>1，其实就是文件夹</h4><p>作用：对类进行文件管理</p>
<p>package 包名;(多级包用.分开)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 171949.png)</p>
<h3 id="2，导包"><a href="#2，导包" class="headerlink" title="2，导包"></a>2，导包</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 172831.png)</p>
<h3 id="3，修饰符的分类"><a href="#3，修饰符的分类" class="headerlink" title="3，修饰符的分类"></a>3，修饰符的分类</h3><h4 id="1，权限修饰符"><a href="#1，权限修饰符" class="headerlink" title="1，权限修饰符"></a>1，权限修饰符</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 174221.png)</p>
<h4 id="2-状态修饰符"><a href="#2-状态修饰符" class="headerlink" title="2.状态修饰符"></a>2.状态修饰符</h4><p>final(最终)</p>
<p><code>final</code>：最终的；<br><code>final</code>用来修饰类、成员变量和方法。</p>
<ul>
<li>final类：表示最终的类，该类不允许被继承。</li>
<li>final变量：表示最终的变量，该变量1经赋值，就不能被修改。</li>
<li>final方法：表示最终的方法，它能被子类所继承，但是该方法不能被子类所重写。</li>
</ul>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 175126.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 175137.png)</p>
<p>修饰局部变量</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 180020.png)</p>
<p>该final把s的地址变成常量，所以s.age&#x3D;100可变，age只是地址里的变量</p>
<p>变量是基本类型：final修饰指的是基本类型的数据值不能发生改变</p>
<p>变量是引用类型：final修饰的是引用类型的地址值不能发生改变，但是地址里面的内容是可以发生改变的</p>
<p>static:</p>
<p><strong>.static关键字</strong> </p>
<p>简单说明：static是静态的意思，可以用来修饰成员方法成员变量。</p>
<h4 id="static修饰的特点："><a href="#static修饰的特点：" class="headerlink" title=".static修饰的特点："></a>.static修饰的特点：</h4><p>1.被类的所有对象所共享，这也是我们判断是否使用静态关键字的关键。</p>
<p>2.可以使用类名来调用也可以使用对象名来调用，推荐使用类名调用</p>
<h4 id="static访问特点："><a href="#static访问特点：" class="headerlink" title=".static访问特点："></a>.static访问特点：</h4><p>非静态成员方法：</p>
<p>1.能访问静态成员变量</p>
<p>2.能访问静态成员方法</p>
<p>3.能访问非静态成员变量</p>
<p>4.能访问非静态成员方法</p>
<p>静态成员方法</p>
<p>1.能访问静态成员变量</p>
<p>2.能访问静态成员方法</p>
<h1 id="十二，多态"><a href="#十二，多态" class="headerlink" title="十二，多态"></a>十二，多态</h1><ul>
<li><p>多态是同1个行为具有不同的表现形式或形态的能力</p>
</li>
<li><p>同1方法可以根据发送对象的不同而采用不同的行为方式</p>
<p><strong>多态就是事物的多种形态，1个对象在不同条件下所表现的不同形式</strong></p>
<p>举例：猫</p>
<p>我们可以说猫是猫：猫 cat&#x3D;new 猫（）;</p>
<p>我们也可以说猫是动物：动物 animal&#x3D;new 猫（）;</p>
<h3 id="1-格式"><a href="#1-格式" class="headerlink" title="1,格式"></a>1,格式</h3><ul>
<li><p>父类类型 变量名 &#x3D; new 子类类型（）；</p>
</li>
<li><p>然后通过 <strong>变量名.方法名（）</strong>调用在子类中重写的方法</p>
</li>
<li><p><strong>\多态体现为父类引用变量可以指向子类对象：\定义了1个父类类型的引用，指向新建的子类类型的对象，由于子类是继承他的父类的，所以父类类型的引用是可以指向子类类型的对象的</strong></p>
</li>
<li><h3 id="2，特点"><a href="#2，特点" class="headerlink" title="2，特点"></a>2，特点</h3></li>
</ul>
</li>
</ul>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 200531.png)</p>
<h6 id="父类"><a href="#父类" class="headerlink" title="&#x2F;&#x2F;父类"></a>&#x2F;&#x2F;父类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;午餐吃狗粮&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="子类Dog"><a href="#子类Dog" class="headerlink" title="子类Dog:"></a>子类Dog:</h6><p>&#x2F;&#x2F;子类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void eat() &#123;</span><br><span class="line">    System.out.println(&quot;晚餐吃狗粮&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//父类类型 对象 = new 子类类型（）</span><br><span class="line">Animal dog = new Dog();</span><br><span class="line"></span><br><span class="line">dog.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>控制台打印输出：调用的是子类中重写的方法</p>
<p>晚餐吃狗粮</p>
<h3 id="3，好处与弊端"><a href="#3，好处与弊端" class="headerlink" title="3，好处与弊端"></a>3，好处与弊端</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 212052.png)</p>
<p>左边与右边同名输出的是右边</p>
<h5 id="左边与右边不1样，假如右边没有左边的方法就无法使用，而左边除重名外无限制而右边的方法必须在左边存在"><a href="#左边与右边不1样，假如右边没有左边的方法就无法使用，而左边除重名外无限制而右边的方法必须在左边存在" class="headerlink" title="左边与右边不1样，假如右边没有左边的方法就无法使用，而左边除重名外无限制而右边的方法必须在左边存在"></a>左边与右边不1样，假如右边没有左边的方法就无法使用，而左边除重名外无限制而右边的方法必须在左边存在</h5><h2 id="4，多态的转型（向上转型：可以使用父类独有，向下转型：可以使用子类独有，但是无论如何转换重名仍然是子类）"><a href="#4，多态的转型（向上转型：可以使用父类独有，向下转型：可以使用子类独有，但是无论如何转换重名仍然是子类）" class="headerlink" title="4，多态的转型（向上转型：可以使用父类独有，向下转型：可以使用子类独有，但是无论如何转换重名仍然是子类）"></a>4，多态的转型（向上转型：可以使用父类独有，向下转型：可以使用子类独有，但是无论如何转换重名仍然是子类）</h2><p>由于子类无法输出父类没有的<br>而且我们在多态情况下调用方法时，首先会检查等式左边的引用类型（父类）中是否有该方法存在，如果父类中没有该方法，则编译器直接报错，也就代表着，父类无法调用子类独有的方法<br>既然编译都出错了，更别说运行了，这也是多态所造成的，因此如果我们想要调用子类的方法，必须做到向下转型</p>
<h3 id="父类引用指向子类对象-向上转型；"><a href="#父类引用指向子类对象-向上转型；" class="headerlink" title="父类引用指向子类对象&#x2F;向上转型；"></a>父类引用指向子类对象&#x2F;向上转型；</h3><p>Animal dog &#x3D; new Dog（）；</p>
<p><strong>左边的Animal是引用类型，而dog是由右边的Dog实例对象new出来的，在上面这个等式中，左边的引用Animal指向了子类的对象dog，原本是子类对象的dog完成了向上转型</strong></p>
<p>Animal父类是大范围的类型，而Cat和Dog类均属于动物类的子类，所以对于子类这种范围小的，我们可以自动转型给父类的变量，儿子向上转型，父亲是唯1的，因此是自动转换</p>
<p>使用格式：</p>
<p>父类类型  变量名  &#x3D; new 子类类型（）；</p>
<p>Animal       dog     &#x3D; new  Dog（）</p>
<p>通过由实例变量Dog类new出来的变量dog作为中介，使得引用变量Animal有所指向，从而完成了向上转型</p>
<p>相当于是</p>
<p>Animal       dog     &#x3D; （Animal) new  Dog（）</p>
<p>这是系统默认的</p>
<h3 id="向下转型-父亲变儿子，需要强制转换"><a href="#向下转型-父亲变儿子，需要强制转换" class="headerlink" title="向下转型(父亲变儿子，需要强制转换):"></a>向下转型(父亲变儿子，需要强制转换):</h3><p>向下转型是父类向子类转换的过程，这个过程需要强制转换（父亲变儿子肯定是需要条件的），1个可以将父类对象转换为子类对象，可以使用强制类型转换的格式，这便是向下转型</p>
<p><strong>对于Dog、Cat这些子类来说，他们只是父类Animal的1部分，而对于父类来说。他拥有更多的子类 牛、羊等</strong>，<strong>所以1旦父类要转换成子类，就必须指定要变成哪个子类，必须有指向性，所以向下转型才是强制转换</strong></p>
<p>向上转型</p>
<p>父类类型  变量名  &#x3D; new 子类类型（）；</p>
<p>Animal       dog     &#x3D; new  Dog（）</p>
<p>向下转型</p>
<p>子类类型 子类变量名 &#x3D; （子类类型） 父类变量名</p>
<p>Dog dog1 &#x3D; (Dog) dog;</p>
<p>dog1.walk； &#x2F;&#x2F;此时可以使用子类独有的方法了<br>&#x2F;&#x2F;dog1由dog强制转换到Dog形态的变量</p>
<h1 id="十三，抽象类"><a href="#十三，抽象类" class="headerlink" title="十三，抽象类"></a>十三，抽象类</h1><p>在java中1个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 081848.png)</p>
<p>animal a&#x3D;new Cat() </p>
<p><img src="C:\Users\31502\AppData\Roaming\Typora\typora-user-images\image-20240712083731083.png" alt="image-20240712083731083"></p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 192604.png)                                             </p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 192640.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 192650.png)</p>
<h1 id="十四，接口"><a href="#十四，接口" class="headerlink" title="十四，接口"></a>十四，接口</h1><h3 id="1，概述-3"><a href="#1，概述-3" class="headerlink" title="1，概述"></a>1，概述</h3><p>接口就是1种公共的规范资源，只要符合规范标准，大家都可以通用，Java中的接口更多的体现在对行为的抽象</p>
<p>接口可以理解为1种特殊的类，里面全部是由<strong>**全局常量*<em><strong>和</strong>公共的抽象方法</em>*所组成。接口是解决</strong>**Java无法使用多继承*<em><strong>的1种手段，但是接口在实际中更多的作用是</strong></em>*制定标准*<em><strong>的。或者我们可以直接把接口理解为</strong></em>*100%的抽象类*<em><strong>，既接口中的方法</strong></em>*必须全部****是抽象方法。（JDK1.8之前可以这样理解）</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 090230.png)</p>
<h3 id="2，接口的成员特点"><a href="#2，接口的成员特点" class="headerlink" title="2，接口的成员特点"></a>2，接口的成员特点</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 092833.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 191543.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 191435.png)</p>
<p>​																									void show（）；</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 191235.png)</p>
<h3 id="3，类与接口的关系"><a href="#3，类与接口的关系" class="headerlink" title="3，类与接口的关系"></a>3，类与接口的关系</h3><p>1个类可以进行多继承接口，初次之外还可继承1个父类</p>
<h3 id="4，抽象类与接口的区别"><a href="#4，抽象类与接口的区别" class="headerlink" title="4，抽象类与接口的区别"></a>4，抽象类与接口的区别</h3><ul>
<li><strong>抽象类</strong>更适合用于定义具有共同属性和行为的类族，可以提供1些通用的实现，同时保持其他方法的抽象性供子类去具体实现。</li>
<li><strong>接口</strong>则主要用于定义类的行为规范，特别适用于需要多个类共享相同行为的场景，以及实现多重继承的情况</li>
<li>调用的话都是采用先实例化才调用其中方法</li>
</ul>
<h1 id="十五，形参和返回值"><a href="#十五，形参和返回值" class="headerlink" title="十五，形参和返回值"></a>十五，形参和返回值</h1><h4 id="1，类名作为形参和返回值"><a href="#1，类名作为形参和返回值" class="headerlink" title="1，类名作为形参和返回值"></a>1，类名作为形参和返回值</h4><p>方法的形参是类名，其实需要的是该类的对象</p>
<p>方法的返回值是类名，其实返回的是该类的对象</p>
<h3 id="2，抽象类名作为形参和返回值"><a href="#2，抽象类名作为形参和返回值" class="headerlink" title="2，抽象类名作为形参和返回值"></a>2，抽象类名作为形参和返回值</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 144955.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 145021.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 145425.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 145455.png)</p>
<p>方法的形参是抽象类名，其实需要的是该抽象类的子类对象</p>
<p>方法的返回值是抽象类名，其实返回的是该抽象类的子类对象</p>
<h3 id="3，接口名作为形参和返回值"><a href="#3，接口名作为形参和返回值" class="headerlink" title="3，接口名作为形参和返回值"></a>3，接口名作为形参和返回值</h3><p>方法的形参是接口名，其实需要的是该接口的实现类对象</p>
<p>方法的返回值是接口名，其实返回的是该接口的实现类对象</p>
<h1 id="十六，内部类"><a href="#十六，内部类" class="headerlink" title="十六，内部类"></a>十六，内部类</h1><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><p>内部类：就是在1个类中定义1个类。</p>
<p>举例在1个类A的内部定义1个类B,类B就被称为内部类</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 160644.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 160654.png)</p>
<h5 id="class修饰类"><a href="#class修饰类" class="headerlink" title="class修饰类"></a>class修饰类</h5><p>内部类可以直接访问外部类的成员，包括私有</p>
<p>外部类要访问内不类的成员，必须创建对象</p>
<p>例子</p>
<p><img src="C:\Users\31502\AppData\Roaming\Typora\typora-user-images\image-20240712162813436.png" alt="image-20240712162813436"></p>
<h3 id="2-，成员内部类"><a href="#2-，成员内部类" class="headerlink" title="2.，成员内部类"></a>2.，成员内部类</h3><p>在类的成员位置:成员内部类</p>
<p>在类的局部位置: 局部内部类</p>
<p>成员内部类，外界如何创建对象使用呢？</p>
<p>格式：外部类名.内部类名 对象名&#x3D;外部类对象.内部类对象；</p>
<p>范例：outer.inner oi &#x3D; new outer().new inner()；</p>
<p>不针对 private</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 172232.png)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// final String y = &quot;good&quot;;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="string">&quot;good&quot;</span>;  <span class="comment">// JDK8 以后，final可以省略</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;  <span class="comment">// 定义在外部类的某个方法里</span></span><br><span class="line">        <span class="comment">// static int a = 10; 不能定义静态变量!  </span></span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">            <span class="comment">// 不能修改外部函数的局部变量</span></span><br><span class="line">			<span class="comment">// y = &#x27;yes&#x27;;</span></span><br><span class="line">            <span class="comment">// 只能访问被 final 修饰的外部函数的局部变量</span></span><br><span class="line">            <span class="comment">// JDK8 以后，如果外部函数的局部变量没有加 final,编译器会自动加 final</span></span><br><span class="line">            System.out.println(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    inner.demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3,局部内部类"></a>3,局部内部类</h3><p>局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用，该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 174225.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 174159.png)</p>
<h3 id="4，匿名内部类"><a href="#4，匿名内部类" class="headerlink" title="4，匿名内部类"></a>4，匿名内部类</h3><p>前提：存在1个类或者1个接口，这里的类可以使具体类也可以是抽象类</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 174723.png)</p>
<p>本质是1个<strong>继承了该类</strong>或者实现了该接口的<strong>子类匿名对象</strong></p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 180248.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 081627.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 180259.png)</p>
<h3 id="5，匿名内部类在开发中的使用"><a href="#5，匿名内部类在开发中的使用" class="headerlink" title="5，匿名内部类在开发中的使用"></a>5，匿名内部类在开发中的使用</h3><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是匿名内部类~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        animal.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分界线————————————</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract public void cry();</span><br><span class="line">&#125;//定义1个抽象类包含抽象方法cry</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        Animal animal = new Animal() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void cry() &#123;</span><br><span class="line">                System.out.println(&quot;这是匿名内部类~&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        animal.cry();</span><br><span class="line">    &#125;//继承了Animal的子类对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        outer.method();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在接口中是实现接口</p>
<p>在抽象类中是其子类</p>
<hr>
<h1 id="十七，Api"><a href="#十七，Api" class="headerlink" title="十七，Api"></a>十七，Api</h1><h3 id="1-math"><a href="#1-math" class="headerlink" title="1,math"></a>1,math</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 204104.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 204153.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 204410.png)</p>
<h2 id="2-system"><a href="#2-system" class="headerlink" title="2,system"></a>2,system</h2><p>System包含几个有用的类字段和方法，他不能被实例化</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 210448.png)</p>
<h3 id="3，object类"><a href="#3，object类" class="headerlink" title="3，object类"></a>3，object类</h3><p>构造方法：public Object()</p>
<p>回想面向对象中，为什么说子类的构造方法默认访问的是父类的无参构造方法？</p>
<p>因为他们的顶级父亲只有无参构造方法</p>
<p>equal方法</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 213128.png)</p>
<p>![屏幕截图 2024-07-12 213251](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 213251.png)</p>
<h3 id="4，Arrays"><a href="#4，Arrays" class="headerlink" title="4，Arrays"></a>4，Arrays</h3><p>①冒泡排序</p>
<p>排序：将一组数据按照固定的顺序进行排列</p>
<p>如果有n个数据进行排序，总共需要比较n-1次</p>
<p>每一次比较完毕，下一次的比较就会少一个数据参与</p>
<p>从第一个开始比较将大的放在最后。</p>
<p>②</p>
<p>需要导包</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 095050.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 100216.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 100222.png)</p>
<h3 id="5，基本类型包装类"><a href="#5，基本类型包装类" class="headerlink" title="5，基本类型包装类"></a>5，基本类型包装类</h3><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据</p>
<p>常用的操作之一：用于基本数据类型与字符串之间的转换</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 104816.png)</p>
<h4 id="除了char和int都是首字母大写"><a href="#除了char和int都是首字母大写" class="headerlink" title="除了char和int都是首字母大写"></a>除了char和int都是首字母大写</h4><p>①integer</p>
<p> Integer i1&#x3D;new Integer(“100”)</p>
<p>sout(i1)</p>
<p>输出的是100</p>
<p>②int 和String的相互转换</p>
<p>用于基本类型和字符串之间的相互转换</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 111542.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 111512.png)</p>
<p>③字符串数据排序例子</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 151705.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 111512.png)</p>
<p>⑤自动装箱和拆箱</p>
<p>装箱：把基本数据类型转换为对应的包装类类型</p>
<p>拆箱：把包装类类型转换为对应的基本类型</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 171635.png)</p>
<p>⑥日期类</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 172158.png)</p>
<p>需要实例化</p>
<p>Date b&#x3D;new Date()使用</p>
<p>实例化自动打印当前时期和时间</p>
<p>b.getData()&#x2F;&#x2F;将时间转换成毫秒数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date now = new Date();</span><br><span class="line">       System.out.println(&quot;当前时间: &quot; + now);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long currentTimeMillis = now.getTime();</span><br><span class="line">       System.out.println(&quot;当前时间的毫秒数: &quot; + currentTimeMillis);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：1689244245000</span><br></pre></td></tr></table></figure>

<p>b.setTime(time)&#x2F;&#x2F;将毫秒数转换为时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Date customDate = new Date();</span><br><span class="line">7        </span><br><span class="line">8        // 计算从1970年1月1日到目标日期的毫秒数</span><br><span class="line">9        long targetTimeMillis = 1672531200000L; // 2023年1月1日 00:00:00 的毫秒数</span><br><span class="line">10        </span><br><span class="line">11        // 使用setTime()方法设置时间</span><br><span class="line">12        customDate.setTime(targetTimeMillis);</span><br><span class="line">13        </span><br><span class="line">14        // 输出设置后的时间</span><br><span class="line">15        System.out.println(customDate);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：Sat Jan 01 00:00:00 GMT 2023</span><br></pre></td></tr></table></figure>

<h4 id="SimpleDataFormat"><a href="#SimpleDataFormat" class="headerlink" title="SimpleDataFormat"></a>SimpleDataFormat</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 175309.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 201157.png)</p>
<p>⑥calendar </p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 211006.png)</p>
<p>![屏幕截图 2024-07-13 212600](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 212600.png)</p>
<p>⑦</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 213149.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 214734.png)</p>
<h1 id="十八-异常"><a href="#十八-异常" class="headerlink" title="十八,异常"></a>十八,异常</h1><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h3><p>程序出现了不正常的情况</p>
<p>error：严重问题，不需要处理</p>
<p>exception:称为异常类，他表示程序本身可以处理的问题</p>
<p>RuntimeException:在编译器是不检查的，出现问题后，需要我们回来修改代码</p>
<p>非RuntimeException：编译器就必须处理的，否则程序不能通过编译，就更不能正常运行了</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 081714.png)</p>
<h3 id="2，jym处理方法"><a href="#2，jym处理方法" class="headerlink" title="2，jym处理方法"></a>2，jym处理方法</h3><p>把异常的名称，异常原因及异常出现的位置等信息输出在了控制台</p>
<p>程序停止执行</p>
<h3 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3.异常处理"></a>3.异常处理</h3><p>①try…catch…![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 082604.png)</p>
<p>从  ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 083333.png)</p>
<p>②Throwable成员方法</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 083501.png)</p>
<p>输出getMessage&#x3D;printStackTrace</p>
<h3 id="4-编译时异常和运行时异常区别"><a href="#4-编译时异常和运行时异常区别" class="headerlink" title="4.编译时异常和运行时异常区别"></a>4.编译时异常和运行时异常区别</h3><p>编译时异常：必须显示处理，否则程序就会发生错误，无法通过编译</p>
<p>运行时异常：无需显示处理，也可以和编译时异常一样处理    </p>
<h4 id="4，throws处理异常"><a href="#4，throws处理异常" class="headerlink" title="4，throws处理异常"></a>4，throws处理异常</h4><p>throws 异常类是方法上的，不是main函数上的；意为方法上的错误留到main函数上修正</p>
<p>编译时异常必须要处理：try…catch…或者throws,如果采用throws这种方案，将来谁调用谁处理</p>
<h3 id="5，自定义异常"><a href="#5，自定义异常" class="headerlink" title="5，自定义异常"></a>5，自定义异常</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 095551.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 095719.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 103243.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 103414.png)</p>
<h3 id="6-throws和throw的区别"><a href="#6-throws和throw的区别" class="headerlink" title="6.throws和throw的区别"></a>6.throws和throw的区别</h3><p>throws：用在方法声明后面，跟的是异常类名</p>
<p>​				表示抛出异常，由该方法的调用者来处理</p>
<p>​				表示出现异常的一种可能性，并不一定会发生这些异常</p>
<p>throw: 用在方法体内，跟的是异常对象名</p>
<p>​			表示抛出异常，由方法体内的语句处理</p>
<p>​			执行throw一定抛出了某种异常</p>
<h1 id="十九，集合进阶"><a href="#十九，集合进阶" class="headerlink" title="十九，集合进阶"></a>十九，集合进阶</h1><h4 id="1-集合类体系结构"><a href="#1-集合类体系结构" class="headerlink" title="1.集合类体系结构"></a>1.集合类体系结构</h4><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 110316.png)</p>
<h4 id="2，①collection集合概念和使用"><a href="#2，①collection集合概念和使用" class="headerlink" title="2，①collection集合概念和使用"></a>2，①collection集合概念和使用</h4><p>是单例集合的顶层接口，他表示一组对象，这些对象也称为Collection的元素</p>
<p>JDK不提供此接口的任何直接实现，他提供更具体的子接口（如Set和List）实现</p>
<h5 id="创建Collection集合的对象："><a href="#创建Collection集合的对象：" class="headerlink" title="创建Collection集合的对象："></a>创建Collection集合的对象：</h5><p>多态的方式</p>
<p>具体的实现类ArrayList</p>
<h4 id="②，collection集合常用方法"><a href="#②，collection集合常用方法" class="headerlink" title="②，collection集合常用方法"></a>②，collection集合常用方法</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 142006.png)</p>
<h4 id="③，collection的遍历"><a href="#③，collection的遍历" class="headerlink" title="③，collection的遍历"></a>③，collection的遍历</h4><p>lterator:迭代器，集合的专用遍历方式 </p>
<p>lterator<e>iterator():返回此集合中元素的迭代器，通过集合的iterator()方法得到</p>
<p>迭代器是通过集合的iterator()方法得到的，所以我们说他是依赖于集合而存在的</p>
<p>lterator中的常用方法</p>
<p>E.next():f返回迭代中的下一个元素</p>
<p>boolean hasNext():如果迭代有更多元素，则返回true</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 150508.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 150529.png)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;student&gt; it=a.iterator();//设置一个it迭代器用于遍历a中student元素</span><br></pre></td></tr></table></figure>

<h5 id="④，集合使用步骤"><a href="#④，集合使用步骤" class="headerlink" title="④，集合使用步骤"></a>④，集合使用步骤</h5><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 151428.png)</p>
<p>先添加元素，再创建迭代器</p>
<h4 id="2-list①"><a href="#2-list①" class="headerlink" title="2.list①"></a>2.list①</h4><p>List集合概念</p>
<p>有序集合（也称为序列），用户可以精准控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素</p>
<p>与Set集合不同，列表通常允许重复的元素</p>
<p>List集合特点</p>
<p>有序：存储和取出的元素顺序一致</p>
<p>可重复：存储的元素可以重复</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 163423.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 164543.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 165116.png)</p>
<p>迭代器方式</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 170126.png)</p>
<p>for循环方式</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 170207.png)</p>
<p>②并发修改异常</p>
<p>ConcurrentModificationException</p>
<p>产生原因：迭代器遍历过程中，通过集合对象修改了集合元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</p>
<p>解决方案</p>
<p>用for循环遍历，然后用集合对象做对应的操作即可</p>
<p>③列表迭代器 </p>
<p>![《](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 174842.png)</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 192615.png)</p>
<p>不会像普通迭代器一样产生并发错误，因为他会将实际值赋给预期值</p>
<h2 id="3，增强for循环"><a href="#3，增强for循环" class="headerlink" title="3，增强for循环"></a>3，增强for循环</h2><p>简化数组和collection集合的遍历</p>
<p>实现Iterable接口的类允许其对象成为增强型for语句的目标</p>
<p>它是jdk5之后出现的，其内部原理是一个Iterator迭代器</p>
<p> 增强for的格式</p>
<h2 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h2><p>for(元素数据类型 变量名&#x2F;&#x2F;<em>这个数据类型指的是数组&#x2F;集合内部存储的值</em>:数组或者Collection集合){</p>
<p>要做的循环</p>
<p>&#x2F;&#x2F;在此使用变量即可，该变量就是元素&#x2F;&#x2F;}</p>
<p>范例：</p>
<p>int[] arr&#x3D;{1,2,3,4,5};</p>
<p>for(int i:arr&#x2F;&#x2F;将arr中元素赋给i){</p>
<p>System.out.println(i);	</p>
<p>}</p>
<p>![ ](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 194835.png)</p>
<p>三种方式遍历集合</p>
<p>![:](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 195942.png)</p>
<p>有索引选for</p>
<h4 id="④，数据结构"><a href="#④，数据结构" class="headerlink" title="④，数据结构"></a>④，数据结构</h4><p>入栈出栈：先进后出</p>
<p>入队出队：先进先出，后进后出</p>
<p> 数组：</p>
<p>数组是一种查询快，增删慢的模型</p>
<p>查询数据通过索引定位，查询任意数据耗时相同，查询效率高</p>
<p>删除数据时，要将原始数据删除，同时后面每个数据前移，删除效率低</p>
<p>添加数据时，添加位置后每个数据后移，再添加元素，添加效率低</p>
<p>链表：</p>
<p>链表是一种查询慢，增删快的模型</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 203221.png)</p>
<p>在数据AC之间添加一个数据B，保存在地址54位置 删除数据BD之间的数据C</p>
<p>查询必须从头节点开始</p>
<h3 id="⑤，List集合子类特点"><a href="#⑤，List集合子类特点" class="headerlink" title="⑤，List集合子类特点"></a>⑤，List集合子类特点</h3><p>List集合常用子类：ArrayList,LinkedList</p>
<p>ArrayList:底层数据结构是数组，查询块，增删慢</p>
<p>Linklist：底层数据结构是链表，查询慢，增删块</p>
<h3 id="⑥-LinkedList集合的特有功能"><a href="#⑥-LinkedList集合的特有功能" class="headerlink" title="⑥.LinkedList集合的特有功能"></a>⑥.LinkedList集合的特有功能</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 212357.png)</p>
<h2 id="4-set集合"><a href="#4-set集合" class="headerlink" title="4.set集合"></a>4.set集合</h2><p>特点：</p>
<p>不包括重复元素的集合</p>
<p>没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>哈希值：是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p>
<p> Object类中有一个方法可以获取对象的哈希值</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 215035.png)</p>
<h4 id="②HashSet集合概述和特点"><a href="#②HashSet集合概述和特点" class="headerlink" title="②HashSet集合概述和特点"></a>②HashSet集合概述和特点</h4><p>HashSet集合特点</p>
<p>底层数据结构是哈希表</p>
<p>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</p>
<p>没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>由于是Set集合，所以是不包含重复元素的集合</p>
<h4 id="③哈希表"><a href="#③哈希表" class="headerlink" title="③哈希表"></a>③哈希表</h4><p>底层为数组+链表实现，可以说是一个元素为链表的<strong>数组</strong></p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-16 163814.png)</p>
<p>由于哈希值的根据地址计算，所以纵使值相同，哈希值也不同需要重写哈希值及hashCode（）和equals()自动生成alt+insert</p>
<h4 id="④，linkhashset集合概述和特点"><a href="#④，linkhashset集合概述和特点" class="headerlink" title="④，linkhashset集合概述和特点"></a>④，linkhashset集合概述和特点</h4><p>LinkHashSet集合特点</p>
<p><strong>哈希表和链表实现的Set接口</strong></p>
<p><strong>哈希表和链表实现的Set接口，具有可预测的迭代次序</strong></p>
<p><strong>有哈希表保证元素唯一，也就是说没有重复的元素</strong></p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-16 174547.png)</p>
<h4 id="⑤Treeset集合概述和特点"><a href="#⑤Treeset集合概述和特点" class="headerlink" title="⑤Treeset集合概述和特点"></a>⑤Treeset集合概述和特点</h4><p>TreeSet集合特点</p>
<p>1,元素有序，这里的顺序不是指存储和取出的顺序,而是按照一定的规则进行排序，具体排序方式取决于构造方法</p>
<p>2,TreeSet():根据其元素的自然排序进行排序</p>
<p>3,TreeSet(Comparator comparator):根据指定的比较器进行排序</p>
<p>4,没有带索引的方法，所以不能使用普通for循环遍历</p>
<p>5,由于是Set集合，所以不包含重复元素的集合</p>
<h4 id="⑥，自然排序Comparable的使用（return的是正数把S2放在S1前面，）s2-s1为从大到小，s1-s2为从小到大"><a href="#⑥，自然排序Comparable的使用（return的是正数把S2放在S1前面，）s2-s1为从大到小，s1-s2为从小到大" class="headerlink" title="⑥，自然排序Comparable的使用（return的是正数把S2放在S1前面，）s2-s1为从大到小，s1-s2为从小到大"></a>⑥，自然排序Comparable的使用（return的是正数把S2放在S1前面，）s2-s1为从大到小，s1-s2为从小到大</h4><p>存储学生对象并遍历，创 建TreeSet集合使用无参构造方法</p>
<p>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</p>
<p>当你尝试向 <code>TreeSet</code> 添加一个新元素时，<code>add()</code> 方法需要确定该元素在树中的适当位置，以保持树的排序性质。为了找到这个位置，<code>TreeSet</code> 需要比较新元素与其他已存在的元素。如果新元素实现了 <code>Comparable</code> 接口，那么 <code>TreeSet</code> 将调用新元素的 <code>compareTo()</code> 方法来与树中现有的元素进行比较。</p>
<p><code>compareTo()</code> 方法返回一个整数值，指示了新元素相对于现有元素的顺序：</p>
<ul>
<li>如果 <code>compareTo()</code> 返回负数，表示新元素小于现有元素，<code>TreeSet</code> 将继续在现有元素的左子树中查找适当位置。</li>
<li>如果 <code>compareTo()</code> 返回正数，表示新元素大于现有元素，<code>TreeSet</code> 将继续在现有元素的右子树中查找适当位置。</li>
<li>如果 <code>compareTo()</code> 返回零，表示新元素与现有元素相等（根据 <code>Comparable</code> 接口的自然排序规则），在这种情况下，<code>TreeSet</code> 不会添加重复的元素，因为它只存储唯一的元素。</li>
</ul>
<p>总结：1，当你add新数据时会自动安排位置及调用compare to 方法</p>
<p>​			2，用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</p>
<p>​			3，自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(to)方法</p>
<p>​			4，重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;<span class="comment">//实现接口</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">	<span class="built_in">super</span>();</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">	<span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写compareTo</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student s)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//		return 0;	//返回0则认为是同一个元素，不添加</span></span><br><span class="line"><span class="comment">//		return 1;	//返回正数是升序</span></span><br><span class="line"><span class="comment">//		return -1; //返回负数是倒序</span></span><br><span class="line">		<span class="comment">// 按照年龄从小到达排序</span></span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">this</span>.age - s.age) == <span class="number">0</span> ;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#96;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a小明&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;b小红&quot;</span>, <span class="number">21</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;c小李&quot;</span>, <span class="number">22</span>);</span><br><span class="line">		<span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d小蓝&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		<span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d小蓝&quot;</span>, <span class="number">10</span>);</span><br><span class="line">		ts.add(s1);</span><br><span class="line">		ts.add(s2);</span><br><span class="line">		ts.add(s3);</span><br><span class="line">		ts.add(s4);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (Student s : ts) &#123;</span><br><span class="line">			System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * a小明,10 d小蓝,10 b小红,21 c小李,22</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>⑦比较器排序Comparator的使用</p>
<p>1，用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</p>
<p>2，比较器排序，就是让集合构造方法接受Compartor的实现类对象，重写compare(To1,To2)方法</p>
<p>3，重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">	private String name;</span><br><span class="line">	private int age;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student(String name, int age) &#123;</span><br><span class="line">	super();</span><br><span class="line">	this.name = name;</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">	return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">	this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">	return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">	this.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line">				<span class="comment">// this.age - s.age</span></span><br><span class="line">				<span class="comment">// s1,s2</span></span><br><span class="line">				<span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">​	<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a小明&quot;</span>, <span class="number">10</span>);</span><br><span class="line">​	<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;b小红&quot;</span>, <span class="number">21</span>);</span><br><span class="line">​	<span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;c小李&quot;</span>, <span class="number">22</span>);</span><br><span class="line">​	<span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d小蓝&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">​	<span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d小蓝&quot;</span>, <span class="number">10</span>);</span><br><span class="line">​	ts.add(s1);</span><br><span class="line">​	ts.add(s2);</span><br><span class="line">​	ts.add(s3);</span><br><span class="line">​	ts.add(s4);</span><br><span class="line"></span><br><span class="line">​	<span class="keyword">for</span> (Student s : ts) &#123;</span><br><span class="line">​		System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">​	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5，泛型"><a href="#5，泛型" class="headerlink" title="5，泛型"></a>5，泛型</h2><h4 id="①，泛型本质是参数化数据类型"><a href="#①，泛型本质是参数化数据类型" class="headerlink" title="①，泛型本质是参数化数据类型"></a>①，泛型本质是参数化数据类型</h4><p>​		参数化类型即将类型由原来的具体的类型参数化，然后在使用&#x2F;调用时传入具体的类型</p>
<p>可以用在类，方法和接口中，分别被称为泛型类，泛型方法，泛型接口</p>
<h4 id="②，泛型定义格式："><a href="#②，泛型定义格式：" class="headerlink" title="②，泛型定义格式："></a>②，泛型定义格式：</h4><p>1，&lt;类型&gt;：制定一种类型的格式。这里的类型可以看成是形参</p>
<p>2，&lt;类型1，类型2…&gt;:指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参,将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用类型</p>
<p>3，泛型的好处：</p>
<p>4，把运行时期的问题提前到了编译期间，避免了强制类型转换</p>
<p>e.g.Collection c &#x3D; new ArrayList();</p>
<p>​		Collection<String> c &#x3D; new ArrayList<String>()</p>
<p>允许使用参数化的类型，如 List<T>，这里的 T 是类型参数，可以是任何具体的类型。</p>
<h4 id="③泛型类"><a href="#③泛型类" class="headerlink" title="③泛型类"></a>③泛型类</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 101940.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 102054.png)</p>
<p>泛型方法的定义格式：</p>
<p>格式：修饰符&lt;类型&gt;返回值类型 方法名(类型 变量名){}</p>
<p>范例:public<T>void show(T t){}</p>
<p>当一个方法的形参不确定的情况下,会使用泛型方法</p>
<p>泛型方法可以脱离泛型类单独存在</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 102304.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 102331.png)</p>
<h4 id="④泛型接口"><a href="#④泛型接口" class="headerlink" title="④泛型接口"></a>④泛型接口</h4><p> 格式:修饰符interface接口名&lt;类型&gt;{}</p>
<p>范例:public interface Generic<T>{}</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 110611.png)</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 110544.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 110743.png)</p>
<p>⑤类型通配符</p>
<p>为了表示各种泛型List的父类，可以使用类型通配符</p>
<h4 id="⑤类型通配符"><a href="#⑤类型通配符" class="headerlink" title="⑤类型通配符&lt;?&gt;"></a>⑤类型通配符&lt;?&gt;</h4><p><strong>当我们为一个类指定泛型并创建对象之后，对象中不仅可以加入泛型所指定的类对象，还可以加入泛型类子类的类对象，这就是数据的继承性。</strong></p>
<p>List&lt;?&gt;:表示元素类型未知的List，它的元素可以匹配任何的类型</p>
<p>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</p>
<p>如果我们说不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p>
<h4 id="类型通配符上限"><a href="#类型通配符上限" class="headerlink" title="类型通配符上限:&lt;?extends类型&gt;"></a>类型通配符上限:&lt;?extends类型&gt;</h4><p>List&lt;?extends Number&gt;:他表示的类型是Number或者其子类型</p>
<p>除了可以指定类型通配符的上限，还有下线</p>
<h4 id="类型通配符下限"><a href="#类型通配符下限" class="headerlink" title="类型通配符下限:&lt;?super类型&gt;"></a>类型通配符下限:&lt;?super类型&gt;</h4><p>List&lt;?super Number&gt;:他表示的类型是Number或者其父类型</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 144025.png)</p>
<h4 id="⑥可变参数"><a href="#⑥可变参数" class="headerlink" title="⑥可变参数"></a>⑥可变参数</h4><p>  可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了</p>
<p>格式：修饰符返回值类型方法名(数据类型…变量名){}</p>
<p>范例：public static int sum(int…a){}</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 145738.png)</p>
<p>![屏幕截图 2024-07-17 145743](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 145743.png)</p>
<p>可变参数注意事项</p>
<p>这里的变量其实是一个数组</p>
<p>如果一个方法有多个参数，包含可变参数，可变参数要放在最后</p>
<p>⑦可变参数的使用</p>
<p>1，Arrays</p>
<p>public static<T>List<t><strong>asList</strong>(T…a):返回由指定数组支持的固定大小的列表</p>
<p>返回的集合不能做增删操作，可以做修改操作</p>
<p>2，List接口 </p>
<p>public static<E>List<E>**of(**E…elements):返回包含任意数量元素的不可变列表</p>
<p>返回的集合不能做增删改操作</p>
<p>3，set接口</p>
<p>public static<E>Set<E><strong>of</strong>(E…elements):返回一个包含任意数量元素的不可变集合</p>
<p>再给元素时，不能给重复的元素</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 152718.png)</p>
<h3 id="6，map集合"><a href="#6，map集合" class="headerlink" title="6，map集合"></a>6，map集合</h3><h4 id="①-概述"><a href="#①-概述" class="headerlink" title="① 概述"></a>① 概述</h4><p>Interface Map&lt;K,V&gt;  K：键的类型;V:值的类型</p>
<p>将键映射到值的对象;不能包含重复到键;每个键可以映射到最多的一个值</p>
<p>举例:学生的学号和姓名</p>
<p>​	itheima001 林青霞</p>
<p>​	itheima002 张曼玉</p>
<p>​	itheima003 王祖贤</p>
<p>创建Map集合的对象</p>
<p>多态得方式</p>
<p>具体的实现类HashMap </p>
<p>Map&lt;String,String&gt; map&#x3D; new HashMap&lt;String,String&gt;();</p>
<h4 id="②-Map集合的基本功能"><a href="#②-Map集合的基本功能" class="headerlink" title="② Map集合的基本功能"></a>② Map集合的基本功能</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 160125.png)</p>
<p>③Map集合的获取功能</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 172349.png)</p>
<p><img src="C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 173555.png" style="zoom:200%;" />![屏幕截图 2024-07-17 173544](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 173544.png)</p>
<h4 id="③Map集合的遍历（方式1）"><a href="#③Map集合的遍历（方式1）" class="headerlink" title="③Map集合的遍历（方式1）"></a>③Map集合的遍历（方式1）</h4><p>夫妻对集合</p>
<p>思路</p>
<p>把所有的丈夫集中起来</p>
<p>遍历丈夫的集合，<em>获取到每一个丈夫</em>********</p>
<p>根据丈夫去找对应的妻子</p>
<h3 id="转换成map"><a href="#转换成map" class="headerlink" title="转换成map:"></a>转换成map:</h3><p>获取所有键的集合。用keySet()方式实现</p>
<p>遍历键的集合，获取每一个键。用增强for实现</p>
<p>根据键去找值。用get(Object key)方式实现&#x2F;&#x2F;<code>map.get(key)</code> 是在 Java 的 <code>Map</code> 接口中定义的一个方法，用于根据提供的键（<code>key</code>）检索与之关联的值</p>
<p>如果 <code>key</code> 存在于 <code>Map</code> 中，方法将返回与该键关联的值。</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 174724.png)</p>
<h4 id="④Map集合的遍历（方式2）"><a href="#④Map集合的遍历（方式2）" class="headerlink" title="④Map集合的遍历（方式2）"></a>④Map集合的遍历（方式2）</h4><p>思路</p>
<p>获取所有结婚证的集合</p>
<p>遍历结婚证的集合，得到每一个结婚证</p>
<p>根据结婚证获取丈夫和妻子</p>
<h5 id="转换为Map集合中的操作："><a href="#转换为Map集合中的操作：" class="headerlink" title="转换为Map集合中的操作："></a>转换为Map集合中的操作：</h5><p><em>获取所有键值对对象的集合</em></p>
<p>Set&lt;Map.Entry&lt;k,y&gt;&gt;entrySet():获取所有键值对对象的集合</p>
<p><em>遍历键值对对象的集合，得到每一个键值对对象</em></p>
<p>用增强for实现，得到每一个Map.Entry</p>
<p><em>根据键值对对象获取键和值</em></p>
<p>用getKey()得到键</p>
<p>用getValue()得到值</p>
<p>![](C:\Users\31502\Desktop\屏幕截图 2024-07-17 180307.png)</p>
<p><code>getKey()</code> 是 <code>Map.Entry</code> 接口的一个方法，它返回当前键值对中的键。</p>
<ol>
<li><strong><code>Map.get(key)</code></strong>:<ul>
<li>这个方法用于根据给定的键从<code>Map</code>中检索值。如果键存在，它返回与该键关联的值；如果键不存在，它返回<code>null</code>。</li>
<li>语法：<code>V get(Object key)</code>，其中<code>V</code>是<code>Map</code>中值的类型。</li>
<li>它用于获取与特定键关联的值。</li>
</ul>
</li>
<li><strong><code>Map.Entry.getKey()</code></strong>:<ul>
<li>这个方法用于从<code>Map.Entry</code>对象中获取键。<code>Map.Entry</code>是一个接口，表示<code>Map</code>中的一个键值对。</li>
<li>语法：<code>K getKey()</code>，其中<code>K</code>是<code>Map</code>中键的类型。</li>
<li>它用于获取<code>Map.Entry</code>对象中的键。</li>
</ul>
</li>
</ol>
<h4 id="⑤，嵌套遍历"><a href="#⑤，嵌套遍历" class="headerlink" title="⑤，嵌套遍历"></a>⑤，嵌套遍历</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 201032.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 201019.png)</p>
<p>_______________________——-</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 203510.png)</p>
<h2 id="7-Collections概念和使用（导包）"><a href="#7-Collections概念和使用（导包）" class="headerlink" title="7,Collections概念和使用（导包）"></a>7,Collections概念和使用（导包）</h2><p>Collections类的概述</p>
<p>是针对集合操作的工具类</p>
<p>Collections类的常用方法</p>
<p>public static&lt;T extends Comparable&lt;?super T&gt;&gt;void <strong>sort</strong>(List<T>list):将指定的列表按升序排列</p>
<p>public static void <strong>reverse</strong>(List&lt;?&gt;list):反转指定列表中元素的顺序</p>
<p>public static void <strong>shuffle</strong>(List&lt;?&gt;list):使用默认的随机源排列指定的列表</p>
<p>由于是静态方法可直接调用不需要实例化</p>
<p>看一下comepareto</p>
<h1 id="二十，io流"><a href="#二十，io流" class="headerlink" title="二十，io流"></a>二十，io流</h1><h2 id="1-file（需要导包）：它是文件和目录路径名的抽象表示"><a href="#1-file（需要导包）：它是文件和目录路径名的抽象表示" class="headerlink" title="1,file（需要导包）：它是文件和目录路径名的抽象表示"></a>1,file（需要导包）：它是文件和目录路径名的抽象表示</h2><p>文件和目录是可以通过File封装成对象的</p>
<p>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。他可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的</p>
<h5 id="①构造方法"><a href="#①构造方法" class="headerlink" title="①构造方法"></a>①构造方法</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 101244.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 101959.png)</p>
<p>是创建实例不是创建File</p>
<h5 id="②File类创建功能"><a href="#②File类创建功能" class="headerlink" title="②File类创建功能"></a>②File类创建功能</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 102225.png)</p>
<p>目录&#x2F;存在返回false，不存在创建并返回true; </p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 104046.png)</p>
<h5 id="③file类判断和获取功能"><a href="#③file类判断和获取功能" class="headerlink" title="③file类判断和获取功能"></a>③file类判断和获取功能</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 104236.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 110211.png)</p>
<h5 id="④File类删除功能"><a href="#④File类删除功能" class="headerlink" title="④File类删除功能"></a>④File类删除功能</h5><p>public boolen delete()</p>
<p>删除由此抽象路径名表示的文件或目录</p>
<p>绝对路径:完整的路径名，不需要任何其他信息就可以定位它表示的文件</p>
<p>相对路径：必须使用取自其他路径名的信息进行解释。例如myFile\java.txt</p>
<p>删除目录注意事项</p>
<p>如果一个目录中有内容，就不能直接删除，必须先删除其中内容</p>
<h5 id="⑤递归"><a href="#⑤递归" class="headerlink" title="⑤递归"></a>⑤递归</h5><p>以编程的角度来看，递归是指方法定义中调用方法本身的现象</p>
<p><strong>思路</strong>:</p>
<p>把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解</p>
<p>递归策略只需少量程序就可以描述出解题过程所需要的多次重复计算</p>
<h5 id="递归解决问题要找到两个内容"><a href="#递归解决问题要找到两个内容" class="headerlink" title="递归解决问题要找到两个内容:"></a>递归解决问题要找到两个内容:</h5><p>递归出口:否则会出现内存溢出</p>
<p>递归规则:与原问题相似的规模较小的问题</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 143735.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 143746.png)</p>
<p>递归阶乘</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 150646.png)</p>
<h2 id="2，字节流"><a href="#2，字节流" class="headerlink" title="2，字节流"></a>2，字节流</h2><h4 id="①io流概述："><a href="#①io流概述：" class="headerlink" title="①io流概述："></a>①io流概述：</h4><p>文件输出流（FileOutputStream）是Java中用于向文件写入字节流的一种方式。</p>
<p>IO:输入&#x2F;输出(Input&#x2F;Output)</p>
<p>流：是一种抽象概念，是对数据运输的总称。也就是说数据在设备间的运输成为流，流的本质是数据运输</p>
<p>io流就是用来处理设备间数据运输问题的</p>
<p>常见的应用:文件复制；文件上传;文件下载</p>
<p>输入：读数据，输出：写数据</p>
<p><strong>根据数据类型来分：</strong></p>
<p><em><strong>字节流：</strong></em></p>
<p><em><strong>字节输入流;字节输出流</strong></em></p>
<p><em><strong>字符流：</strong></em></p>
<p><em><strong>字符输入流;字符输出流</strong></em></p>
<p><strong>注：如果数据通过Window自带的记事本软件打开，我们还可以读懂里面的内容，就使用字符流，否则使用字节流</strong></p>
<p>  <strong>②写数据</strong></p>
<p><strong>字节流抽象基类</strong></p>
<p><strong>InputStream:这个抽象类是表示字节输出流的所有类的超类</strong></p>
<p><strong>OutputStream:这个抽象类是表示字节输出流的所有类的超类</strong></p>
<p><strong>子类名特点:子类名称都是以其父类名作为子类名的后缀</strong></p>
<p><strong>FileOutStream:文件输出流用于将数据写入File</strong></p>
<p><strong>FileOutputStream(String name):创建文件输出流以指定的名称写入文件</strong></p>
<p><strong>使用字节输出流写数据的步骤：</strong></p>
<p><strong>创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，R让字节输出流对象指向文件)</strong></p>
<p><strong>调用字节输出流对象的写数据方法</strong></p>
<p><strong>释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)</strong></p>
<h3 id="③字节流写数据的3种方式"><a href="#③字节流写数据的3种方式" class="headerlink" title="③字节流写数据的3种方式"></a>③字节流写数据的3种方式</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 162117.png)</p>
<p><code>FileOutputStream()</code> 括号内的参数是指定目标文件的信息，不是要输出的具体内容 </p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 172113.png)</p>
<h4 id="④换行和追加写入"><a href="#④换行和追加写入" class="headerlink" title="④换行和追加写入"></a>④换行和追加写入</h4><p><strong>换行写完数据化，加换行符</strong></p>
<p>windows:\r\n</p>
<p>linux:\n</p>
<p>mac:\r</p>
<p>![](C:\Users\31502\Desktop\屏幕截图 2024-07-18 175743.png)</p>
<p><strong>追加写入：</strong></p>
<p>publicFileOutStream(String name,boolean append)</p>
<p>创建文件输出流以指定的名称写入文件。如果第二个参数为true,则字节将写入文件的末尾而不是开头</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 175743.png)</p>
<h4 id="⑤字节流写数据加异常处理（kan"><a href="#⑤字节流写数据加异常处理（kan" class="headerlink" title="⑤字节流写数据加异常处理（kan)"></a>⑤字节流写数据加异常处理（kan)</h4><p>finally:在异常处理时提供finally块来执行所有清除操作。比如说IO流中的释放资源</p>
<p>特点:被finally控制的语句一定会执行，除非JYM退出</p>
<p>try{</p>
<p>}catch(异常类名 变量名){</p>
<p>异常 的处理代码;</p>
<p>}finally{</p>
<p>执行所有清除操作；</p>
<p>}</p>
<h4 id="①字节流读数据-一次读一个字节数据"><a href="#①字节流读数据-一次读一个字节数据" class="headerlink" title="①字节流读数据(一次读一个字节数据)"></a>①字节流读数据(一次读一个字节数据)</h4><p>FileInputStream是用来读文件数据的流，所以它需要一个文件对象用来实例化，这个文件可以是一个File对象,也可以是文件名路径字符串.【这里文件不存在会抛错】</p>
<p>FilelnputStream:从文件系统中的文件获取输入字节</p>
<p>需求:把文件fos.txt中的内容读取出来再控制台输出</p>
<p>FilelnputStream(String name):通过打开与实际文件的连接来创建一个FilelnputStream，该文件由文件系统中的路径名name命名</p>
<p>使用字节输入流读数据的步骤:</p>
<p>①创建字节输入流对象&#x2F;&#x2F;FileInputStream(String name)</p>
<p>②调用字节输入流对象的读数据方法&#x2F;&#x2F;int read():从该输入流读取一个字节的数据</p>
<p>③释放资源   ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 201034.png)</p>
<h5 id="注意：在Java中，InputStream-的-read-方法每次调用时，都会尝试从输入流中读取下一个字节。这意味着，如果你连续调用两次-read-方法（假设输入流中有足够的数据），第一次调用会读取流中的第一个字节，而第二次调用会读取紧随其后的第二个字节。"><a href="#注意：在Java中，InputStream-的-read-方法每次调用时，都会尝试从输入流中读取下一个字节。这意味着，如果你连续调用两次-read-方法（假设输入流中有足够的数据），第一次调用会读取流中的第一个字节，而第二次调用会读取紧随其后的第二个字节。" class="headerlink" title="注意：在Java中，InputStream 的 read() 方法每次调用时，都会尝试从输入流中读取下一个字节。这意味着，如果你连续调用两次 read() 方法（假设输入流中有足够的数据），第一次调用会读取流中的第一个字节，而第二次调用会读取紧随其后的第二个字节。"></a>注意：在Java中，<code>InputStream</code> 的 <code>read()</code> 方法每次调用时，都会尝试从输入流中读取下一个字节。这意味着，如果你连续调用两次 <code>read()</code> 方法（假设输入流中有足够的数据），第一次调用会读取流中的第一个字节，而第二次调用会读取紧随其后的第二个字节。</h5><h5 id="read-从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据"><a href="#read-从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据" class="headerlink" title="read():从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据"></a>read():从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据</h5><h5 id="read-byte-b-：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）"><a href="#read-byte-b-：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）" class="headerlink" title="read(byte[] b)：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）"></a>read(byte[] b)：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）</h5><p>②复制文本文件</p>
<p>FileInputStream fis &#x3D; new FileInputStream(name)&#x2F;&#x2F;输出流对象</p>
<p>FileOutputStream fos&#x3D; new FileOutputStream(name)&#x2F;&#x2F;输入流对象</p>
<h4 id="②字节流读取数据（一次读一个字节数组数据"><a href="#②字节流读取数据（一次读一个字节数组数据" class="headerlink" title="②字节流读取数据（一次读一个字节数组数据)"></a>②字节流读取数据（一次读一个字节数组数据)</h4><p>需求:把文件fos.txt中的内容读取出来在控制台输出</p>
<p>使用字节输入流读数据的步骤:</p>
<p>① 创建字节输入流对象</p>
<p>②调用字节输入流对象的读数据方法</p>
<p>③释放资源</p>
<h3 id="注意-read（byte）读取的是所读字节的长度"><a href="#注意-read（byte）读取的是所读字节的长度" class="headerlink" title="注意:read（byte）读取的是所读字节的长度"></a>注意:read（byte）读取的是所读字节的长度</h3><p>byte[] bu &#x3D; new byte[6];</p>
<p> fis.read(bu)</p>
<h5 id="将读取的字节存到bu里面"><a href="#将读取的字节存到bu里面" class="headerlink" title="将读取的字节存到bu里面"></a>将读取的字节存到bu里面</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 204634.png)</p>
<h4 id="③复制图片"><a href="#③复制图片" class="headerlink" title="③复制图片"></a>③复制图片</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 205215.png)</p>
<h4 id="①字节缓冲流"><a href="#①字节缓冲流" class="headerlink" title="①字节缓冲流"></a>①字节缓冲流</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 210211.png)</p>
<p>读数据</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 212701.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 212708.png)</p>
<p>写数据</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 212822.png)</p>
<p>案例（复制）视频</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213815.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213828.png)</p>
<p>![屏幕截图 2024-07-18 213851](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213851.png)</p>
<p>![屏幕截图 2024-07-18 213922](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213922.png)</p>
<p>!(C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213940.png)</p>
<h2 id="3，字符流"><a href="#3，字符流" class="headerlink" title="3，字符流"></a>3，字符流</h2><p>存在原因:</p>
<p><code>FileInputStream</code> 本身只能读取字节流，不关心字符编码。当你使用 <code>FileInputStream</code> 读取文件时，它会逐个读取文件中的字节，并将每个字节转换为字符。如果文件中的字节表示的是 ASCII 字母，那么每个字节恰好是一个字符，所以你可以看到字母被正确地打印出来。</p>
<p>然而，如果你的文件包含汉字，情况就会变得复杂。因为汉字可能占用多个字节，而 <code>FileInputStream</code> 没有考虑到这一点，所以它不能正确地解码汉字。这就是为什么你不能用 <code>FileInputStream</code> 直接读取汉字的原因</p>
<p>汉字编码第一个都是负数</p>
<p>由于字节流操作中文不是特别的方便，所以java就提供字符流</p>
<p>字符流&#x3D;字节流+编码表</p>
<p>用字节流复制文本文件时，文本文件也会有中文，但是没有问题原因是最终底层操作会自动进行字节拼接成中文，汉字编码第一个都是负数，这个特点用于编码存储</p>
<h4 id="①编码表"><a href="#①编码表" class="headerlink" title="①编码表"></a>①编码表</h4><p>计算机中储存的信息都是用二进制数表示的:我们看到的字符都是二进制数转换之后的结果</p>
<p>按照规则将字符存储到计算机中称为编码，反之，解析二进制数出来称为解码，</p>
<h5 id="注-按照A编码表存储，必须按照A编码解析，否则出现乱码现象"><a href="#注-按照A编码表存储，必须按照A编码解析，否则出现乱码现象" class="headerlink" title="注:按照A编码表存储，必须按照A编码解析，否则出现乱码现象"></a>注:按照A编码表存储，必须按照A编码解析，否则出现乱码现象</h5><p>字符编码:就是一套自然语言的字符与二进制数之间的对应规则（A,650</p>
<p>字符集:</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 074717.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 075539.png)</p>
<h4 id="②编码解码问题"><a href="#②编码解码问题" class="headerlink" title="②编码解码问题"></a>②编码解码问题</h4><p>编码</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 080402.png)</p>
<p>![屏幕截图 2024-07-19 080407](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 080407.png)</p>
<p>![屏幕截图 2024-07-19 080412](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 080412.png)</p>
<p>解码</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 080510.png)</p>
<p>字符流抽象基类</p>
<p>Reader:字符输入流的抽象类</p>
<p>Writer:字符输出流的抽象类</p>
<p>字符流中和编码解码为问题相关的两个类:</p>
<p>InputStreamReader</p>
<p>OutputStreamWriter</p>
<p>输出:</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 082516.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 083302.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 083357.png)</p>
<p>输入:</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 083505.png)</p>
<h4 id="③字符流写数据的⑤种方式"><a href="#③字符流写数据的⑤种方式" class="headerlink" title="③字符流写数据的⑤种方式"></a>③字符流写数据的⑤种方式</h4><p>![](C:\Users\31502\Desktop\屏幕截图 2024-07-19 084526.png)</p>
<p>由于字节是数字，所以接受的是int类型</p>
<h3 id="注-写入的字符实际是由c转换成字符的"><a href="#注-写入的字符实际是由c转换成字符的" class="headerlink" title="注:写入的字符实际是由c转换成字符的"></a>注:写入的字符实际是由c转换成字符的</h3><p><code>OutputStreamWriter</code> 接收 <code>FileOutputStream</code> 因为它是用来将字符数据写入文件的。<code>FileOutputStream</code> 提供了将字节写入文件的功能，而 <code>OutputStreamWriter</code> 则提供了将字符数据转换为字节的功能。通过将两者结合在一起，你可以方便地将字符数据写入文件。</p>
<p>具体来说，<code>OutputStreamWriter</code> 使用 <code>OutputStream</code> 实现底层的字节写入功能，同时根据指定的字符集将字符数据转换为字节。这样，你可以使用 <code>OutputStreamWriter</code> 写入任意字符数据，而不需要担心如何将字符转换为字节的问题。</p>
<hr>
<p><code>OutputStreamWriter</code> 类继承自 <code>Writer</code> 类，<code>Writer</code> 类提供了一些基本的写入字符的方法，例如 <code>write(char)</code>、<code>write(String)</code> 和 <code>write(char[], int, int)</code>。这些方法允许你直接写入字符数据，而无需手动将字符转换为字节。</p>
<p>当你调用这些方法时，<code>OutputStreamWriter</code> 自动将字符转换为字节，并使用指定的字符集将字节写入底层的 <code>OutputStream</code>。这样，你就不必自己处理字符与字节之间的转换，简化了编程过程。</p>
<p>close()先刷新再关闭流 </p>
<p>flush()刷新流，还可以继续写数据</p>
<h4 id="④字符流读数据的2种方式"><a href="#④字符流读数据的2种方式" class="headerlink" title="④字符流读数据的2种方式"></a>④字符流读数据的2种方式</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 094215.png)</p>
<p><code>read(char[] cbuf)</code> 方法是 <code>Reader</code> 类的一个方法，用于从输入流中读取字符数据。它将读取的字符存储在 <code>cbuf</code> 数组中，并返回实际读取的字符数。如果到达流的末尾，返回 <code>-1</code>。</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 095342.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 102544.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 103345.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 103419.png)</p>
<h3 id="⑤字符缓冲流"><a href="#⑤字符缓冲流" class="headerlink" title="⑤字符缓冲流"></a>⑤字符缓冲流</h3><p>BufferedWritter:将文本写入字符输出流，缓冲字符，已提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</p>
<p>BufferedReader:从字符输入流读取文本，缓冲字符，已提供字符,数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途</p>
<p>构造方法:</p>
<p>BufferedWriter(Writer out)</p>
<p>BufferedReader(Reader in)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 110516.png)</p>
<p>字节缓冲流复制文件案例</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 111929.png)</p>
<p>字符缓冲流特有功能</p>
<p>BufferedWriter:</p>
<p>void newLine():写一行行分隔符，行分隔符字符串由系统属性定义(换行)</p>
<p>BufferedReader:</p>
<p>public String readLine():读一行文字，不读换行符号，返回那一行文字，用String类型接受。结果包含行的内容的字符串，不包含任何行终止字符（不能换行），如果流的结尾已经到达，则为null</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 142154.png)</p>
<h3 id="io流小结"><a href="#io流小结" class="headerlink" title="io流小结"></a>io流小结</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 142510.png)</p>
<p>![屏幕截图 2024-07-19 142537](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 142537.png)</p>
<p>q：为什么</p>
<p>FileInputStream的read方法在做类型提升（将byte提升为int）</p>
<p>FileOutputStream的write的方法在做类型强转(将int强转为byte)</p>
<p>java 字节读取流的read方法一次读一个byte但返回int的原因</p>
<p>读取二进制数据按字节读取，每次读一个字节（byte）。</p>
<p>read()的底层是由C++实现的，返回的是unsigned byte，取值范围为[0~255]，在java中没有对应的类型，所以只能用int类型接收，由Java接收得到的就是int[0、255]。</p>
<h4 id="字符流存在原因"><a href="#字符流存在原因" class="headerlink" title="字符流存在原因"></a>字符流存在原因</h4><p>存在原因:</p>
<p><code>FileInputStream</code> 本身只能读取字节流，不关心字符编码。当你使用 <code>FileInputStream</code> 读取文件时，它会逐个读取文件中的字节，并将每个字节转换为字符。如果文件中的字节表示的是 ASCII 字母，那么每个字节恰好是一个字符，所以你可以看到字母被正确地打印出来。</p>
<p>然而，如果你的文件包含汉字，情况就会变得复杂。因为汉字可能占用多个字节，而 <code>FileInputStream</code> 没有考虑到这一点，所以它不能正确地解码汉字。这就是为什么你不能用 <code>FileInputStream</code> 直接读取汉字的原因</p>
<h5 id="write-read与write-read-byte-b-的区别："><a href="#write-read与write-read-byte-b-的区别：" class="headerlink" title="write&#x2F;read与write&#x2F;read(byte[] b)的区别："></a>write&#x2F;read与write&#x2F;read(byte[] b)的区别：</h5><p>write(byte[] b)<code> 方法直接接受一个字节数组作为参数，数组中的每个元素就是一个字节 (</code>byte<code>)，不需要额外将其转换为 </code>int</p>
<h2 id="308"><a href="#308" class="headerlink" title="308"></a>308</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.复制单级文件夹</p>
<p>![屏幕截图 2024-07-19 174457](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 174457.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 174531.png)</p>
<p>2.复制多级文件夹</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 191155.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 191332.png)</p>
<p>3，复制文件的基本处理</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 192440.png)</p>
<h2 id="4，特殊操作流"><a href="#4，特殊操作流" class="headerlink" title="4，特殊操作流"></a>4，特殊操作流</h2><h4 id="①标准输入输出流"><a href="#①标准输入输出流" class="headerlink" title="①标准输入输出流"></a>①标准输入输出流</h4><p>System类中有两个静态的成员变量:</p>
<p>public static final InputStream in:标准输入流。通常该流对应于键盘输入或由主句环境光国用户指定的另一个输入源</p>
<p>public static final PringStream out:标准输出流。通常该流对应于键盘输入或由主句环境光国用户指定的另一个输出目标</p>
<p>自己实现键盘录入数据:</p>
<p>BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(System.in));</p>
<p>写起来太麻烦，java就提供了一个类实现键盘录入</p>
<p>Scanner sc &#x3D; new Scanner(System,in);</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 195356.png)</p>
<p>输出</p>
<p>输出语句的本质:是一个标准的输出流</p>
<p>PrintStream ps&#x3D;System.out;</p>
<p>System.out.print()&#x2F;&#x2F;括号必须有数值</p>
<p>System.out.println()&#x2F;&#x2F;括号不一定有数值</p>
<p>PrintStream类有的方法，System.out都可以使用</p>
<h4 id="②打印流"><a href="#②打印流" class="headerlink" title="②打印流"></a>②打印流</h4><p>打印流分类:</p>
<p>字节打印流:PrintStream</p>
<p>字符打印流:PrintWriter</p>
<p>打印流的特点:</p>
<p>只负责输出数据，不负责读取数据</p>
<p>有自己的特有方法</p>
<p>字节打印流</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 202112.png)</p>
<p>PrintStream(String fileName):使用指定的文件名创建新的打印流</p>
<p>使用继承父类的方法写数据&#x2F;&#x2F;指write（），查看的时候会转码;使用自己的特有方法写数据&#x2F;&#x2F;print&#x2F;println()，查看的数据原样输出</p>
<p>字符打印流 </p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 202512.png)</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 203411.png)</p>
<h3 id="③对象序列化流"><a href="#③对象序列化流" class="headerlink" title="③对象序列化流"></a>③对象序列化流</h3><p>对象序列化流:ObjectOutputStream</p>
<p>将Java对象的原始数据类型和图形写入OutputStream.可以使用ObjectlnputStream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机或另一个进程中重构对象</p>
<p>构造方法:ObjectOutputStream(OutputStream out):创建一个写入指定的OutputStream的ObjectOutputStream</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 211715.png)</p>
<p>eg</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 211807.png)</p>
<p>④对象反序列化流:ObjectlnputStream</p>
<p>ObjectlnputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象</p>
<p>构造方法:</p>
<p>ObjectlnputStream(lnputStream in):创建从指定的lnputStream读取的ObjectputStream</p>
<p>反序列化对象的方法:</p>
<p>Object readObject():从ObjectlnputStream读取一个对象</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 213707.png)</p>
<p>注意:Object obj &#x3D; ois.readObject(),是将已经反实例化的对象变成 Object类</p>
<p>而Student s &#x3D; (Student) obj,是将Object类强转为Student类</p>
<h5 id="⑤三个问题"><a href="#⑤三个问题" class="headerlink" title="⑤三个问题"></a>⑤三个问题</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 215931.png)</p>
<p>例子</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 220009.png)</p>
<h4 id="⑥properties"><a href="#⑥properties" class="headerlink" title="⑥properties"></a>⑥properties</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 090521.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 091135.png)</p>
<p>Propertier和io流结合的方法:</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 091258.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 092548.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 092718.png)</p>
<p>​         案例:游戏次数</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 095050.png)</p>
<h1 id="二十一，多线程"><a href="#二十一，多线程" class="headerlink" title="二十一，多线程"></a>二十一，多线程</h1><h2 id="1，实现多线程"><a href="#1，实现多线程" class="headerlink" title="1，实现多线程"></a>1，实现多线程</h2><h3 id="①线程"><a href="#①线程" class="headerlink" title="①线程"></a>①线程</h3><p>线程:是进程中的单个顺序控制流，是一条执行路径</p>
<p>单线程:是一个进程如果只有一条执行路径，则称为单线程程序，如main方法</p>
<p>多线程:一个进程如果有多条执行路径，则称为多线程程序</p>
<p>假设你有一个计算密集型的任务，可以有两种处理方式：</p>
<ul>
<li><strong>调用方法</strong>：你可以写一个方法，然后在主线程中调用它。这将导致主线程在该方法执行期间阻塞，无法执行其他任务。</li>
<li><strong>启动线程</strong>：相反，你可以将这个任务封装在一个实现了 <code>Runnable</code> 接口的类中，并创建一个线程来执行这个类的 <code>run</code> 方法。这样，主线程可以继续执行其他任务，而计算密集型的任务在另一个线程中独立完成。</li>
</ul>
<p>举例：</p>
<p>记事本程序</p>
<p>扫雷程序</p>
<h3 id="②多线程的实现方式"><a href="#②多线程的实现方式" class="headerlink" title="②多线程的实现方式"></a>②多线程的实现方式</h3><p>方式1:继承Thread类</p>
<p>定义一个类MyThread继承Thread类</p>
<p>在MyThread类中重写run()方法</p>
<p>创建MyThread类的对象</p>
<p>启动线程</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 102317.png)</p>
<p>![屏幕截图 2024-07-20 102323](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 102323.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 102404.png)</p>
<p>两个小问题:</p>
<p>为什么要重写run()方法?</p>
<p>​	因为run()是用来封装被线程执行的代码</p>
<p>run()方法和start()方法的区别 ?</p>
<p>​	run():封装线程执行的代码，直接调用，相当于普通方法的调用</p>
<p>​	start():启动线程；然后由JYM调用此线程的run()方法 （有了start()之后就不用run()方法）</p>
<h3 id="③设置和获取线程名称的方法"><a href="#③设置和获取线程名称的方法" class="headerlink" title="③设置和获取线程名称的方法"></a>③设置和获取线程名称的方法</h3><p>Thread类设置和获取线程名称的方法</p>
<p>void setName(String name):将此线程的名称更改为等于参数name</p>
<p>String getName():返回此线程的名称</p>
<p>通过构造方法也可以设置线程名称</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 105533.png)</p>
<p>![屏幕截图 2024-07-20 105552](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 105552.png)</p>
<p>如何获取main()方法所在的线程名称?</p>
<p>public static Thread currentThread():返回对当前执行的线程对象的引用</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 105849.png)</p>
<h3 id="④线程调度"><a href="#④线程调度" class="headerlink" title="④线程调度"></a>④线程调度</h3><p>线程有两种调度模型</p>
<p>分时调度模型:所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</p>
<p>抢占式调度模型:优先让优先权高的线程使用CPU,如果线程的优先级相同，那么会随机选择一个获取Cpu时间片相对多一些</p>
<p>Java使用的是抢占式调度模型</p>
<p>假如计算机只有一个CPU，那么CPU在某一时刻只能执行一条指令，线程只有得到Cpu时间片，也就是使用权，才可以执行指令，所以说多线程程序的执行是有随机性，抢到CPU的使用权的对象不一定</p>
<p>Thread类中设置和获取线程优先级的方法</p>
<h5 id="public-final-int-getPriority-返回此线程的优先级"><a href="#public-final-int-getPriority-返回此线程的优先级" class="headerlink" title="public final int getPriority():返回此线程的优先级"></a>public final int getPriority():返回此线程的优先级</h5><h5 id="public-final-void-setPriority-int-newPriority-更改此线程的优先级"><a href="#public-final-void-setPriority-int-newPriority-更改此线程的优先级" class="headerlink" title="public final void setPriority(int newPriority):更改此线程的优先级"></a>public final void setPriority(int newPriority):更改此线程的优先级</h5><p>优先级最低为1，默认为5，最高为10</p>
<p>线程优先级高仅仅表示线程获取CPU的时间片的几率高，但是要在次数比较多，或者多次运行时才能看到你的效果</p>
<h3 id="⑤线程控制"><a href="#⑤线程控制" class="headerlink" title="⑤线程控制"></a>⑤线程控制</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 112021.png)</p>
<p> 用于方法类而非main方法</p>
<p>join</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113426.png)</p>
<p>![屏幕截图 2024-07-20 113502](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113502.png)</p>
<p>setDa</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113549.png)</p>
<p>![屏幕截图 2024-07-20 113619](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113619.png)</p>
<h3 id="⑥线程生命周期"><a href="#⑥线程生命周期" class="headerlink" title="⑥线程生命周期"></a>⑥线程生命周期</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113902.png)</p>
<h3 id="⑦多线程的实现方式"><a href="#⑦多线程的实现方式" class="headerlink" title="⑦多线程的实现方式"></a>⑦多线程的实现方式</h3><p>方式2:实现Runnable接口</p>
<p>启动线程</p>
<p>多线程的实现方案：</p>
<p>继承Thread类</p>
<p>实现Runnable接口</p>
<p>相比继承Thread类，实现Runnablle接口的好处</p>
<p>避免了Java单继承的局限性</p>
<p>适合多个相同程序的代码1去处理同一个资源的情况，把线程和程序的代码，数据有效分离，较好的体现了面向对象的设计思想</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 143611.png)</p>
<p>![屏幕截图 2024-07-20 143632](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 143632.png)</p>
<h2 id="2，线程同步"><a href="#2，线程同步" class="headerlink" title="2，线程同步"></a>2，线程同步</h2><h3 id="①为什么会出现线程同步"><a href="#①为什么会出现线程同步" class="headerlink" title="①为什么会出现线程同步"></a>①为什么会出现线程同步</h3><p>当、有多线程环境、有共享数据、有多条语句操作共享数据、同时存在时会出现数据安全问题</p>
<p>解决:</p>
<p>基本思想:让程序没有安全问题的环境</p>
<p>方法:1,把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可</p>
<p>​		2,Java提供了同步代码块的方式来解决</p>
<h3 id="②同步代码块"><a href="#②同步代码块" class="headerlink" title="②同步代码块"></a>②同步代码块</h3><p>锁多条语句操作共享数据，可以使用同步代码块实现</p>
<p><code>synchronized</code> 是Java中用于实现线程同步的关键字，主要用于解决多线程环境中对共享资源的并发访问问题。它可以确保在同一时刻，只有一个线程能够执行特定的代码段或访问特定的对象</p>
<p><code>synchronized</code> 块或方法在进入时会自动获取锁，并在正常退出或抛出异常时自动释放锁</p>
<p>格式:</p>
<p>synchronized(任意对象){</p>
<p>​	多条语句操作共享数据的代码</p>
<p>​	}</p>
<p>synchronized(任意对象):就相当于给代码枷锁了，任意对象就可以看成一把锁</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 154003.png)</p>
<p>![屏幕截图 2024-07-20 154012](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 154012.png)</p>
<h3 id="③同步方法"><a href="#③同步方法" class="headerlink" title="③同步方法"></a>③同步方法</h3><p>同步方法:就是把Synchronized关键字加到方法上</p>
<p>格式:</p>
<p>修饰符Synchronized返回值类型 方法名(方法参数){}</p>
<p>同步方法的锁对象是什么呢？</p>
<p>this</p>
<p>同步静态方法:就是把synchronized关键字加到静态方法上</p>
<p>格式:</p>
<p>修饰符:static synchronized返回值类型 方法名(方法参数){}</p>
<p>同步静态方法的锁对象是什么呢？</p>
<p>类名.class</p>
<h3 id="④线程安全的类"><a href="#④线程安全的类" class="headerlink" title="④线程安全的类"></a>④线程安全的类</h3><p>线程安全的类是指那些在多线程环境中能够正确处理共享资源访问，避免数据竞争、脏读、死锁等问题的类。</p>
<p>StringBuffer   Vector   Hashtable</p>
<p>StringBuffer:</p>
<p>线程安全，可变的字符序列</p>
<p>通常使用StringBuilder类，因为它支持所有相同的操作，因为他不执行同步</p>
<p>Vector:</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 162616.png)</p>
<p>Hashtable</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 162621.png)</p>
<p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 164013.png)</p>
<h3 id="⑤lock锁"><a href="#⑤lock锁" class="headerlink" title="⑤lock锁"></a>⑤lock锁</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 164256.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 165016.png)</p>
<h3 id="3，生产者消费者"><a href="#3，生产者消费者" class="headerlink" title="3，生产者消费者"></a>3，生产者消费者</h3><p>为了体现生产和消费过程中的等待和唤醒，Java就提供了几个方法供我们使用，这几个方法在Object类中Object类的等待和唤醒功能:</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 165453.png)</p>
<p>监视器:锁</p>
<h1 id="二十二，网络编程"><a href="#二十二，网络编程" class="headerlink" title="二十二，网络编程"></a>二十二，网络编程</h1><h2 id="1，网络编程入门"><a href="#1，网络编程入门" class="headerlink" title="1，网络编程入门"></a>1，网络编程入门</h2><h3 id="①计算机网络"><a href="#①计算机网络" class="headerlink" title="①计算机网络"></a>①计算机网络</h3><p>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 174028.png)</p>
<h3 id="②网络编程三要素"><a href="#②网络编程三要素" class="headerlink" title="②网络编程三要素"></a>②网络编程三要素</h3><p>ip地址：</p>
<p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，而Ip地址就是这个标识号，也就是设备的标识</p>
<p>端口:</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 174613.png)</p>
<p>协议:</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 174643.png)</p>
<h3 id="④ip地址"><a href="#④ip地址" class="headerlink" title="④ip地址"></a>④ip地址</h3><p>IP地址:是网络中设备的唯一标识</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 191435.png)</p>
<p>命令与地址</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 193504.png)</p>
<h3 id="⑤InetAddress的使用"><a href="#⑤InetAddress的使用" class="headerlink" title="⑤InetAddress的使用"></a>⑤InetAddress的使用</h3><p>为了方便我们对ip地址的获取和操作，提供了一个类InetAddress供我们使用</p>
<p>InetAddress:此类表示Internet（ip）协议</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 194007.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 195131.png)</p>
<h3 id="⑥端口"><a href="#⑥端口" class="headerlink" title="⑥端口"></a>⑥端口</h3><p>端口:设备上应用程序的为标识</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 195820.png)</p>
<h3 id="⑤协议"><a href="#⑤协议" class="headerlink" title="⑤协议"></a>⑤协议</h3><p>协议:计算机</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 073647.png)</p>
<p>TCP协议</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 073900.png)</p>
<p>三次握手</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 073933.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 074023.png)</p>
<p>在吗?在，好的</p>
<p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件，下载文件，浏览网页等</p>
<h2 id="2，UDP通信程序"><a href="#2，UDP通信程序" class="headerlink" title="2，UDP通信程序"></a>2，UDP通信程序</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 074702.png)</p>
<p>发送数据的步骤:</p>
<p>①创建发送端的Socket对象(DatagramSocket)</p>
<p>②创建数据，并把数据打包</p>
<p>③调用DatagramSocket对象的方法发送数据</p>
<p>④关闭发送端</p>
<p>void close()</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 075211.png)</p>
<p>接受数据的步骤</p>
<p>①创建接受端的Socket对象(DatagramSocket)</p>
<p>②创建一个数据包，用于接受数据</p>
<p>③调用DatagramSocket对象的方法接收数据</p>
<p>④解析数据包，并把数据在控制台显示</p>
<p>⑤关闭接收端</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 090135.png)</p>
<p>![屏幕截图 2024-07-22 090212](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 090212.png)</p>
<h2 id="3，TCP通信程序"><a href="#3，TCP通信程序" class="headerlink" title="3，TCP通信程序"></a>3，TCP通信程序</h2><h3 id="①TCP通信原理"><a href="#①TCP通信原理" class="headerlink" title="①TCP通信原理"></a>①TCP通信原理</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 090518.png)</p>
<p>发送数据的步骤</p>
<p>①创建客户端的Socket对象(Socket)</p>
<p>Socket(String host,int port)</p>
<p>②获取输出流，写数据</p>
<p>OutputStream getOutputStream()</p>
<p>③释放资源</p>
<p>void close()</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 092627.png)</p>
<h3 id="②TCP接受数据"><a href="#②TCP接受数据" class="headerlink" title="②TCP接受数据"></a>②TCP接受数据</h3><p>接受数据的步骤</p>
<p>①创建服务器端的Socket对象(ServerSocket)</p>
<p>ServerSocket(int port)</p>
<p>②监听客户端连接，返回一个Socket对象</p>
<p>Socket accept()</p>
<p>②获取输入流，读数据，并把数据显示在控制台</p>
<p>InputStream getlnputStream()</p>
<p>③释放资源</p>
<p> void close()</p>
<ol>
<li><strong>创建ServerSocket</strong>：首先，你需要创建一个<code>ServerSocket</code>对象，该对象将绑定到一个特定的端口上。这是服务器监听客户端连接的基础。</li>
<li>**调用accept()**：<code>ServerSocket</code>对象提供了一个<code>accept()</code>方法，该方法会阻塞并等待客户端的连接请求。当客户端尝试连接时，<code>accept()</code>方法将返回一个<code>Socket</code>对象，代表了与客户端之间的连接。</li>
<li><strong>处理客户端连接</strong>：一旦<code>accept()</code>方法返回了<code>Socket</code>对象，你就可以通过该对象的输入输出流与客户端进行通信。通常，你会在一个新的线程中处理每个客户端连接，以允许多个客户端同时连接。</li>
<li><strong>关闭连接</strong>：在处理完客户端的请求后，记得关闭<code>Socket</code>对象，以释放系统资源。</li>
</ol>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 094054.png)</p>
<h3 id="③例子"><a href="#③例子" class="headerlink" title="③例子"></a>③例子</h3><p>1，服务器给反馈</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 102504.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 103441.png)</p>
<p>2，输入</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 110450.png)</p>
<p>![屏幕截图 2024-07-22 110347](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 110347.png)</p>
<p>3，写入文本数据</p>
<p><img src="C:\Users\31502\AppData\Roaming\Typora\typora-user-images\image-20240722110526263.png" alt="image-20240722110526263"></p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 110450.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 111434.png)</p>
<p>4，文本文件接受与写入</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 112324.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 112137.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 111434.png)</p>
<p>5，文本文件接受与写入加反馈</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 142617.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 150614.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 150632.png)</p>
<p>出现问题:程序一直等待</p>
<p>原因:读数据的方法时阻塞式的</p>
<p>解决方法:自定义结束标记;使用shutdownOutput()方法</p>
<p>6，封装</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 151155.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 153253.png)</p>
<p>![屏幕截图 2024-07-22 153313](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 153313.png)</p>
<p>![屏幕截图 2024-07-22 153326](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 153326.png)</p>
<p>q：</p>
<p>1，为什么while ((line &#x3D; br.readLine()) !&#x3D; null) { System.out.println(line);如果在网络中读不到数据不会停止运行?</p>
<p>在Java中，当你使用 <code>BufferedReader</code> 的 <code>readLine()</code> 方法从网络输入流（例如通过 <code>Socket</code> 连接）读取数据时，<code>readLine()</code> 方法会阻塞（等待）直到读取到一行数据或者到达流的末尾。如果网络连接中断，或者远程服务器停止发送数据，<code>readLine()</code> 方法最终会返回 <code>null</code>，这将使 <code>while</code> 循环终止。</p>
<h1 id="二十三，Lambda表达式"><a href="#二十三，Lambda表达式" class="headerlink" title="二十三，Lambda表达式"></a>二十三，Lambda表达式</h1><h2 id="1，函数式编程思想概述"><a href="#1，函数式编程思想概述" class="headerlink" title="1，函数式编程思想概述"></a>1，函数式编程思想概述</h2><p>在数学中，函数就是有输入量，输出流的一套计算方案，也就是”拿数据做操作”面向对象思想强调”必须通过对象的形式来做事情”</p>
<p>函数式思想则尽量忽略面向对象的复杂语法:”强调做什么，而不是以什么形式去做”而我们要学习的Lambda表达式就是函数式思想的体现</p>
<p>方式1</p>
<p>定义一个类</p>
<p>定义一个类MyRunnable实现Runnable接口</p>
<p>在MyRunnable类中重写run()方法&#x2F;&#x2F;不能使用getName方法</p>
<p>创建MyRunnable类对象</p>
<p>创建Thread类的对像&#x2F;&#x2F;他是自带的，把MyRunnable对象作为构造方法的参数</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 155806.png)</p>
<h2 id="2，Lambda表达式的标准格式"><a href="#2，Lambda表达式的标准格式" class="headerlink" title="2，Lambda表达式的标准格式"></a>2，Lambda表达式的标准格式</h2><p> 组成Lambda表达式的三要素:形式参数，箭头，代码块</p>
<p>格式:(形式参数)-&gt;{代码块}</p>
<p>形式参数:如果有多个参数，参数之间用逗号隔开;如果没有参数，留空即可</p>
<p>-&gt;:由英文中划线和大于符号组成，固定写法。代表指向动作</p>
<p>代码块:是我们具体要做的实景，也就是我们写的方法体内容</p>
<p>Lambda表达式的方法中必须有参数</p>
<h2 id="3，练习"><a href="#3，练习" class="headerlink" title="3，练习"></a>3，练习</h2><p>Lambda表达式的使用前提</p>
<p>有一个接口</p>
<p>接口中有且仅有一个抽象方法</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 191310.png)</p>
<p>![屏幕截图 2024-07-22 191322](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 191322.png)</p>
<p>![屏幕截图 2024-07-22 170520](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 170520.png)</p>
<p>2，</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 174557.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 175411.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 175443.png)</p>
<h4 id="Lambda表达式其实就是接口方法的重写（参数）-方法体"><a href="#Lambda表达式其实就是接口方法的重写（参数）-方法体" class="headerlink" title="Lambda表达式其实就是接口方法的重写（参数）-&gt;{方法体}"></a>Lambda表达式其实就是接口方法的重写（参数）-&gt;{方法体}</h4><h2 id="4，省略规则"><a href="#4，省略规则" class="headerlink" title="4，省略规则"></a>4，省略规则</h2><p>1.参数类型可以省略。但是有多个参数的情况下，不能只省略一个</p>
<p>2.如果参数有且仅有一个，那么小括号可以省略</p>
<p>3.如果代码块的语句只有一条，可以省略大括号和分号，甚至是return</p>
<h2 id="5，注意事项"><a href="#5，注意事项" class="headerlink" title="5，注意事项"></a>5，注意事项</h2><p>在匿名内部类中实例化即代表重写</p>
<p>如new fdf()&#x2F;&#x2F;接口名{}</p>
<p>1，使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法</p>
<p>2，必须有上下文环境，才能推导出Lambda对应的接口</p>
<p>​		根据局部变量的赋值得知Lambda对应的接口:Runnabler r&#x3D;()-&gt;System.out.println(“Lambda表达式”)；</p>
<p>​		根据调用方法的参数得知Lambda对应的接口：new Thread(()-&gt;System.out.println(“Lambda表达式”)).start（）；</p>
<p><strong>在Java中，你可以创建任意数量的同一接口的实例，并为每个实例单独提供具体的实现。这通常通过Lambda表达式或匿名内部类来完成，尤其是对于函数式接口（即只有一个抽象方法的接口）</strong></p>
<h2 id="6-Lambda表达式和匿名内部类的区别"><a href="#6-Lambda表达式和匿名内部类的区别" class="headerlink" title="6,Lambda表达式和匿名内部类的区别"></a>6,Lambda表达式和匿名内部类的区别</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 212132.png)</p>
<h1 id="二十四，接口组成更新"><a href="#二十四，接口组成更新" class="headerlink" title="二十四，接口组成更新"></a>二十四，接口组成更新</h1><h2 id="1，概述-4"><a href="#1，概述-4" class="headerlink" title="1，概述"></a>1，概述</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 212459.png)</p>
<h2 id="2，接口默认方法"><a href="#2，接口默认方法" class="headerlink" title="2，接口默认方法"></a>2，接口默认方法</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 213235.png)</p>
<p>重写的时候要在实现类去掉default</p>
<h2 id="3-接口中静态方法"><a href="#3-接口中静态方法" class="headerlink" title="3.接口中静态方法"></a>3.接口中静态方法</h2><p>接口中并不是所有都是抽象方法</p>
<p>只有抽象方法，静态方法，默认方法</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 214218.png)</p>
<h2 id="4，接口中私有方法"><a href="#4，接口中私有方法" class="headerlink" title="4，接口中私有方法"></a>4，接口中私有方法</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 215055.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 214749.png)</p>
<p>![屏幕截图 2024-07-22 214912](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 214912.png)</p>
<h1 id="二十五，方法引用（进行重写（实现），同时调用方法"><a href="#二十五，方法引用（进行重写（实现），同时调用方法" class="headerlink" title="二十五，方法引用（进行重写（实现），同时调用方法)"></a>二十五，方法引用（进行重写（实现），同时调用方法)</h1><h2 id="1，方法引用符"><a href="#1，方法引用符" class="headerlink" title="1，方法引用符"></a>1，方法引用符</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 073144.png)</p>
<h2 id="2-Lambda表达式支持的方法"><a href="#2-Lambda表达式支持的方法" class="headerlink" title="2,Lambda表达式支持的方法"></a>2,Lambda表达式支持的方法</h2><p>常用的引用方式:</p>
<p>引用类方式</p>
<p>引用对象的实例方法</p>
<p>引用类的实例方法</p>
<p>引用构造器</p>
<h3 id="①引用类方法"><a href="#①引用类方法" class="headerlink" title="①引用类方法"></a>①引用类方法</h3><p>引用类方法:其实就是引用类（大多为工具类）的静态方法</p>
<p>格式:类名::静态方法</p>
<p>范例:Integer::parselnt</p>
<p>Integer类的方法:public static int parselnt(String s)将此String 转换为int类型</p>
<p>Lambda表达式被类方法替代时，它的形式参数全部传递给静态方法作为参数</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 082023.png)</p>
<h3 id="②引用对象的实例方法"><a href="#②引用对象的实例方法" class="headerlink" title="②引用对象的实例方法"></a>②引用对象的实例方法</h3><p>引用对象的实例方法，其实是引用类中的成员方法</p>
<p>格式:对象::成员方法</p>
<p>范例:”HelloWorld”::toUpperCase</p>
<p>String类中的方法:public String toUpperCase()将此String所有字符转换为大写</p>
<p>Lambda表达式被对象的实例方法替代时，它的形式参数全部传递给该方法作为参数</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 084055.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 084336.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 084404.png)</p>
<h3 id="③引用类的的实例方法"><a href="#③引用类的的实例方法" class="headerlink" title="③引用类的的实例方法"></a>③引用类的的实例方法</h3><p>引用类的实例方法，其实就是引用类中成员方法</p>
<p>格式:类名::成员方法</p>
<p>范例:String::substring</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 085735.png)</p>
<p>![屏幕截图 2024-07-23 085747](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 085747.png)</p>
<h3 id="④引用构造器"><a href="#④引用构造器" class="headerlink" title="④引用构造器"></a>④引用构造器</h3><p>其实就是引用构造方法</p>
<p>格式:类名::new</p>
<p>范例:Student::new</p>
<h1 id="二十六，函数式接口"><a href="#二十六，函数式接口" class="headerlink" title="二十六，函数式接口"></a>二十六，函数式接口</h1><p>函数式接口:有且仅有一个抽象方法的接口</p>
<p>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口</p>
<p>只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导</p>
<p>如何检测一个接口是不是函数式接口呢</p>
<p>@Functionallnterface</p>
<p>放在接口定义的上方:如果接口是函数式接口，编译通过;如果不是，编译失败</p>
<p>注意</p>
<p>我们自己定义函数式接口的时候，@Functionallnterface是可选的，但是建议加上该注解</p>
<h2 id="1，函数式接口作为方法的参数"><a href="#1，函数式接口作为方法的参数" class="headerlink" title="1，函数式接口作为方法的参数"></a>1，函数式接口作为方法的参数</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 094418.png)</p>
<h2 id="2，函数式接口作为方法的返回值"><a href="#2，函数式接口作为方法的返回值" class="headerlink" title="2，函数式接口作为方法的返回值"></a>2，函数式接口作为方法的返回值</h2><p>需求</p>
<p>定义一个类（ComparatorDemo），在类中提供两个方法<br>一个方法是：Comparator&lt; String &gt; getComparator() 方法返回值Comparator是一个函数式接口</p>
<p>一个方法是主方法，在主方法中调用getComparator方法</p>
<p>如果一个方法的返回值是一个函数式接口，我们可以把一个Lambda表达式作为结果返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static Comparator&lt;String&gt; getComparator() &#123;    </span><br><span class="line">	//Lambda表达式写法</span><br><span class="line">    return (s1, s2) -&gt; s1.length() - s2.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class ComparatorDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;cccc&quot;);</span><br><span class="line">        list.add(&quot;aa&quot;);</span><br><span class="line">        list.add(&quot;b&quot;);</span><br><span class="line">        list.add(&quot;ddd&quot;);</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;排序前&quot; + list);</span><br><span class="line">​    Collections.sort(list, getComparator());</span><br><span class="line">​    System.out.println(&quot;排序后&quot; + list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果一个方法的返回值是一个函数式接口，我们可以把一个Lambda表达式作为结果返回</span><br><span class="line">private static Comparator&lt;String&gt; getComparator() &#123;</span><br><span class="line">    //使用匿名内部类实现</span><br><span class="line"></span><br><span class="line">//        return new Comparator&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public int compare(String s1, String s2) &#123;</span><br><span class="line">//                return s1.length()-s2.length();</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line"></span><br><span class="line">​    //Lambda表达式写法</span><br><span class="line">​    return (s1, s2) -&gt; s1.length() - s2.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3，常用的函数式接口"><a href="#3，常用的函数式接口" class="headerlink" title="3，常用的函数式接口"></a>3，常用的函数式接口</h2><ul>
<li>Supplier接口</li>
<li>Consumer接口</li>
<li>Predicate接口</li>
<li>Function接口</li>
</ul>
<h3 id="①Supplier接口"><a href="#①Supplier接口" class="headerlink" title="①Supplier接口"></a>①Supplier接口</h3><p>Supplier&lt; T &gt;：包含一个无参的方法</p>
<p>T get()：获得结果<br>该方法不需要参数，他会按照某种实现逻辑（由Lambda表达式实现）返回一个数据<br>Supplier&lt; T &gt;接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会产生什么类型的数据供我们使用</p>
<h5 id="注意-return可以省略"><a href="#注意-return可以省略" class="headerlink" title="注意:return可以省略"></a>注意:return可以省略</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 102856.png)</p>
<p>多条语句</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 103636.png)</p>
<h3 id="②consumer接口"><a href="#②consumer接口" class="headerlink" title="②consumer接口"></a>②consumer接口</h3><p><code>Consumer&lt;T&gt;</code>是Java中的一个函数式接口，它主要用来<strong>消费或处理类型为<code>T</code>的对象</strong>。<code>Consumer&lt;T&gt;</code>接口只有一个抽象方法<code>void accept(T t);</code>，这个方法接收一个类型为<code>T</code>的参数，并对其执行某种操作，但不返回任何值。</p>
<p><code>Consumer&lt;T&gt;</code>接口非常适合用来作为参数传递给方法，或者在流（<code>Stream</code>）操作中作为终端操作的一部分，用于处理数据。例如，你可以使用<code>Consumer&lt;T&gt;</code>来打印列表中的每个元素，或者更新数据库中的记录等</p>
<p>Consumer&lt; T &gt;：包含两个方法</p>
<p>1.void accept(T t)：对给定的参数执行此操作 </p>
<p>2.default Consumer &lt; T &gt; andThen(Consumer after)：返回一个组</p>
<p>合的Consumer，依次执行此操作，然后执行after操作</p>
<p>Consumer&lt; T &gt;接口也被称为消费型接口，它消费的数据类型由泛型指定</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">  operatorString(<span class="string">&quot;张三&quot;</span>, (s) -&gt; System.out.println(s));</span><br><span class="line">        </span><br><span class="line">  operatorString(<span class="string">&quot;张三&quot;</span>, (s) -&gt; System.out.println(s), (s)-&gt; System.out.println(<span class="keyword">new</span>  </span><br><span class="line">                                                                              <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个方法，消费一个字符串数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con)</span> &#123;</span><br><span class="line">    con.accept(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个方法，用不同的方式消费同一个字符串两次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        con1.accept(name);</span></span><br><span class="line"><span class="comment">//        con2.accept(name);</span></span><br><span class="line">        <span class="comment">//返回一个组合的Consumer</span></span><br><span class="line">        con1.andThen(con2).accept(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="q："><a href="#q：" class="headerlink" title="q："></a>q：</h5><p>你没有在同一个类中实现<code>accept</code>方法两次，而是创建了两个独立的<code>Consumer&lt;String&gt;</code>实例，每个实例都有自己的<code>accept</code>方法实现。当你在<code>operatorString</code>方法中使用<code>andThen</code>方法时，你实际上是在创建一个新的<code>Consumer&lt;String&gt;</code>实例，这个实例包含了两个操作的顺序执行。也就是说，你创建了两个独立的<code>Consumer&lt;String&gt;</code>，并通过<code>andThen</code>将它们串联起来，形成一个新的<code>Consumer&lt;String&gt;</code>。</p>
<p>这里的关键点是，虽然<code>accept</code>方法在两个Lambda表达式中都被实现了，但这不是在同一个类中的重复实现，而是两个独立的实现，每个都在不同的<code>Consumer&lt;String&gt;</code>实例中。因此，这不属于同一个抽象方法实现两次，而是两个独立的实现，它们恰好覆盖了同一个接口的抽象方法。</p>
<h3 id="③Predicate接口"><a href="#③Predicate接口" class="headerlink" title="③Predicate接口"></a>③Predicate接口</h3><p><code>Predicate&lt;T&gt;</code>接口在Java中是一个函数式接口，它主要<strong>用于测试类型为<code>T</code>的对象是否满足某种条件</strong>。<code>Predicate&lt;T&gt;</code>接口定义了一个抽象方法<code>boolean test(T t);</code>，用于对给定的<code>T</code>类型对象进行评估并返回一个布尔值表示是否满足条件。</p>
<p><strong>也就是实现的是Test()方法</strong>，测试实现的具体内容</p>
<p>Predicate&lt; T &gt;：常用的四个方法</p>
<p>boolean test(T t)：对给定的参数进行判断（判断逻辑由Lambda表达式实现），返回一个布尔值<br>default Predicate&lt; T &gt; negate()：返回一个逻辑的否定，对应逻辑非<br>default Predicate&lt; T &gt; and(Predicate other)：返回一个组合判断，对应短路与<br>default Predicate&lt; T &gt; or(Predicate other)：返回一个组合判断，对应短路或<br>Predicate&lt; T &gt;：接口通常用于判断参数是否满足指定的条件</p>
<p>![ ](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 143702.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 145504.png)</p>
<p>进行重写，同时调用方法</p>
<h3 id="④Function接口"><a href="#④Function接口" class="headerlink" title="④Function接口"></a>④Function接口</h3><p>Function&lt;T,R&gt;：接口通常用于对参数进行<strong>处理，转换</strong>（处理逻辑由Lambda表达式实现），然后返回一个新值</p>
<p><strong>R</strong> apply(<strong>T</strong> t)：将此函数应用于给定的参数</p>
<p>default&lt; V &gt;：Function andThen(Function after)：返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</p>
<p>T表示函数输入的类型</p>
<p>R表示函数结果的类型</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 152944.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 153124.png)</p>
<h1 id="二十七，Stream流"><a href="#二十七，Stream流" class="headerlink" title="二十七，Stream流"></a>二十七，Stream流</h1><h2 id="1，体验"><a href="#1，体验" class="headerlink" title="1，体验"></a>1，体验</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 155932.png)</p>
<h2 id="2，Stream流的生成方式"><a href="#2，Stream流的生成方式" class="headerlink" title="2，Stream流的生成方式"></a>2，Stream流的生成方式</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 160126.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 160322.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 161322.png)</p>
<h2 id="3，Stream流的常见中间操作方法"><a href="#3，Stream流的常见中间操作方法" class="headerlink" title="3，Stream流的常见中间操作方法"></a>3，Stream流的常见中间操作方法</h2><h4 id="①Streamfilter-Predicate-predicate-用于对流中的数据进行过滤"><a href="#①Streamfilter-Predicate-predicate-用于对流中的数据进行过滤" class="headerlink" title="①Streamfilter(Predicate predicate):用于对流中的数据进行过滤"></a>①Stream<T>filter(Predicate predicate):用于对流中的数据进行过滤</h4><h4 id="Predicate接口中的方法-boolean-test-T-t-对给定的参数进行判断，返回一个布尔值"><a href="#Predicate接口中的方法-boolean-test-T-t-对给定的参数进行判断，返回一个布尔值" class="headerlink" title="Predicate接口中的方法          boolean test(T t):对给定的参数进行判断，返回一个布尔值"></a>Predicate接口中的方法          boolean test(T t):对给定的参数进行判断，返回一个布尔值</h4><p>过滤流中的元素，只保留满足给定谓词（条件）的元素。</p>
<ul>
<li>参数：一个<code>Predicate</code>接口的实例，表示要应用的过滤条件。</li>
</ul>
<p> 当你调用 <code>list.stream()</code> 方法时，就已经创建了一个流。流是基于集合元素的一次性计算，它不会改变源集合的内容，而是产生一个新的结果。所以不用声明一个流</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 162357.png)</p>
<h4 id="②Streamlimit-long-maxSize-返回此流中的元素组成的流，截取前指定参数个数的数据"><a href="#②Streamlimit-long-maxSize-返回此流中的元素组成的流，截取前指定参数个数的数据" class="headerlink" title="②Streamlimit(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据"></a>②Stream<T>limit(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据</h4><h4 id="Streamskip-long-n-跳过指定参数个数的数据，返回由该流的剩余元素组成的流"><a href="#Streamskip-long-n-跳过指定参数个数的数据，返回由该流的剩余元素组成的流" class="headerlink" title="Streamskip(long n):跳过指定参数个数的数据，返回由该流的剩余元素组成的流"></a>Stream<T>skip(long n):跳过指定参数个数的数据，返回由该流的剩余元素组成的流</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 164325.png)</p>
<h4 id="③staticStreamconcat-Stream-a-Stream-b-合并a和b两个流为一个流"><a href="#③staticStreamconcat-Stream-a-Stream-b-合并a和b两个流为一个流" class="headerlink" title="③staticStreamconcat(Stream a,Stream b):合并a和b两个流为一个流"></a>③static<T>Stream<T>concat(Stream a,Stream b):合并a和b两个流为一个流</h4><h4 id="Streamdistinct-返回由该流的不同元素-根据Object-equals-Object-组成的流"><a href="#Streamdistinct-返回由该流的不同元素-根据Object-equals-Object-组成的流" class="headerlink" title="Streamdistinct():返回由该流的不同元素(根据Object.equals(Object))组成的流"></a>Stream<T>distinct():返回由该流的不同元素(根据Object.equals(Object))组成的流</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 170108.png)</p>
<h4 id="④Streamsorted-返回由此流的元素组成的流，根据自然顺序排序"><a href="#④Streamsorted-返回由此流的元素组成的流，根据自然顺序排序" class="headerlink" title="④Streamsorted():返回由此流的元素组成的流，根据自然顺序排序"></a>④Stream<T>sorted():返回由此流的元素组成的流，根据自然顺序排序</h4><h4 id="Streamsorted-Comparator-comparator-返回由此流的元素组成的流，根据提供的Comparator进行排序"><a href="#Streamsorted-Comparator-comparator-返回由此流的元素组成的流，根据提供的Comparator进行排序" class="headerlink" title="Streamsorted(Comparator comparator):返回由此流的元素组成的流，根据提供的Comparator进行排序"></a>Stream<T>sorted(Comparator comparator):返回由此流的元素组成的流，根据提供的Comparator进行排序</h4><p>**sorted(Comparator&lt;? super T&gt; comparator)**： 对流中的元素进行排序。</p>
<ul>
<li>参数：一个<code>Comparator</code>接口的实例，表示排序规则。</li>
</ul>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 171511.png)</p>
<h4 id="⑤Streammap-Function-mapper-返回由给定函数应用于此流的元素的结果组成的流"><a href="#⑤Streammap-Function-mapper-返回由给定函数应用于此流的元素的结果组成的流" class="headerlink" title="⑤Streammap(Function mapper):返回由给定函数应用于此流的元素的结果组成的流"></a>⑤<R>Stream<R>map(Function mapper):返回由给定函数应用于此流的元素的结果组成的流</h4><p>​		Function接口中的方法               R apply(T t)</p>
<p>**map(Function&lt;T, R&gt; mapper)**： 将流中的每个元素转换为另一种类型。</p>
<ul>
<li>参数：一个<code>Function</code>接口的实例，表示转换逻辑。</li>
</ul>
<h4 id="IntStream-map-Tolnt-TolntFunction-mapper-返回一个IntStream其中包含将给定函数应用于此流的元素的结果"><a href="#IntStream-map-Tolnt-TolntFunction-mapper-返回一个IntStream其中包含将给定函数应用于此流的元素的结果" class="headerlink" title="IntStream map Tolnt(TolntFunction mapper):返回一个IntStream其中包含将给定函数应用于此流的元素的结果"></a>IntStream map Tolnt(TolntFunction mapper):返回一个IntStream其中包含将给定函数应用于此流的元素的结果</h4><p>​		IntStream:表示原始int流</p>
<p>​		TolntFunction接口中的方法                       int applyAslnt(T value)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 172842.png)</p>
<h2 id="4-常见终结操作方法"><a href="#4-常见终结操作方法" class="headerlink" title="4,常见终结操作方法"></a>4,常见终结操作方法</h2><p>void forEach(Consumer sction):对此流的每个元素执行操作</p>
<p>​		Consumer接口中的方法                   void accept(T t):对给定的参数执行此操作</p>
<p>long count():返回此流中的元素数</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 174326.png)</p>
<h2 id="5，练习"><a href="#5，练习" class="headerlink" title="5，练习"></a>5，练习</h2><p>![屏幕截图 2024-07-23 175745](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 175745.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 175759.png)</p>
<h2 id="6，Stream流的收集操作"><a href="#6，Stream流的收集操作" class="headerlink" title="6，Stream流的收集操作"></a>6，Stream流的收集操作</h2><p>对数据使用Stream流的方式操作完毕后，我想把流中的数据收集到集合中，该怎么办呢?</p>
<p>Stream流的收集方法</p>
<p>R collect(Collector collector)</p>
<p>但是这个收集方法的参数是一个Collector接口</p>
<p>工具类Collector提供了具体的收集方式</p>
<p>public static<T>Collector toList():把元素收集到List集合中</p>
<p>public static<T>Collector toSet():把元素收集到List集合中</p>
<p>public static Collector toMap(Function keyMapper,Function valueMapper):把元素收集到Map集合中</p>
<p>**collect(Collector&lt;? super T, A, R&gt; collector)**： 将流转换为其他形式的数据结构，如列表、集合、Map等。</p>
<ul>
<li>参数：一个<code>Collector</code>接口的实例，表示收集逻辑。</li>
</ul>
<p>List</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193750.png)</p>
<p>Set</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193654.png)</p>
<p>map</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193356.png)</p>
<p>![屏幕截图 2024-07-23 193512](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193512.png)</p>
<p>![屏幕截图 2024-07-23 193540](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193540.png)</p>
<h2 id="二十八，反射"><a href="#二十八，反射" class="headerlink" title="二十八，反射"></a>二十八，反射</h2><h2 id="1，类加载器"><a href="#1，类加载器" class="headerlink" title="1，类加载器"></a>1，类加载器</h2><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JYM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化</p>
<p>类的加载</p>
<p>就是指将class文件读入内存，并为之创建一个java.lang.Class对象</p>
<p>任何类被使用时，系统都会为之建立一个java.lang.Class对象</p>
<p>类的连接</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 194636.png)</p>
<p>类的初始化</p>
<p>在该阶段，主要是对类变量进行初始化</p>
<h3 id="①类加载"><a href="#①类加载" class="headerlink" title="①类加载"></a>①类加载</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 194848.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 194953.png)</p>
<h3 id="②类加载器"><a href="#②类加载器" class="headerlink" title="②类加载器"></a>②类加载器</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 195948.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 195902.png)</p>
<p>类加载器:ClassLoader</p>
<h2 id="2-反射"><a href="#2-反射" class="headerlink" title="2,反射"></a>2,反射</h2><h3 id="①反射概述"><a href="#①反射概述" class="headerlink" title="①反射概述"></a>①反射概述</h3><p>反射就是把java类中的各种成分映射成一个个的Java对象</p>
<p>Java反射机制:是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译器就完成确定，在运行期仍然可以扩展</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 200658.png)</p>
<h3 id="②获取Class类的对象"><a href="#②获取Class类的对象" class="headerlink" title="②获取Class类的对象"></a>②获取Class类的对象</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 201545.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 202549.png)</p>
<h3 id="③反射获取构造方法并使用"><a href="#③反射获取构造方法并使用" class="headerlink" title="③反射获取构造方法并使用"></a>③反射获取构造方法并使用</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 204011.png)</p>
<p>newInstance(Object… initargs)<br>           使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。<br>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用<br>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 204241.png)</p>
<h3 id="④练习"><a href="#④练习" class="headerlink" title="④练习"></a>④练习</h3><p>1</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 205301.png)</p>
<p>2</p>
<p>public void setAccessible(boolean flag):值为true,取消访问检查</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 210343.png)</p>
<h3 id="⑤反射获取成员变量并使用"><a href="#⑤反射获取成员变量并使用" class="headerlink" title="⑤反射获取成员变量并使用"></a>⑤反射获取成员变量并使用</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 211509.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 211544.png)</p>
<h3 id="⑥反射获取成员方法并使用"><a href="#⑥反射获取成员方法并使用" class="headerlink" title="⑥反射获取成员方法并使用"></a>⑥反射获取成员方法并使用</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 213258.png)</p>
<h1 id="二十九，模块化"><a href="#二十九，模块化" class="headerlink" title="二十九，模块化"></a>二十九，模块化</h1><h2 id="1，模块化概述"><a href="#1，模块化概述" class="headerlink" title="1，模块化概述"></a>1，模块化概述</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 213609.png)</p>
<h2 id="2，模块的基本使用"><a href="#2，模块的基本使用" class="headerlink" title="2，模块的基本使用"></a>2，模块的基本使用</h2><p><img src="/">![屏幕截图 2024-07-23 214553](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214553.png)</p>
<p>![屏幕截图 2024-07-23 214605](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214605.png)</p>
<p>![屏幕截图 2024-07-23 214648](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214648.png)</p>
<p>![屏幕截图 2024-07-23 214713](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214713.png)</p>
<h2 id="3，模块服务的使用"><a href="#3，模块服务的使用" class="headerlink" title="3，模块服务的使用"></a>3，模块服务的使用</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214934.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 215856.png)</p>
<p>![屏幕截图 2024-07-23 215907](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 215907.png)</p>
<p>![屏幕截图 2024-07-23 215953](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 215953.png)</p>
<p>![屏幕截图 2024-07-23 220009](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 220009.png)</p>
<p>![屏幕截图 2024-07-23 220017](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 220017.png)</p>
<p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 220147.png)</p>
<style>
        *{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        ul{
            list-style: none;
        }
        a{
            text-decoration: none;
            color: #000;
        }
        .head{ width:100%; height: 84px; display:block;position: sticky;top: 0; z-index: 2;transition: all 0.3s;background-color: #fff;}
        /* 设置页头内logo*/
        .head .logo{ display:block; height: 60px; width: 202px; position: absolute; left: 150px; top: 12px;background: url(img/logo2.png) no-repeat;background-size: contain;transition:background 0.3s;}
        /* 设置无序表 */
        .menu_list{ display: block; height:72px; width: 600px;;position: absolute; left: 700px; top: 0px; cursor: pointer; opacity: 1; transition:opacity 0.3s linear;transform: translate(0px,0);}
        /* 设置无序表的项 */
        .menu_list .menu_item{ display: inline-block; height:72px;  margin-left:72px; position: relative; }
        /* 设置无序表项的文本元素*/
        .menu_list .menu_item .txt{ display: block; height:72px; line-height: 72px; font-size: 16px; color: black; font-weight: bold; opacity: 0.95; transition:color 0.3s linear; position: relative; z-index: 2;}
        /* 用伪元素设置一个蓝条条，提升用户选中时的反馈 */
        .menu_list .menu_item .txt::after{content: "";background-color: rgb(4, 99, 231);display: block;border-radius: 4px;height: 4px;width: 100%;position: absolute;top: 50px;opacity: 0; transform: scale(0.01,1);transition: transform 0.2s ease-out, opacity 0.2s ease-out;}
        .menu_list .menu_item:hover .txt::after{content: "";background-color: rgb(4, 99, 231);display: block;border-radius: 4px;height: 4px;width: 100%;position: absolute;top: 50px;opacity: 1;transform: scale(1,1);transition: transform 0.2s ease-out, opacity 0.2s ease-out;}
    </style>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">王浩学</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2024/09/10/javase/">http://example.com/2024/09/10/javase/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">WhX</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://ts1.cn.mm.bing.net/th?id=OIP-C.Ig7_AHVk9TLxH7-p9riLHAHaHa&amp;w=250&amp;h=250&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;dpr=1.5&amp;pid=3.1&amp;rm=2" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/09/06/hello-world/" title="Hello World"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hello World</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://ts1.cn.mm.bing.net/th?id=OIP-C.Ig7_AHVk9TLxH7-p9riLHAHaHa&amp;w=250&amp;h=250&amp;c=8&amp;rs=1&amp;qlt=90&amp;o=6&amp;dpr=1.5&amp;pid=3.1&amp;rm=2" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">王浩学</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xue888666"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/haoxue666888" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="qqenvelope:3150291615@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">这是我的博客^-^</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%EF%BC%8C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">一，基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8C%E6%B3%A8%E9%87%8A"><span class="toc-number">1.0.1.</span> <span class="toc-text">1，注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.0.2.</span> <span class="toc-text">2,关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E5%B8%B8%E9%87%8F"><span class="toc-number">1.0.3.</span> <span class="toc-text">3，常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.4.</span> <span class="toc-text">4，数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.5.</span> <span class="toc-text">1,基本数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%8C%E5%8F%98%E9%87%8F"><span class="toc-number">1.0.6.</span> <span class="toc-text">5，变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%8C%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.0.7.</span> <span class="toc-text">6，标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.0.8.</span> <span class="toc-text">7，类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%8C%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.9.</span> <span class="toc-text">8，算术运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.0.10.</span> <span class="toc-text">9，字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%EF%BC%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-number">1.0.11.</span> <span class="toc-text">10，赋值运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%EF%BC%8C%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.12.</span> <span class="toc-text">11，自增自减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%EF%BC%8C%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.13.</span> <span class="toc-text">12，关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%EF%BC%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.14.</span> <span class="toc-text">13，逻辑运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%EF%BC%8C3%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.0.15.</span> <span class="toc-text">14，3元运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%EF%BC%8C%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5"><span class="toc-number">1.0.16.</span> <span class="toc-text">15，数据输入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%EF%BC%8C%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.</span> <span class="toc-text">二，分支语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.0.1.</span> <span class="toc-text">1，流程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8C%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84"><span class="toc-number">2.0.2.</span> <span class="toc-text">2，分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.0.2.1.</span> <span class="toc-text">if语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.0.3.</span> <span class="toc-text">switch 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#case%E7%A9%BF%E9%80%8F"><span class="toc-number">2.0.4.</span> <span class="toc-text">case穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.0.5.</span> <span class="toc-text">3，循环语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#for%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.0.6.</span> <span class="toc-text">for语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#while%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.0.6.1.</span> <span class="toc-text">while循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%91%E6%88%98%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.0.7.</span> <span class="toc-text">挑战控制语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%B5%8C%E5%A5%97"><span class="toc-number">2.0.8.</span> <span class="toc-text">循环嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#random"><span class="toc-number">2.0.9.</span> <span class="toc-text">random</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%EF%BC%8C%E6%95%B0%E7%BB%84"><span class="toc-number">3.</span> <span class="toc-text">五，数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8C%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.0.1.</span> <span class="toc-text">1，数组定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%8A%A8%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.0.2.</span> <span class="toc-text">3、动态初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-int-%E6%98%AF%E5%88%9B%E5%BB%BA%E6%95%B4%E5%9E%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-number">3.0.3.</span> <span class="toc-text">new int[]是创建整型数组的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%8C%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E8%AE%BF%E9%97%AE"><span class="toc-number">3.0.4.</span> <span class="toc-text">4，数组元素访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%8C%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">3.0.5.</span> <span class="toc-text">5，内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%8C%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">3.0.6.</span> <span class="toc-text">6，数组内存图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%8C%E9%9D%99%E6%80%81%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.0.7.</span> <span class="toc-text">7，静态初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%99%E6%80%81%EF%BC%9Aint-arr-new-int-1-2-3"><span class="toc-number">3.0.7.0.0.1.</span> <span class="toc-text">静态：int[] arr &#x3D;new int{1,2,3}</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%EF%BC%8C%E9%97%AE%E9%A2%98"><span class="toc-number">3.0.8.</span> <span class="toc-text">8，问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%B6%8A%E7%95%8C%EF%BC%9A%E8%AE%BF%E9%97%AE%E4%BA%86%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E7%B4%A2%E5%BC%95%E5%AF%B9%E5%BA%94%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">3.0.8.1.</span> <span class="toc-text">索引越界：访问了数组中不存在的索引对应的元素</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8"><span class="toc-number">3.0.8.1.1.</span> <span class="toc-text">空指针异常</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%EF%BC%8C%E9%81%8D%E5%8E%86"><span class="toc-number">3.0.9.</span> <span class="toc-text">9，遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%EF%BC%9A%E6%95%B0%E7%BB%84%E5%90%8D-length"><span class="toc-number">3.1.</span> <span class="toc-text">格式：数组名.length</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8C%83%E4%BE%8B%EF%BC%9Aarr-length"><span class="toc-number">3.1.0.1.</span> <span class="toc-text">范例：arr.length</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E9%80%9A%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.1.1.</span> <span class="toc-text">遍历通用格式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%EF%BC%8C%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">六，方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E6%A6%82%E5%BF%B5"><span class="toc-number">4.1.</span> <span class="toc-text">1，概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%EF%BC%9A%E5%B0%86%E5%85%B7%E6%9C%89%E7%8B%AC%E7%AB%8B%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97%E7%BB%84%E7%BB%87%E6%88%90%E4%B8%BA1%E4%B8%AA%E6%95%B4%E4%BD%93%EF%BC%8C%E4%BD%BF%E5%85%B7%E6%9C%89%E7%89%B9%E6%AE%8A%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%9B%86"><span class="toc-number">4.1.1.</span> <span class="toc-text">方法：将具有独立功能的代码块组织成为1个整体，使具有特殊功能的代码集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8C%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">2，方法定义与调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%8C%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E5%85%88%E5%AE%9A%E4%B9%89%E5%90%8E%E8%B0%83%E7%94%A8"><span class="toc-number">4.2.1.</span> <span class="toc-text">注意，方法必须先定义后调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E5%B8%A6%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8"><span class="toc-number">4.2.2.</span> <span class="toc-text">3，带参数方法定义与调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%BD%A2%E5%8F%82%E4%B8%8E%E5%AE%9E%E5%8F%82"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.形参与实参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B8%A6%E8%BF%94%E5%9B%9E%E5%80%BC%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.4.</span> <span class="toc-text">5.带返回值方法定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%8C%E6%96%B9%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.3.</span> <span class="toc-text">6，方法注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2"><span class="toc-number">4.3.0.0.1.</span> <span class="toc-text">③.</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">4.4.</span> <span class="toc-text">7，方法重载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%EF%BC%8C%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">4.5.</span> <span class="toc-text">8，方法参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%EF%BC%8C%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-number">4.6.</span> <span class="toc-text">9，数组遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E6%B1%82%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">4.6.1.</span> <span class="toc-text">10.求数组最大值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%EF%BC%8Cdebug"><span class="toc-number">5.</span> <span class="toc-text">六，debug</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E6%A6%82%E8%BF%B0"><span class="toc-number">5.1.</span> <span class="toc-text">1，概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A1%88%E4%BE%8B"><span class="toc-number">5.1.1.</span> <span class="toc-text">2.案例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%EF%BC%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80"><span class="toc-number">6.</span> <span class="toc-text">七，面向对象基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.</span> <span class="toc-text">1，类与对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%9B%BE"><span class="toc-number">6.1.1.</span> <span class="toc-text">2.对象内存图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%EF%BC%8C%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.1.2.</span> <span class="toc-text">①，多个对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%EF%BC%8C%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%8C%87%E5%90%91%E7%9B%B8%E5%90%8C"><span class="toc-number">6.1.3.</span> <span class="toc-text">②，多个对象指向相同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%EF%BC%8C%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">6.1.4.</span> <span class="toc-text">③，成员变量与局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%EF%BC%8C%E5%B0%81%E8%A3%85"><span class="toc-number">6.1.5.</span> <span class="toc-text">④，封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%EF%BC%8Cthis%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">6.1.6.</span> <span class="toc-text">⑤，this关键字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%EF%BC%8C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">7.</span> <span class="toc-text">八，构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">7.0.1.</span> <span class="toc-text">1.概述</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.</span> <span class="toc-text">八，字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8Cstring"><span class="toc-number">8.0.1.</span> <span class="toc-text">1，string</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8Cstring%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">8.0.2.</span> <span class="toc-text">2，string的特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">8.1.</span> <span class="toc-text">3，字符串的比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%8C%E4%B8%BE%E4%BE%8B"><span class="toc-number">8.1.1.</span> <span class="toc-text">4，举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%8CStringBuilder"><span class="toc-number">8.1.2.</span> <span class="toc-text">5，StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">构造方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E4%B8%8E%E5%8F%8D%E8%BD%AC"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">添加与反转</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringBuilder%E5%92%8CString%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">StringBuilder和String相互转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1%EF%BC%8CStringBuilder%E8%BD%AC%E6%8D%A2%E4%B8%BAString"><span class="toc-number">8.1.2.3.1.</span> <span class="toc-text">1，StringBuilder转换为String</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-String%E8%BD%AC%E6%8D%A2%E4%B8%BAStringBuilder"><span class="toc-number">8.1.2.3.2.</span> <span class="toc-text">2,String转换为StringBuilder</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-Users-31502-Pictures-Screenshots-%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE-2024-07-10-112853-png-%E4%B9%9D%EF%BC%8C%E9%9B%86%E5%90%88"><span class="toc-number">9.</span> <span class="toc-text">![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 112853.png)                                                                                九，集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8C%E6%A6%82%E8%BF%B0-1"><span class="toc-number">9.0.1.</span> <span class="toc-text">1，概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8CArrayList%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%92%8C%E6%B7%BB%E5%8A%A0%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.</span> <span class="toc-text">2，ArrayList构造方法和添加方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8CArrayList%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">3，ArrayList集合常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">9.2.1.</span> <span class="toc-text">例子：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%EF%BC%8C%E7%BB%A7%E6%89%BF"><span class="toc-number">10.</span> <span class="toc-text">十，继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8C%E6%A6%82%E8%BF%B0-2"><span class="toc-number">10.0.1.</span> <span class="toc-text">1，概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8C%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">10.0.1.1.</span> <span class="toc-text">2，继承的优缺点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8C%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">10.1.</span> <span class="toc-text">3，继承中变量的访问特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%8CSuper"><span class="toc-number">10.1.1.</span> <span class="toc-text">4，Super</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%8C%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">10.1.2.</span> <span class="toc-text">5，继承中构造方法的访问特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%8C%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9"><span class="toc-number">10.1.3.</span> <span class="toc-text">6，继承中成员方法的访问特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%EF%BC%8C%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">10.1.4.</span> <span class="toc-text">7，方法重写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%EF%BC%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">11.</span> <span class="toc-text">十一，修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8C%E5%8C%85"><span class="toc-number">11.0.1.</span> <span class="toc-text">1，包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8C%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">11.0.1.1.</span> <span class="toc-text">1，其实就是文件夹</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8C%E5%AF%BC%E5%8C%85"><span class="toc-number">11.0.2.</span> <span class="toc-text">2，导包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">11.0.3.</span> <span class="toc-text">3，修饰符的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8C%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">11.0.3.1.</span> <span class="toc-text">1，权限修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%8A%B6%E6%80%81%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">11.0.3.2.</span> <span class="toc-text">2.状态修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E4%BF%AE%E9%A5%B0%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">11.0.3.3.</span> <span class="toc-text">.static修饰的特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static%E8%AE%BF%E9%97%AE%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">11.0.3.4.</span> <span class="toc-text">.static访问特点：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%EF%BC%8C%E5%A4%9A%E6%80%81"><span class="toc-number">12.</span> <span class="toc-text">十二，多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%BC%E5%BC%8F"><span class="toc-number">12.0.1.</span> <span class="toc-text">1,格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8C%E7%89%B9%E7%82%B9"><span class="toc-number">12.0.2.</span> <span class="toc-text">2，特点</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB"><span class="toc-number">12.0.2.0.0.1.</span> <span class="toc-text">&#x2F;&#x2F;父类</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%AD%90%E7%B1%BBDog"><span class="toc-number">12.0.2.0.0.2.</span> <span class="toc-text">子类Dog:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E5%A5%BD%E5%A4%84%E4%B8%8E%E5%BC%8A%E7%AB%AF"><span class="toc-number">12.0.3.</span> <span class="toc-text">3，好处与弊端</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E8%BE%B9%E4%B8%8E%E5%8F%B3%E8%BE%B9%E4%B8%8D1%E6%A0%B7%EF%BC%8C%E5%81%87%E5%A6%82%E5%8F%B3%E8%BE%B9%E6%B2%A1%E6%9C%89%E5%B7%A6%E8%BE%B9%E7%9A%84%E6%96%B9%E6%B3%95%E5%B0%B1%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E8%80%8C%E5%B7%A6%E8%BE%B9%E9%99%A4%E9%87%8D%E5%90%8D%E5%A4%96%E6%97%A0%E9%99%90%E5%88%B6%E8%80%8C%E5%8F%B3%E8%BE%B9%E7%9A%84%E6%96%B9%E6%B3%95%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%B7%A6%E8%BE%B9%E5%AD%98%E5%9C%A8"><span class="toc-number">12.0.3.0.1.</span> <span class="toc-text">左边与右边不1样，假如右边没有左边的方法就无法使用，而左边除重名外无限制而右边的方法必须在左边存在</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%8C%E5%A4%9A%E6%80%81%E7%9A%84%E8%BD%AC%E5%9E%8B%EF%BC%88%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%88%B6%E7%B1%BB%E7%8B%AC%E6%9C%89%EF%BC%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%AD%90%E7%B1%BB%E7%8B%AC%E6%9C%89%EF%BC%8C%E4%BD%86%E6%98%AF%E6%97%A0%E8%AE%BA%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%E9%87%8D%E5%90%8D%E4%BB%8D%E7%84%B6%E6%98%AF%E5%AD%90%E7%B1%BB%EF%BC%89"><span class="toc-number">12.1.</span> <span class="toc-text">4，多态的转型（向上转型：可以使用父类独有，向下转型：可以使用子类独有，但是无论如何转换重名仍然是子类）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E7%B1%BB%E5%BC%95%E7%94%A8%E6%8C%87%E5%90%91%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%EF%BC%9B"><span class="toc-number">12.1.1.</span> <span class="toc-text">父类引用指向子类对象&#x2F;向上转型；</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B-%E7%88%B6%E4%BA%B2%E5%8F%98%E5%84%BF%E5%AD%90%EF%BC%8C%E9%9C%80%E8%A6%81%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">12.1.2.</span> <span class="toc-text">向下转型(父亲变儿子，需要强制转换):</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">13.</span> <span class="toc-text">十三，抽象类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%EF%BC%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">14.</span> <span class="toc-text">十四，接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%BC%8C%E6%A6%82%E8%BF%B0-3"><span class="toc-number">14.0.1.</span> <span class="toc-text">1，概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%88%90%E5%91%98%E7%89%B9%E7%82%B9"><span class="toc-number">14.0.2.</span> <span class="toc-text">2，接口的成员特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">14.0.3.</span> <span class="toc-text">3，类与接口的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">14.0.4.</span> <span class="toc-text">4，抽象类与接口的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94%EF%BC%8C%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">15.</span> <span class="toc-text">十五，形参和返回值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8C%E7%B1%BB%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">15.0.0.1.</span> <span class="toc-text">1，类名作为形参和返回值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">15.0.1.</span> <span class="toc-text">2，抽象类名作为形参和返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E6%8E%A5%E5%8F%A3%E5%90%8D%E4%BD%9C%E4%B8%BA%E5%BD%A2%E5%8F%82%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">15.0.2.</span> <span class="toc-text">3，接口名作为形参和返回值</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%EF%BC%8C%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">16.</span> <span class="toc-text">十六，内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="toc-number">16.0.1.</span> <span class="toc-text">1.概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#class%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-number">16.0.1.0.1.</span> <span class="toc-text">class修饰类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%EF%BC%8C%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">16.0.2.</span> <span class="toc-text">2.，成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">16.0.3.</span> <span class="toc-text">3,局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">16.0.4.</span> <span class="toc-text">4，匿名内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">16.0.5.</span> <span class="toc-text">5，匿名内部类在开发中的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">16.0.5.0.1.</span> <span class="toc-text">实现接口</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83%EF%BC%8CApi"><span class="toc-number">17.</span> <span class="toc-text">十七，Api</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-math"><span class="toc-number">17.0.1.</span> <span class="toc-text">1,math</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-system"><span class="toc-number">17.1.</span> <span class="toc-text">2,system</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8Cobject%E7%B1%BB"><span class="toc-number">17.1.1.</span> <span class="toc-text">3，object类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%BC%8CArrays"><span class="toc-number">17.1.2.</span> <span class="toc-text">4，Arrays</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">17.1.3.</span> <span class="toc-text">5，基本类型包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%A4%E4%BA%86char%E5%92%8Cint%E9%83%BD%E6%98%AF%E9%A6%96%E5%AD%97%E6%AF%8D%E5%A4%A7%E5%86%99"><span class="toc-number">17.1.3.1.</span> <span class="toc-text">除了char和int都是首字母大写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SimpleDataFormat"><span class="toc-number">17.1.3.2.</span> <span class="toc-text">SimpleDataFormat</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AB-%E5%BC%82%E5%B8%B8"><span class="toc-number">18.</span> <span class="toc-text">十八,异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0-2"><span class="toc-number">18.0.1.</span> <span class="toc-text">1.概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%BC%8Cjym%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">18.0.2.</span> <span class="toc-text">2，jym处理方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">18.0.3.</span> <span class="toc-text">3.异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BC%96%E8%AF%91%E6%97%B6%E5%BC%82%E5%B8%B8%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BC%82%E5%B8%B8%E5%8C%BA%E5%88%AB"><span class="toc-number">18.0.4.</span> <span class="toc-text">4.编译时异常和运行时异常区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%8Cthrows%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">18.0.4.1.</span> <span class="toc-text">4，throws处理异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%EF%BC%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">18.0.5.</span> <span class="toc-text">5，自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-throws%E5%92%8Cthrow%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">18.0.6.</span> <span class="toc-text">6.throws和throw的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D%EF%BC%8C%E9%9B%86%E5%90%88%E8%BF%9B%E9%98%B6"><span class="toc-number">19.</span> <span class="toc-text">十九，集合进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%86%E5%90%88%E7%B1%BB%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">19.0.0.1.</span> <span class="toc-text">1.集合类体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8C%E2%91%A0collection%E9%9B%86%E5%90%88%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">19.0.0.2.</span> <span class="toc-text">2，①collection集合概念和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BACollection%E9%9B%86%E5%90%88%E7%9A%84%E5%AF%B9%E8%B1%A1%EF%BC%9A"><span class="toc-number">19.0.0.2.1.</span> <span class="toc-text">创建Collection集合的对象：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%EF%BC%8Ccollection%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">19.0.0.3.</span> <span class="toc-text">②，collection集合常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%EF%BC%8Ccollection%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">19.0.0.4.</span> <span class="toc-text">③，collection的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3%EF%BC%8C%E9%9B%86%E5%90%88%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-number">19.0.0.4.1.</span> <span class="toc-text">④，集合使用步骤</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-list%E2%91%A0"><span class="toc-number">19.0.0.5.</span> <span class="toc-text">2.list①</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8C%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">19.1.</span> <span class="toc-text">3，增强for循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">19.2.</span> <span class="toc-text">格式：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%EF%BC%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">19.2.0.1.</span> <span class="toc-text">④，数据结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%EF%BC%8CList%E9%9B%86%E5%90%88%E5%AD%90%E7%B1%BB%E7%89%B9%E7%82%B9"><span class="toc-number">19.2.1.</span> <span class="toc-text">⑤，List集合子类特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5-LinkedList%E9%9B%86%E5%90%88%E7%9A%84%E7%89%B9%E6%9C%89%E5%8A%9F%E8%83%BD"><span class="toc-number">19.2.2.</span> <span class="toc-text">⑥.LinkedList集合的特有功能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-set%E9%9B%86%E5%90%88"><span class="toc-number">19.3.</span> <span class="toc-text">4.set集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1HashSet%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">19.3.0.1.</span> <span class="toc-text">②HashSet集合概述和特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">19.3.0.2.</span> <span class="toc-text">③哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%EF%BC%8Clinkhashset%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">19.3.0.3.</span> <span class="toc-text">④，linkhashset集合概述和特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4Treeset%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">19.3.0.4.</span> <span class="toc-text">⑤Treeset集合概述和特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%EF%BC%8C%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8FComparable%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88return%E7%9A%84%E6%98%AF%E6%AD%A3%E6%95%B0%E6%8A%8AS2%E6%94%BE%E5%9C%A8S1%E5%89%8D%E9%9D%A2%EF%BC%8C%EF%BC%89s2-s1%E4%B8%BA%E4%BB%8E%E5%A4%A7%E5%88%B0%E5%B0%8F%EF%BC%8Cs1-s2%E4%B8%BA%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7"><span class="toc-number">19.3.0.5.</span> <span class="toc-text">⑥，自然排序Comparable的使用（return的是正数把S2放在S1前面，）s2-s1为从大到小，s1-s2为从小到大</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%8C%E6%B3%9B%E5%9E%8B"><span class="toc-number">19.4.</span> <span class="toc-text">5，泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%EF%BC%8C%E6%B3%9B%E5%9E%8B%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%8F%82%E6%95%B0%E5%8C%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">19.4.0.1.</span> <span class="toc-text">①，泛型本质是参数化数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%EF%BC%8C%E6%B3%9B%E5%9E%8B%E5%AE%9A%E4%B9%89%E6%A0%BC%E5%BC%8F%EF%BC%9A"><span class="toc-number">19.4.0.2.</span> <span class="toc-text">②，泛型定义格式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E6%B3%9B%E5%9E%8B%E7%B1%BB"><span class="toc-number">19.4.0.3.</span> <span class="toc-text">③泛型类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3"><span class="toc-number">19.4.0.4.</span> <span class="toc-text">④泛型接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">19.4.0.5.</span> <span class="toc-text">⑤类型通配符&lt;?&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8A%E9%99%90"><span class="toc-number">19.4.0.6.</span> <span class="toc-text">类型通配符上限:&lt;?extends类型&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%E4%B8%8B%E9%99%90"><span class="toc-number">19.4.0.7.</span> <span class="toc-text">类型通配符下限:&lt;?super类型&gt;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">19.4.0.8.</span> <span class="toc-text">⑥可变参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%EF%BC%8Cmap%E9%9B%86%E5%90%88"><span class="toc-number">19.4.1.</span> <span class="toc-text">6，map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0-%E6%A6%82%E8%BF%B0"><span class="toc-number">19.4.1.1.</span> <span class="toc-text">① 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1-Map%E9%9B%86%E5%90%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD"><span class="toc-number">19.4.1.2.</span> <span class="toc-text">② Map集合的基本功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2Map%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E6%96%B9%E5%BC%8F1%EF%BC%89"><span class="toc-number">19.4.1.3.</span> <span class="toc-text">③Map集合的遍历（方式1）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%88%90map"><span class="toc-number">19.4.2.</span> <span class="toc-text">转换成map:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3Map%E9%9B%86%E5%90%88%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E6%96%B9%E5%BC%8F2%EF%BC%89"><span class="toc-number">19.4.2.1.</span> <span class="toc-text">④Map集合的遍历（方式2）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E4%B8%BAMap%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">19.4.2.1.1.</span> <span class="toc-text">转换为Map集合中的操作：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%EF%BC%8C%E5%B5%8C%E5%A5%97%E9%81%8D%E5%8E%86"><span class="toc-number">19.4.2.2.</span> <span class="toc-text">⑤，嵌套遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-Collections%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%BF%E7%94%A8%EF%BC%88%E5%AF%BC%E5%8C%85%EF%BC%89"><span class="toc-number">19.5.</span> <span class="toc-text">7,Collections概念和使用（导包）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%EF%BC%8Cio%E6%B5%81"><span class="toc-number">20.</span> <span class="toc-text">二十，io流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-file%EF%BC%88%E9%9C%80%E8%A6%81%E5%AF%BC%E5%8C%85%EF%BC%89%EF%BC%9A%E5%AE%83%E6%98%AF%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84%E5%90%8D%E7%9A%84%E6%8A%BD%E8%B1%A1%E8%A1%A8%E7%A4%BA"><span class="toc-number">20.1.</span> <span class="toc-text">1,file（需要导包）：它是文件和目录路径名的抽象表示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A0%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">20.1.0.0.1.</span> <span class="toc-text">①构造方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A1File%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">20.1.0.0.2.</span> <span class="toc-text">②File类创建功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A2file%E7%B1%BB%E5%88%A4%E6%96%AD%E5%92%8C%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">20.1.0.0.3.</span> <span class="toc-text">③file类判断和获取功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A3File%E7%B1%BB%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">20.1.0.0.4.</span> <span class="toc-text">④File类删除功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4%E9%80%92%E5%BD%92"><span class="toc-number">20.1.0.0.5.</span> <span class="toc-text">⑤递归</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E8%A6%81%E6%89%BE%E5%88%B0%E4%B8%A4%E4%B8%AA%E5%86%85%E5%AE%B9"><span class="toc-number">20.1.0.0.6.</span> <span class="toc-text">递归解决问题要找到两个内容:</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8C%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">20.2.</span> <span class="toc-text">2，字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0io%E6%B5%81%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">20.2.0.1.</span> <span class="toc-text">①io流概述：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%843%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">20.2.1.</span> <span class="toc-text">③字节流写数据的3种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E6%8D%A2%E8%A1%8C%E5%92%8C%E8%BF%BD%E5%8A%A0%E5%86%99%E5%85%A5"><span class="toc-number">20.2.1.1.</span> <span class="toc-text">④换行和追加写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4%E5%AD%97%E8%8A%82%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%88kan"><span class="toc-number">20.2.1.2.</span> <span class="toc-text">⑤字节流写数据加异常处理（kan)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE-%E4%B8%80%E6%AC%A1%E8%AF%BB%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE"><span class="toc-number">20.2.1.3.</span> <span class="toc-text">①字节流读数据(一次读一个字节数据)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A%E5%9C%A8Java%E4%B8%AD%EF%BC%8CInputStream-%E7%9A%84-read-%E6%96%B9%E6%B3%95%E6%AF%8F%E6%AC%A1%E8%B0%83%E7%94%A8%E6%97%B6%EF%BC%8C%E9%83%BD%E4%BC%9A%E5%B0%9D%E8%AF%95%E4%BB%8E%E8%BE%93%E5%85%A5%E6%B5%81%E4%B8%AD%E8%AF%BB%E5%8F%96%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E3%80%82%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%BD%A0%E8%BF%9E%E7%BB%AD%E8%B0%83%E7%94%A8%E4%B8%A4%E6%AC%A1-read-%E6%96%B9%E6%B3%95%EF%BC%88%E5%81%87%E8%AE%BE%E8%BE%93%E5%85%A5%E6%B5%81%E4%B8%AD%E6%9C%89%E8%B6%B3%E5%A4%9F%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%89%EF%BC%8C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%B0%83%E7%94%A8%E4%BC%9A%E8%AF%BB%E5%8F%96%E6%B5%81%E4%B8%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%8C%E8%80%8C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E8%B0%83%E7%94%A8%E4%BC%9A%E8%AF%BB%E5%8F%96%E7%B4%A7%E9%9A%8F%E5%85%B6%E5%90%8E%E7%9A%84%E7%AC%AC%E4%BA%8C%E4%B8%AA%E5%AD%97%E8%8A%82%E3%80%82"><span class="toc-number">20.2.1.3.1.</span> <span class="toc-text">注意：在Java中，InputStream 的 read() 方法每次调用时，都会尝试从输入流中读取下一个字节。这意味着，如果你连续调用两次 read() 方法（假设输入流中有足够的数据），第一次调用会读取流中的第一个字节，而第二次调用会读取紧随其后的第二个字节。</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#read-%E4%BB%8E%E6%B5%81%E4%B8%AD%E8%AF%BB%E5%8F%961%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E6%98%AF%E4%B8%80%E4%B8%AAint%EF%BC%8C%EF%BC%88%E5%A6%82%E6%9E%9C%E7%BC%96%E7%A0%81%E6%98%AF%E4%BB%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E8%BD%AC%E6%88%90char%EF%BC%8C%E7%94%A8%E6%9D%A5%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">20.2.1.3.2.</span> <span class="toc-text">read():从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#read-byte-b-%EF%BC%9A%E4%BB%8E%E6%B5%81%E4%B8%AD%E8%AF%BB%E5%8F%96b%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%AA%E5%AD%97%E8%8A%82%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%88%B0b%E4%B8%AD%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E6%98%AF%E8%AF%BB%E5%8F%96%E7%9A%84%E5%AD%97%E8%8A%82%E4%B8%AA%E6%95%B0%EF%BC%88%E5%BD%93%E5%86%8D%E6%AC%A1%E8%AF%BB%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%94%E5%9B%9E-1%E8%AF%B4%E6%98%8E%E5%88%B0%E4%BA%86%E7%BB%93%E5%B0%BE%EF%BC%8C%E6%B2%A1%E6%9C%89%E4%BA%86%E6%95%B0%E6%8D%AE%EF%BC%89"><span class="toc-number">20.2.1.3.3.</span> <span class="toc-text">read(byte[] b)：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E5%AD%97%E8%8A%82%E6%B5%81%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE%EF%BC%88%E4%B8%80%E6%AC%A1%E8%AF%BB%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%E6%95%B0%E6%8D%AE"><span class="toc-number">20.2.1.4.</span> <span class="toc-text">②字节流读取数据（一次读一个字节数组数据)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-read%EF%BC%88byte%EF%BC%89%E8%AF%BB%E5%8F%96%E7%9A%84%E6%98%AF%E6%89%80%E8%AF%BB%E5%AD%97%E8%8A%82%E7%9A%84%E9%95%BF%E5%BA%A6"><span class="toc-number">20.2.2.</span> <span class="toc-text">注意:read（byte）读取的是所读字节的长度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B0%86%E8%AF%BB%E5%8F%96%E7%9A%84%E5%AD%97%E8%8A%82%E5%AD%98%E5%88%B0bu%E9%87%8C%E9%9D%A2"><span class="toc-number">20.2.2.0.1.</span> <span class="toc-text">将读取的字节存到bu里面</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%A4%8D%E5%88%B6%E5%9B%BE%E7%89%87"><span class="toc-number">20.2.2.1.</span> <span class="toc-text">③复制图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E5%AD%97%E8%8A%82%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">20.2.2.2.</span> <span class="toc-text">①字节缓冲流</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8C%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-number">20.3.</span> <span class="toc-text">3，字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-number">20.3.0.1.</span> <span class="toc-text">①编码表</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8-%E6%8C%89%E7%85%A7A%E7%BC%96%E7%A0%81%E8%A1%A8%E5%AD%98%E5%82%A8%EF%BC%8C%E5%BF%85%E9%A1%BB%E6%8C%89%E7%85%A7A%E7%BC%96%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%8C%E5%90%A6%E5%88%99%E5%87%BA%E7%8E%B0%E4%B9%B1%E7%A0%81%E7%8E%B0%E8%B1%A1"><span class="toc-number">20.3.0.1.1.</span> <span class="toc-text">注:按照A编码表存储，必须按照A编码解析，否则出现乱码现象</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E9%97%AE%E9%A2%98"><span class="toc-number">20.3.0.2.</span> <span class="toc-text">②编码解码问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2%E5%AD%97%E7%AC%A6%E6%B5%81%E5%86%99%E6%95%B0%E6%8D%AE%E7%9A%84%E2%91%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">20.3.0.3.</span> <span class="toc-text">③字符流写数据的⑤种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8-%E5%86%99%E5%85%A5%E7%9A%84%E5%AD%97%E7%AC%A6%E5%AE%9E%E9%99%85%E6%98%AF%E7%94%B1c%E8%BD%AC%E6%8D%A2%E6%88%90%E5%AD%97%E7%AC%A6%E7%9A%84"><span class="toc-number">20.3.1.</span> <span class="toc-text">注:写入的字符实际是由c转换成字符的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3%E5%AD%97%E7%AC%A6%E6%B5%81%E8%AF%BB%E6%95%B0%E6%8D%AE%E7%9A%842%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">20.3.1.1.</span> <span class="toc-text">④字符流读数据的2种方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E5%AD%97%E7%AC%A6%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">20.3.2.</span> <span class="toc-text">⑤字符缓冲流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#io%E6%B5%81%E5%B0%8F%E7%BB%93"><span class="toc-number">20.3.3.</span> <span class="toc-text">io流小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E5%AD%98%E5%9C%A8%E5%8E%9F%E5%9B%A0"><span class="toc-number">20.3.3.1.</span> <span class="toc-text">字符流存在原因</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#write-read%E4%B8%8Ewrite-read-byte-b-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">20.3.3.1.1.</span> <span class="toc-text">write&#x2F;read与write&#x2F;read(byte[] b)的区别：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#308"><span class="toc-number">20.4.</span> <span class="toc-text">308</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B"><span class="toc-number">20.4.1.</span> <span class="toc-text">案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%8C%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E6%B5%81"><span class="toc-number">20.5.</span> <span class="toc-text">4，特殊操作流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">20.5.0.1.</span> <span class="toc-text">①标准输入输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">20.5.0.2.</span> <span class="toc-text">②打印流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81"><span class="toc-number">20.5.1.</span> <span class="toc-text">③对象序列化流</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E2%91%A4%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">20.5.1.0.1.</span> <span class="toc-text">⑤三个问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A5properties"><span class="toc-number">20.5.1.1.</span> <span class="toc-text">⑥properties</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.</span> <span class="toc-text">二十一，多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.1.</span> <span class="toc-text">1，实现多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E7%BA%BF%E7%A8%8B"><span class="toc-number">21.1.1.</span> <span class="toc-text">①线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">21.1.2.</span> <span class="toc-text">②多线程的实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E8%AE%BE%E7%BD%AE%E5%92%8C%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">21.1.3.</span> <span class="toc-text">③设置和获取线程名称的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6"><span class="toc-number">21.1.4.</span> <span class="toc-text">④线程调度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#public-final-int-getPriority-%E8%BF%94%E5%9B%9E%E6%AD%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">21.1.4.0.1.</span> <span class="toc-text">public final int getPriority():返回此线程的优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#public-final-void-setPriority-int-newPriority-%E6%9B%B4%E6%94%B9%E6%AD%A4%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">21.1.4.0.2.</span> <span class="toc-text">public final void setPriority(int newPriority):更改此线程的优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E7%BA%BF%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">21.1.5.</span> <span class="toc-text">⑤线程控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">21.1.6.</span> <span class="toc-text">⑥线程生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A6%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">21.1.7.</span> <span class="toc-text">⑦多线程的实现方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8C%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">21.2.</span> <span class="toc-text">2，线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">21.2.1.</span> <span class="toc-text">①为什么会出现线程同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">21.2.2.</span> <span class="toc-text">②同步代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">21.2.3.</span> <span class="toc-text">③同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E7%B1%BB"><span class="toc-number">21.2.4.</span> <span class="toc-text">④线程安全的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4lock%E9%94%81"><span class="toc-number">21.2.5.</span> <span class="toc-text">⑤lock锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%BC%8C%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">21.2.6.</span> <span class="toc-text">3，生产者消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">22.</span> <span class="toc-text">二十二，网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8"><span class="toc-number">22.1.</span> <span class="toc-text">1，网络编程入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">22.1.1.</span> <span class="toc-text">①计算机网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">22.1.2.</span> <span class="toc-text">②网络编程三要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3ip%E5%9C%B0%E5%9D%80"><span class="toc-number">22.1.3.</span> <span class="toc-text">④ip地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4InetAddress%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">22.1.4.</span> <span class="toc-text">⑤InetAddress的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E7%AB%AF%E5%8F%A3"><span class="toc-number">22.1.5.</span> <span class="toc-text">⑥端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E5%8D%8F%E8%AE%AE"><span class="toc-number">22.1.6.</span> <span class="toc-text">⑤协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8CUDP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">22.2.</span> <span class="toc-text">2，UDP通信程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8CTCP%E9%80%9A%E4%BF%A1%E7%A8%8B%E5%BA%8F"><span class="toc-number">22.3.</span> <span class="toc-text">3，TCP通信程序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0TCP%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="toc-number">22.3.1.</span> <span class="toc-text">①TCP通信原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1TCP%E6%8E%A5%E5%8F%97%E6%95%B0%E6%8D%AE"><span class="toc-number">22.3.2.</span> <span class="toc-text">②TCP接受数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E4%BE%8B%E5%AD%90"><span class="toc-number">22.3.3.</span> <span class="toc-text">③例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%89%EF%BC%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">23.</span> <span class="toc-text">二十三，Lambda表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E6%A6%82%E8%BF%B0"><span class="toc-number">23.1.</span> <span class="toc-text">1，函数式编程思想概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8CLambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%A0%87%E5%87%86%E6%A0%BC%E5%BC%8F"><span class="toc-number">23.2.</span> <span class="toc-text">2，Lambda表达式的标准格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8C%E7%BB%83%E4%B9%A0"><span class="toc-number">23.3.</span> <span class="toc-text">3，练习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%85%B6%E5%AE%9E%E5%B0%B1%E6%98%AF%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%EF%BC%88%E5%8F%82%E6%95%B0%EF%BC%89-%E6%96%B9%E6%B3%95%E4%BD%93"><span class="toc-number">23.3.0.1.</span> <span class="toc-text">Lambda表达式其实就是接口方法的重写（参数）-&gt;{方法体}</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%8C%E7%9C%81%E7%95%A5%E8%A7%84%E5%88%99"><span class="toc-number">23.4.</span> <span class="toc-text">4，省略规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">23.5.</span> <span class="toc-text">5，注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">23.6.</span> <span class="toc-text">6,Lambda表达式和匿名内部类的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%9B%9B%EF%BC%8C%E6%8E%A5%E5%8F%A3%E7%BB%84%E6%88%90%E6%9B%B4%E6%96%B0"><span class="toc-number">24.</span> <span class="toc-text">二十四，接口组成更新</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E6%A6%82%E8%BF%B0-4"><span class="toc-number">24.1.</span> <span class="toc-text">1，概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8C%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95"><span class="toc-number">24.2.</span> <span class="toc-text">2，接口默认方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E4%B8%AD%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-number">24.3.</span> <span class="toc-text">3.接口中静态方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%BC%8C%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">24.4.</span> <span class="toc-text">4，接口中私有方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%94%EF%BC%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%EF%BC%88%E8%BF%9B%E8%A1%8C%E9%87%8D%E5%86%99%EF%BC%88%E5%AE%9E%E7%8E%B0%EF%BC%89%EF%BC%8C%E5%90%8C%E6%97%B6%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">25.</span> <span class="toc-text">二十五，方法引用（进行重写（实现），同时调用方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E6%96%B9%E6%B3%95%E5%BC%95%E7%94%A8%E7%AC%A6"><span class="toc-number">25.1.</span> <span class="toc-text">1，方法引用符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%AF%E6%8C%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">25.2.</span> <span class="toc-text">2,Lambda表达式支持的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%BC%95%E7%94%A8%E7%B1%BB%E6%96%B9%E6%B3%95"><span class="toc-number">25.2.1.</span> <span class="toc-text">①引用类方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E5%BC%95%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">25.2.2.</span> <span class="toc-text">②引用对象的实例方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%BC%95%E7%94%A8%E7%B1%BB%E7%9A%84%E7%9A%84%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">25.2.3.</span> <span class="toc-text">③引用类的的实例方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E5%BC%95%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">25.2.4.</span> <span class="toc-text">④引用构造器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AD%EF%BC%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.</span> <span class="toc-text">二十六，函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">26.1.</span> <span class="toc-text">1，函数式接口作为方法的参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E4%BD%9C%E4%B8%BA%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">26.2.</span> <span class="toc-text">2，函数式接口作为方法的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8C%E5%B8%B8%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.3.</span> <span class="toc-text">3，常用的函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0Supplier%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.3.1.</span> <span class="toc-text">①Supplier接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F-return%E5%8F%AF%E4%BB%A5%E7%9C%81%E7%95%A5"><span class="toc-number">26.3.1.0.1.</span> <span class="toc-text">注意:return可以省略</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1consumer%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.3.2.</span> <span class="toc-text">②consumer接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#q%EF%BC%9A"><span class="toc-number">26.3.2.0.1.</span> <span class="toc-text">q：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2Predicate%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.3.3.</span> <span class="toc-text">③Predicate接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3Function%E6%8E%A5%E5%8F%A3"><span class="toc-number">26.3.4.</span> <span class="toc-text">④Function接口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%83%EF%BC%8CStream%E6%B5%81"><span class="toc-number">27.</span> <span class="toc-text">二十七，Stream流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E4%BD%93%E9%AA%8C"><span class="toc-number">27.1.</span> <span class="toc-text">1，体验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8CStream%E6%B5%81%E7%9A%84%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F"><span class="toc-number">27.2.</span> <span class="toc-text">2，Stream流的生成方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8CStream%E6%B5%81%E7%9A%84%E5%B8%B8%E8%A7%81%E4%B8%AD%E9%97%B4%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">27.3.</span> <span class="toc-text">3，Stream流的常见中间操作方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A0Streamfilter-Predicate-predicate-%E7%94%A8%E4%BA%8E%E5%AF%B9%E6%B5%81%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4"><span class="toc-number">27.3.0.1.</span> <span class="toc-text">①Streamfilter(Predicate predicate):用于对流中的数据进行过滤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Predicate%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95-boolean-test-T-t-%E5%AF%B9%E7%BB%99%E5%AE%9A%E7%9A%84%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%88%A4%E6%96%AD%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%B8%83%E5%B0%94%E5%80%BC"><span class="toc-number">27.3.0.2.</span> <span class="toc-text">Predicate接口中的方法          boolean test(T t):对给定的参数进行判断，返回一个布尔值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A1Streamlimit-long-maxSize-%E8%BF%94%E5%9B%9E%E6%AD%A4%E6%B5%81%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0%E7%BB%84%E6%88%90%E7%9A%84%E6%B5%81%EF%BC%8C%E6%88%AA%E5%8F%96%E5%89%8D%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E7%9A%84%E6%95%B0%E6%8D%AE"><span class="toc-number">27.3.0.3.</span> <span class="toc-text">②Streamlimit(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Streamskip-long-n-%E8%B7%B3%E8%BF%87%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E8%BF%94%E5%9B%9E%E7%94%B1%E8%AF%A5%E6%B5%81%E7%9A%84%E5%89%A9%E4%BD%99%E5%85%83%E7%B4%A0%E7%BB%84%E6%88%90%E7%9A%84%E6%B5%81"><span class="toc-number">27.3.0.4.</span> <span class="toc-text">Streamskip(long n):跳过指定参数个数的数据，返回由该流的剩余元素组成的流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A2staticStreamconcat-Stream-a-Stream-b-%E5%90%88%E5%B9%B6a%E5%92%8Cb%E4%B8%A4%E4%B8%AA%E6%B5%81%E4%B8%BA%E4%B8%80%E4%B8%AA%E6%B5%81"><span class="toc-number">27.3.0.5.</span> <span class="toc-text">③staticStreamconcat(Stream a,Stream b):合并a和b两个流为一个流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Streamdistinct-%E8%BF%94%E5%9B%9E%E7%94%B1%E8%AF%A5%E6%B5%81%E7%9A%84%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0-%E6%A0%B9%E6%8D%AEObject-equals-Object-%E7%BB%84%E6%88%90%E7%9A%84%E6%B5%81"><span class="toc-number">27.3.0.6.</span> <span class="toc-text">Streamdistinct():返回由该流的不同元素(根据Object.equals(Object))组成的流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A3Streamsorted-%E8%BF%94%E5%9B%9E%E7%94%B1%E6%AD%A4%E6%B5%81%E7%9A%84%E5%85%83%E7%B4%A0%E7%BB%84%E6%88%90%E7%9A%84%E6%B5%81%EF%BC%8C%E6%A0%B9%E6%8D%AE%E8%87%AA%E7%84%B6%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">27.3.0.7.</span> <span class="toc-text">④Streamsorted():返回由此流的元素组成的流，根据自然顺序排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Streamsorted-Comparator-comparator-%E8%BF%94%E5%9B%9E%E7%94%B1%E6%AD%A4%E6%B5%81%E7%9A%84%E5%85%83%E7%B4%A0%E7%BB%84%E6%88%90%E7%9A%84%E6%B5%81%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%8F%90%E4%BE%9B%E7%9A%84Comparator%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">27.3.0.8.</span> <span class="toc-text">Streamsorted(Comparator comparator):返回由此流的元素组成的流，根据提供的Comparator进行排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%91%A4Streammap-Function-mapper-%E8%BF%94%E5%9B%9E%E7%94%B1%E7%BB%99%E5%AE%9A%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E4%BA%8E%E6%AD%A4%E6%B5%81%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%93%E6%9E%9C%E7%BB%84%E6%88%90%E7%9A%84%E6%B5%81"><span class="toc-number">27.3.0.9.</span> <span class="toc-text">⑤Streammap(Function mapper):返回由给定函数应用于此流的元素的结果组成的流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IntStream-map-Tolnt-TolntFunction-mapper-%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AAIntStream%E5%85%B6%E4%B8%AD%E5%8C%85%E5%90%AB%E5%B0%86%E7%BB%99%E5%AE%9A%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E4%BA%8E%E6%AD%A4%E6%B5%81%E7%9A%84%E5%85%83%E7%B4%A0%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">27.3.0.10.</span> <span class="toc-text">IntStream map Tolnt(TolntFunction mapper):返回一个IntStream其中包含将给定函数应用于此流的元素的结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%B8%B8%E8%A7%81%E7%BB%88%E7%BB%93%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="toc-number">27.4.</span> <span class="toc-text">4,常见终结操作方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%BC%8C%E7%BB%83%E4%B9%A0"><span class="toc-number">27.5.</span> <span class="toc-text">5，练习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%BC%8CStream%E6%B5%81%E7%9A%84%E6%94%B6%E9%9B%86%E6%93%8D%E4%BD%9C"><span class="toc-number">27.6.</span> <span class="toc-text">6，Stream流的收集操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AB%EF%BC%8C%E5%8F%8D%E5%B0%84"><span class="toc-number">27.7.</span> <span class="toc-text">二十八，反射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">27.8.</span> <span class="toc-text">1，类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">27.8.1.</span> <span class="toc-text">①类加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">27.8.2.</span> <span class="toc-text">②类加载器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8F%8D%E5%B0%84"><span class="toc-number">27.9.</span> <span class="toc-text">2,反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A0%E5%8F%8D%E5%B0%84%E6%A6%82%E8%BF%B0"><span class="toc-number">27.9.1.</span> <span class="toc-text">①反射概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A1%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">27.9.2.</span> <span class="toc-text">②获取Class类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A2%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">27.9.3.</span> <span class="toc-text">③反射获取构造方法并使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A3%E7%BB%83%E4%B9%A0"><span class="toc-number">27.9.4.</span> <span class="toc-text">④练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A4%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">27.9.5.</span> <span class="toc-text">⑤反射获取成员变量并使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%91%A5%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">27.9.6.</span> <span class="toc-text">⑥反射获取成员方法并使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B9%9D%EF%BC%8C%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-number">28.</span> <span class="toc-text">二十九，模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%BC%8C%E6%A8%A1%E5%9D%97%E5%8C%96%E6%A6%82%E8%BF%B0"><span class="toc-number">28.1.</span> <span class="toc-text">1，模块化概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%BC%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">28.2.</span> <span class="toc-text">2，模块的基本使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%BC%8C%E6%A8%A1%E5%9D%97%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">28.3.</span> <span class="toc-text">3，模块服务的使用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/10/javase/" title="javase">javase</a><time datetime="2024-09-10T12:17:26.000Z" title="发表于 2024-09-10 20:17:26">2024-09-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/09/06/hello-world/" title="Hello World">Hello World</a><time datetime="2024-09-06T08:39:13.063Z" title="发表于 2024-09-06 16:39:13">2024-09-06</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By 王浩学</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="false" data-text="我,爱,你" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>