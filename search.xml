<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>javase</title>
      <link href="/2024/09/10/javase/"/>
      <url>/2024/09/10/javase/</url>
      
        <content type="html"><![CDATA[<h1 id="一，基础知识"><a href="#一，基础知识" class="headerlink" title="一，基础知识"></a>一，基础知识</h1><h3 id="1，注释"><a href="#1，注释" class="headerlink" title="1，注释"></a>1，注释</h3><p>说明性信息</p><hr><p>单行注释</p><p>格式:&#x2F;&#x2F;注释信息</p><hr><p>多行注释</p><p>格式：&#x2F;<em>注释信息</em>&#x2F;</p><h3 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2,关键字"></a>2,关键字</h3><p> 有特定含义</p><p>字母全都小写</p><p>编辑器对关键字有颜色特殊标注</p><h3 id="3，常量"><a href="#3，常量" class="headerlink" title="3，常量"></a>3，常量</h3><p>1，字符串常量：“helloworld”</p><p>2，整数常量：不带小数的数字</p><p>3、小数常量：带小数的数字</p><p>4，字符常量：‘a’   ‘0‘</p><p>5，布尔常量：true false</p><p>6，空常量：null 不能直接输出</p><h3 id="4，数据类型"><a href="#4，数据类型" class="headerlink" title="4，数据类型"></a>4，数据类型</h3><p>最小信息单元：位（bit）b  </p><p>最小存储单元字节(byte) B</p><p>1B&#x3D;8bit</p><p>1KB&#x3D;1024B</p><p>1MB&#x3D;1024KB</p><p>1GB&#x3D;1024MB</p><p>1TB&#x3D;1024GB</p><h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1,基本数据类型"></a>1,基本数据类型</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 103350.png)</p><h3 id="5，变量"><a href="#5，变量" class="headerlink" title="5，变量"></a>5，变量</h3><p>值可以改变的量</p><p>存续在内存上</p><p>数据类型 变量名&#x3D;变量值</p><p>eg：int a&#x3D;10；</p><p>取值：变量名 eg：a</p><p>修改值：变量名&#x3D;变量值</p><p>如：a&#x3D;20；</p><p><em><strong>注意事项</strong></em>：</p><p>由于整数默认int  浮点数默认double所以数字后要加大写首字母</p><p>eg：float f &#x3D;14.12F</p><p>​long 1&#x3D;10324234820L</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 110416.png)</p><h3 id="6，标识符"><a href="#6，标识符" class="headerlink" title="6，标识符"></a>6，标识符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 110731.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 111003.png)</p><p>小驼峰是变量，方法；大驼峰是类</p><h3 id="7，类型转换"><a href="#7，类型转换" class="headerlink" title="7，类型转换"></a>7，类型转换</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 111551.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 111633.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 112009.png) </p><h3 id="8，算术运算符"><a href="#8，算术运算符" class="headerlink" title="8，算术运算符"></a>8，算术运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 142516.png)</p><h3 id="9，字符串"><a href="#9，字符串" class="headerlink" title="9，字符串"></a>9，字符串</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 143911.png)</p><h3 id="10，赋值运算"><a href="#10，赋值运算" class="headerlink" title="10，赋值运算"></a>10，赋值运算</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 144709.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 145005.png)</p><h3 id="11，自增自减运算符"><a href="#11，自增自减运算符" class="headerlink" title="11，自增自减运算符"></a>11，自增自减运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 145542.png)</p><h3 id="12，关系运算符"><a href="#12，关系运算符" class="headerlink" title="12，关系运算符"></a>12，关系运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 150129.png)</p><p>![ ](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 150309.png)</p><h3 id="13，逻辑运算符"><a href="#13，逻辑运算符" class="headerlink" title="13，逻辑运算符"></a>13，逻辑运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 151005.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 151101.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 152056.png)</p><h3 id="14，3元运算符"><a href="#14，3元运算符" class="headerlink" title="14，3元运算符"></a>14，3元运算符</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 153518.png)</p><h3 id="15，数据输入"><a href="#15，数据输入" class="headerlink" title="15，数据输入"></a>15，数据输入</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 160251.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 160522.png)</p><p>例子，3个和尚</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 161131.png)</p><h1 id="二，分支语句"><a href="#二，分支语句" class="headerlink" title="二，分支语句"></a>二，分支语句</h1><h3 id="1，流程控制"><a href="#1，流程控制" class="headerlink" title="1，流程控制"></a>1，流程控制</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162032.png)</p><h3 id="2，分支结构"><a href="#2，分支结构" class="headerlink" title="2，分支结构"></a>2，分支结构</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162150.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162407.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162515.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 162736.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 164831.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 165229.png)</p><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 171550.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 171726.png)</p><h3 id="case穿透"><a href="#case穿透" class="headerlink" title="case穿透"></a>case穿透</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172248.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172324.png)</p><h3 id="3，循环语句"><a href="#3，循环语句" class="headerlink" title="3，循环语句"></a>3，循环语句</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172640.png)</p><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172913.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 172945.png)</p><p>eg</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 174341.png)</p><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 174702.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 174936.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 191512.png)</p><p><img src="/">![屏幕截图 2024-07-08 191620](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 191620.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 192107.png)</p><h3 id="挑战控制语句"><a href="#挑战控制语句" class="headerlink" title="挑战控制语句"></a>挑战控制语句</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 193155.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 193231.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 193301.png)</p><h3 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 194016.png)</p><h3 id="random"><a href="#random" class="headerlink" title="random"></a>random</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 194226.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 194510.png)</p><p>​                                                                                                       <em><strong>idea</strong></em></p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 204829.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 205243.png)</p><h1 id="五，数组"><a href="#五，数组" class="headerlink" title="五，数组"></a>五，数组</h1><h3 id="1，数组定义"><a href="#1，数组定义" class="headerlink" title="1，数组定义"></a>1，数组定义</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 210034.png)</p><h3 id="3、动态初始化"><a href="#3、动态初始化" class="headerlink" title="3、动态初始化"></a>3、动态初始化</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 210501.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 210643.png)</p><h3 id="new-int-是创建整型数组的基本用法"><a href="#new-int-是创建整型数组的基本用法" class="headerlink" title="new int[]是创建整型数组的基本用法"></a>new int[]是创建整型数组的基本用法</h3><h3 id="4，数组元素访问"><a href="#4，数组元素访问" class="headerlink" title="4，数组元素访问"></a>4，数组元素访问</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 212046.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 212143.png)</p><h3 id="5，内存分配"><a href="#5，内存分配" class="headerlink" title="5，内存分配"></a>5，内存分配</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 213607.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 213937.png)</p><h3 id="6，数组内存图"><a href="#6，数组内存图" class="headerlink" title="6，数组内存图"></a>6，数组内存图</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 214357.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 214813.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 215146.png)</p><h3 id="7，静态初始化"><a href="#7，静态初始化" class="headerlink" title="7，静态初始化"></a>7，静态初始化</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 215418.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 215832.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-08 215854.png)</p><h6 id="静态：int-arr-new-int-1-2-3"><a href="#静态：int-arr-new-int-1-2-3" class="headerlink" title="静态：int[] arr &#x3D;new int{1,2,3}"></a>静态：int[] arr &#x3D;new int{1,2,3}</h6><p>动态：int[] arr&#x3D;new int[3]</p><h3 id="8，问题"><a href="#8，问题" class="headerlink" title="8，问题"></a>8，问题</h3><h4 id="索引越界：访问了数组中不存在的索引对应的元素"><a href="#索引越界：访问了数组中不存在的索引对应的元素" class="headerlink" title="索引越界：访问了数组中不存在的索引对应的元素"></a>索引越界：访问了数组中不存在的索引对应的元素</h4><h5 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 070959.png)</p><h3 id="9，遍历"><a href="#9，遍历" class="headerlink" title="9，遍历"></a>9，遍历</h3><h2 id="格式：数组名-length"><a href="#格式：数组名-length" class="headerlink" title="格式：数组名.length"></a>格式：数组名.length</h2><h4 id="范例：arr-length"><a href="#范例：arr-length" class="headerlink" title="范例：arr.length"></a>范例：arr.length</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 071914.png)</p><h3 id="遍历通用格式"><a href="#遍历通用格式" class="headerlink" title="遍历通用格式"></a>遍历通用格式</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 071950.png)</p><h1 id="六，方法"><a href="#六，方法" class="headerlink" title="六，方法"></a>六，方法</h1><h2 id="1，概念"><a href="#1，概念" class="headerlink" title="1，概念"></a>1，概念</h2><h3 id="方法：将具有独立功能的代码块组织成为1个整体，使具有特殊功能的代码集"><a href="#方法：将具有独立功能的代码块组织成为1个整体，使具有特殊功能的代码集" class="headerlink" title="方法：将具有独立功能的代码块组织成为1个整体，使具有特殊功能的代码集"></a>方法：将具有独立功能的代码块组织成为1个整体，使具有特殊功能的代码集</h3><p>注意：</p><p>方法必须先创建才可以使用，该过程称为方法定义</p><p>方法创建后并不是直接运行的，需要手动使用后才执行，该过程称为方法调用</p><h2 id="2，方法定义与调用"><a href="#2，方法定义与调用" class="headerlink" title="2，方法定义与调用"></a>2，方法定义与调用</h2><p>①，方法定义</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 074659.png)</p><p>②.方法调用</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 075139.png)</p><h3 id="注意，方法必须先定义后调用"><a href="#注意，方法必须先定义后调用" class="headerlink" title="注意，方法必须先定义后调用"></a>注意，方法必须先定义后调用</h3><p>案例：</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 080453.png)</p><h3 id="3，带参数方法定义与调用"><a href="#3，带参数方法定义与调用" class="headerlink" title="3，带参数方法定义与调用"></a>3，带参数方法定义与调用</h3><p>定义</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 080625.png)</p><p>注意：</p><p>方法定义时，参数的数据类型与变量名都不能缺少，缺少任意1个程序将报错</p><p>方法定义时，多个参数之间使用逗号（，）分隔</p><p>调用</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 081014.png)</p><p>注意</p><p>方法调用时，参数的数量与类型必须与方法定义中的设置相匹配，否则程序将报错</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 081812.png)</p><h3 id="4-形参与实参"><a href="#4-形参与实参" class="headerlink" title="4.形参与实参"></a>4.形参与实参</h3><p>形参：方法定义中的参数</p><p>如 int number</p><p>实参：方法调用中的参数</p><p>如10    number</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 082142.png)</p><h3 id="5-带返回值方法定义"><a href="#5-带返回值方法定义" class="headerlink" title="5.带返回值方法定义"></a>5.带返回值方法定义</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 082702.png)</p><p>注意：方法定义时return后面的返回值与方法定义上的数据类型要匹，否则程序将报错</p><p>调用</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 083024.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 083148.png)</p><p>在 main()方法中调用定义好的方法可直接打印结果</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 083513.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 083728.png)</p><h2 id="6，方法注意事项"><a href="#6，方法注意事项" class="headerlink" title="6，方法注意事项"></a>6，方法注意事项</h2><p>①.方法不能嵌套定义</p><p>②.void表示无返回值，可以省略return,也可以单独书写return，后面不加数据。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 084140.png)</p><p>return表结束</p><h5 id="③"><a href="#③" class="headerlink" title="③."></a>③.</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 084443.png)</p><p>④.![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 084553.png)</p><p>参数是数据类型 变量名</p><h2 id="7，方法重载"><a href="#7，方法重载" class="headerlink" title="7，方法重载"></a>7，方法重载</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 084930.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 085636.png)</p><h2 id="8，方法参数传递"><a href="#8，方法参数传递" class="headerlink" title="8，方法参数传递"></a>8，方法参数传递</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 092541.png)</p><p>原因，并没有将其值调用回（return）main函数  </p><p>而对于引用类型参数穿递，引用类型变量存储的是内存地址，传参后形参和实参指向内存中同1位置，形参改变自然会影响实参</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 094516.png)</p><h2 id="9，数组遍历"><a href="#9，数组遍历" class="headerlink" title="9，数组遍历"></a>9，数组遍历</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 094709.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 095410.png)</p><h3 id="10-求数组最大值"><a href="#10-求数组最大值" class="headerlink" title="10.求数组最大值"></a>10.求数组最大值</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 101623.png)</p><h1 id="六，debug"><a href="#六，debug" class="headerlink" title="六，debug"></a>六，debug</h1><h2 id="1，概述"><a href="#1，概述" class="headerlink" title="1，概述"></a>1，概述</h2><p>是供程序使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 102211.png)</p><p><img src="/">![屏幕截图 2024-07-09 102217](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 102217.png)</p><p>1，加断点</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 102316.png)</p><p>2，右键</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 102418.png)</p><p>3，看debugger窗口，console窗口（执行结果）</p><p>4，f7继续执行</p><p>5，左键删除</p><h3 id="2-案例"><a href="#2-案例" class="headerlink" title="2.案例"></a>2.案例</h3><p>查找</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 144516.png)</p><h1 id="七，面向对象基础"><a href="#七，面向对象基础" class="headerlink" title="七，面向对象基础"></a>七，面向对象基础</h1><h2 id="1，类与对象"><a href="#1，类与对象" class="headerlink" title="1，类与对象"></a>1，类与对象</h2><p>类是对现实生活中1类具有共同属性和行为的事物的抽象</p><p>特点1，类是对象的数据类型</p><p>2.类是具有相同<strong>属性</strong>和<strong>行为</strong>的1组对象的集合</p><p>行为对象执行的操作</p><p>类的定义（不用加static）</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 163459.png)</p><p>成员变量的使用如图所示：</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 161252.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 162347.png)</p><p>eg：</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 164354.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 164410.png)</p><p>这说明上1个类是下1个类的容器</p><h3 id="2-对象内存图"><a href="#2-对象内存图" class="headerlink" title="2.对象内存图"></a>2.对象内存图</h3><h3 id="①，多个对象"><a href="#①，多个对象" class="headerlink" title="①，多个对象"></a>①，多个对象</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 170753.png)</p><h3 id="②，多个对象指向相同"><a href="#②，多个对象指向相同" class="headerlink" title="②，多个对象指向相同"></a>②，多个对象指向相同</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 171830.png)</p><p>首先是堆内存装的是林青霞后s2&#x3D;s1将s1的地址赋值给s2之后，s2的地址也变成001，经过后续修改直接改变001存放的值，变为张曼玉</p><h3 id="③，成员变量与局部变量"><a href="#③，成员变量与局部变量" class="headerlink" title="③，成员变量与局部变量"></a>③，成员变量与局部变量</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 173540.png)</p><p>区别</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 173630.png)</p><h3 id="④，封装"><a href="#④，封装" class="headerlink" title="④，封装"></a>④，封装</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 174559.png)</p><h3 id="⑤，this关键字"><a href="#⑤，this关键字" class="headerlink" title="⑤，this关键字"></a>⑤，this关键字</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 191653.png)</p><h1 id="八，构造方法"><a href="#八，构造方法" class="headerlink" title="八，构造方法"></a>八，构造方法</h1><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>特殊方法，作用为创造对象</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 215406.png)</p><p>功能：主要是完成对象数据的初始化</p><p>当你没有构造方法时，系统会有一个默认无参的构造方法，就可以在其他类实例化对象，如果定义了构造方法，系统将不再提供默认的构造方法</p><p>只要有无参构造方法，实例化对象就不需要参数，否则实例化一定有参数</p><p>构造方法的作用是 类实例化创建对象 类中的成员变量赋上默认值 也可以对类中的成员变量进行初始化 </p><p>推荐无论是否使用，都手工书写无参构造方法</p><p>实例化时自动调用其方法或变量</p><p>2，标准类制作</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 074801.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 075001.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 075041.png)</p><h1 id="八，字符串"><a href="#八，字符串" class="headerlink" title="八，字符串"></a>八，字符串</h1><h3 id="1，string"><a href="#1，string" class="headerlink" title="1，string"></a>1，string</h3><p>string类代表字符串 </p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 204746.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 204859.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 211459.png)</p><h3 id="2，string的特点"><a href="#2，string的特点" class="headerlink" title="2，string的特点"></a>2，string的特点</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 212720.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 212737.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 213014.png)</p><h2 id="3，字符串的比较"><a href="#3，字符串的比较" class="headerlink" title="3，字符串的比较"></a>3，字符串的比较</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 214429.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-09 214500.png)</p><h3 id="4，举例"><a href="#4，举例" class="headerlink" title="4，举例"></a>4，举例</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 085539.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 090417.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 093406.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 093423.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 100607.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 100634.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 100652.png)</p><h3 id="5，StringBuilder"><a href="#5，StringBuilder" class="headerlink" title="5，StringBuilder"></a>5，StringBuilder</h3><p>避免由于拼接导致的内存占用浪费</p><p>是1个可变的字符串类，可以看成1个容器，可变指的是StringBuilder对象中的内容是可变的</p><p>String：内容不可变而StringBuilder:内容是可变的</p><h4 id="构造方法："><a href="#构造方法：" class="headerlink" title="构造方法："></a>构造方法：</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 102303.png)</p><h4 id="添加与反转"><a href="#添加与反转" class="headerlink" title="添加与反转"></a>添加与反转</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 104954.png)</p><h4 id="StringBuilder和String相互转换"><a href="#StringBuilder和String相互转换" class="headerlink" title="StringBuilder和String相互转换"></a>StringBuilder和String相互转换</h4><h5 id="1，StringBuilder转换为String"><a href="#1，StringBuilder转换为String" class="headerlink" title="1，StringBuilder转换为String"></a>1，StringBuilder转换为String</h5><p>public String to String():通过toString()就可以实现把StringBuilder转换为String</p><h5 id="2-String转换为StringBuilder"><a href="#2-String转换为StringBuilder" class="headerlink" title="2,String转换为StringBuilder"></a>2,String转换为StringBuilder</h5><p>public StringBuilder(String s):通过构造方法就可以实把String转换为StringBuilder</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 110723.png)</p><p>用Springbuildr构造字符串拼接</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 111553.png)</p><p>反转</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 112722.png)&#x3D;![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 112751.png)</p><h1 id="C-Users-31502-Pictures-Screenshots-屏幕截图-2024-07-10-112853-png-九，集合"><a href="#C-Users-31502-Pictures-Screenshots-屏幕截图-2024-07-10-112853-png-九，集合" class="headerlink" title="![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 112853.png)                                                                                九，集合"></a>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 112853.png)                                                                                九，集合</h1><h3 id="1，概述-1"><a href="#1，概述-1" class="headerlink" title="1，概述"></a>1，概述</h3><p>提供1种存储空间可变的存储模型，存储的数据量可以发生改变</p><p>ArrayList<E> </p><p>可调整大小的数组实现</p><p><E>是1种数据类型&#x2F;f泛型类如ArrayList<String>,ArrayList<Student></p><h2 id="2，ArrayList构造方法和添加方法"><a href="#2，ArrayList构造方法和添加方法" class="headerlink" title="2，ArrayList构造方法和添加方法"></a>2，ArrayList构造方法和添加方法</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 143859.png)</p><p>这其中的方法是已经有的，在调用完对象可直接使用</p><p>变量名.add():将元素加到集合末尾</p><p>如array.add(“hello”);</p><p>array.add(“word”);</p><p>输出helloword</p><p>变量名.add(数字，元素)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 145857.png)</p><p>将“元素”插到第“数字”位置</p><h2 id="3，ArrayList集合常用方法"><a href="#3，ArrayList集合常用方法" class="headerlink" title="3，ArrayList集合常用方法"></a>3，ArrayList集合常用方法</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 150848.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 150926.png)</p><h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 152733.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 154213.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-10 154131.png)</p><h1 id="十，继承"><a href="#十，继承" class="headerlink" title="十，继承"></a>十，继承</h1><h3 id="1，概述-2"><a href="#1，概述-2" class="headerlink" title="1，概述"></a>1，概述</h3><p>继承是面向对象的3大特征之1，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法。</p><p>继承是指在原有类的基础上，进行功能扩展，创建新的类型。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 102141.png)</p><p> 例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="comment">//public 公共的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">money</span> <span class="operator">=</span> <span class="number">1_0000_0000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;说话&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//student is person</span></span><br><span class="line"><span class="comment">//Teacher student也叫派生类或者子类</span></span><br><span class="line"><span class="comment">//子类可以继承父类的所有方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.say();</span><br><span class="line">        System.out.println(student.money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类继承父类后，测试可直接创建子类对象，调用父类方法</p><p>子类有父类的内容，还可以有自己的内容</p><h4 id="2，继承的优缺点"><a href="#2，继承的优缺点" class="headerlink" title="2，继承的优缺点"></a>2，继承的优缺点</h4><p>继承好处：</p><p>实现了数据和方法的共享<br>提高了代码的复用性(多个类相同的成员可以放到同1个类中)<br>提高了代码的维护性(如果方法的代码需要修改，修改1处即可)<br>提高了代码的可扩展性<br>继承缺点：</p><p>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟看变化，削弱了子类的独立性</p><p>什么时候使用继承？</p><p>假设法：我有两个类A和B，如果他们满足A（B）是B（A）的1种，就说明他们存在继承关系，这个时候就可以考虑使用继承来体现，否则就不能滥用继承</p><p>如：苹果和水果，猫和狗</p><h2 id="3，继承中变量的访问特点"><a href="#3，继承中变量的访问特点" class="headerlink" title="3，继承中变量的访问特点"></a>3，继承中变量的访问特点</h2><p>在子类方法中访问1个变量</p><p>最先在子类局部范围找，如果没有就在子类成员范围找，最后在父类成员范围找，如果都没有就报错(不考虑父亲的父亲…)。</p><p>例如：创建1个父类Fu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class Fu &#123;</span><br><span class="line">public int age = 10;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建1个子类Zi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Zi extends Fu &#123;</span><br><span class="line">public int heigth = 180;</span><br><span class="line">public int age = 20;// 若果没有这句，和下面那句，输入的是10</span><br><span class="line">public void show() &#123;</span><br><span class="line">int age = 30;// 若果没有这句，输入的是20</span><br><span class="line">System.out.println(age);</span><br><span class="line">System.out.println(heigth);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建1个测试类Test</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// 创建对象调用方法</span><br><span class="line">Zi z = new Zi();</span><br><span class="line">z.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：30 80</p><h3 id="4，Super"><a href="#4，Super" class="headerlink" title="4，Super"></a>4，Super</h3><p>super 关键字的用法和 this 关键字的用法相似</p><ul><li>this:代表本类对象的引用（this关键字指向调用该方法的对象1般我们是在当前类中使用this关键字所以我们常说this代表本类对象的引用）</li><li>super:代表父类存储空间的标识(可以理解为父类对象引用)</li></ul><p>1，this.成员变量访问本类成员变量</p><p>this(…)访问本类构造方法</p><p>this.成员方法(…)访问本类成员方法<br>super.成员变量访问父类成员变量</p><p>super(…)访问父类构造方法</p><p>super.成员方法(…)访问父类成员方法</p><p>定义1个父类Fu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Fu &#123;</span><br><span class="line">public int age = 10;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义1个子类Zi</p><p>public class Zi extends Fu {<br>    public int age &#x3D; 20;</p><pre><code>public void show() &#123;    int age = 30;    System.out.println(age); // 30    // 访问本类中的成员变量age    System.out.println(this.age);    // 访问Fu类中的成员变量age    System.out.println(super.age);&#125;</code></pre><p>}<br>测试：Test</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Zi z = new Zi();</span><br><span class="line">z.show();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：30 20 10</p><h3 id="5，继承中构造方法的访问特点"><a href="#5，继承中构造方法的访问特点" class="headerlink" title="5，继承中构造方法的访问特点"></a>5，继承中构造方法的访问特点</h3><p>子类中所有的构造方法默认都会访问父类中无参的构造方法。</p><ol><li>因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，1定要先完成父类数据的初始化</li><li>每1个子类构造方法的第1条语句默认都是: super()</li></ol><p>例如：创建1个父类Fu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Fu &#123;</span><br><span class="line">public Fu() &#123;</span><br><span class="line">System.out.println(&quot;Fu中无参构造方法被调用&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Fu(int age) &#123;</span><br><span class="line">System.out.println(&quot;Fu中带参构造方法被调用&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建1个子类Zi</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Zi extends Fu &#123;</span><br><span class="line">public Zi() &#123;</span><br><span class="line">// super();</span><br><span class="line">System.out.println(&quot;Zi中无参构造方法被调用&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Zi(int age) &#123;</span><br><span class="line">// super();</span><br><span class="line">System.out.println(&quot;Zi中带参构造方法被调用&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：Test</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Zi z = new Zi();</span><br><span class="line">System.out.println(&quot;-------------------&quot;);</span><br><span class="line">Zi zi = new Zi(18);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果父类中没有无参构造方法，只有带参构造方法<br>1.通过super关键字去显示的调用父类的带参构造方法</p><p>2.在父类中自己提供1个无参构造方法</p><h3 id="6，继承中成员方法的访问特点"><a href="#6，继承中成员方法的访问特点" class="headerlink" title="6，继承中成员方法的访问特点"></a>6，继承中成员方法的访问特点</h3><p>通过子类对象访问1个方法：</p><p>先子类成员范围找，如果找不到就在父类成员范围找，如果都没有就报错(不考虑父亲的父亲…)‘</p><p>注意：Java中类只支持单继承，不支持多继承</p><p>Java中类支持多层继承（意思是Java中儿子不能继承妈妈和爸爸，但爸爸可以继承爷爷，进而让儿子继承爸爸</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 161548.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 161631.png)</p><h3 id="7，方法重写"><a href="#7，方法重写" class="headerlink" title="7，方法重写"></a>7，方法重写</h3><p>方法重写概述：子类中出现了和父类中1模1样的方法声明<br>方法重写的应用：当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容</p><p>定义1个手机类Phone</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class Phone &#123;</span><br><span class="line">public void call(String name) &#123;</span><br><span class="line">System.out.println(&quot;给&quot; + name + &quot;打电话&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义1个新手机类NewPhone</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class NewPhone extends Phone &#123;</span><br><span class="line">public void call(String name) &#123;</span><br><span class="line">System.out.println(&quot;开启视频功能&quot;);</span><br><span class="line">// System.out.println(&quot;给&quot; + name + &quot;打电话&quot;);</span><br><span class="line">super.call(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：PersonTest </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class PersonTest &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Phone p = new Phone();</span><br><span class="line">p.call(&quot;张3&quot;);</span><br><span class="line">System.out.println(&quot;--------&quot;);</span><br><span class="line">NewPhone np = new NewPhone();</span><br><span class="line">np.call(&quot;张3&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p>给张3打电话</p><hr><p>开启视频功能</p><p>给张3打电话super.</p><p>注意：</p><p>私有方法不能被重写(父类私有成员子类是不能继承的)</p><p>子类方法访问权限不能更低(public&gt;默认&gt;私有)</p><h1 id="十一，修饰符"><a href="#十一，修饰符" class="headerlink" title="十一，修饰符"></a>十一，修饰符</h1><h3 id="1，包"><a href="#1，包" class="headerlink" title="1，包"></a>1，包</h3><h4 id="1，其实就是文件夹"><a href="#1，其实就是文件夹" class="headerlink" title="1，其实就是文件夹"></a>1，其实就是文件夹</h4><p>作用：对类进行文件管理</p><p>package 包名;(多级包用.分开)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 171949.png)</p><h3 id="2，导包"><a href="#2，导包" class="headerlink" title="2，导包"></a>2，导包</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 172831.png)</p><h3 id="3，修饰符的分类"><a href="#3，修饰符的分类" class="headerlink" title="3，修饰符的分类"></a>3，修饰符的分类</h3><h4 id="1，权限修饰符"><a href="#1，权限修饰符" class="headerlink" title="1，权限修饰符"></a>1，权限修饰符</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 174221.png)</p><h4 id="2-状态修饰符"><a href="#2-状态修饰符" class="headerlink" title="2.状态修饰符"></a>2.状态修饰符</h4><p>final(最终)</p><p><code>final</code>：最终的；<br><code>final</code>用来修饰类、成员变量和方法。</p><ul><li>final类：表示最终的类，该类不允许被继承。</li><li>final变量：表示最终的变量，该变量1经赋值，就不能被修改。</li><li>final方法：表示最终的方法，它能被子类所继承，但是该方法不能被子类所重写。</li></ul><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 175126.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 175137.png)</p><p>修饰局部变量</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 180020.png)</p><p>该final把s的地址变成常量，所以s.age&#x3D;100可变，age只是地址里的变量</p><p>变量是基本类型：final修饰指的是基本类型的数据值不能发生改变</p><p>变量是引用类型：final修饰的是引用类型的地址值不能发生改变，但是地址里面的内容是可以发生改变的</p><p>static:</p><p><strong>.static关键字</strong> </p><p>简单说明：static是静态的意思，可以用来修饰成员方法成员变量。</p><h4 id="static修饰的特点："><a href="#static修饰的特点：" class="headerlink" title=".static修饰的特点："></a>.static修饰的特点：</h4><p>1.被类的所有对象所共享，这也是我们判断是否使用静态关键字的关键。</p><p>2.可以使用类名来调用也可以使用对象名来调用，推荐使用类名调用</p><h4 id="static访问特点："><a href="#static访问特点：" class="headerlink" title=".static访问特点："></a>.static访问特点：</h4><p>非静态成员方法：</p><p>1.能访问静态成员变量</p><p>2.能访问静态成员方法</p><p>3.能访问非静态成员变量</p><p>4.能访问非静态成员方法</p><p>静态成员方法</p><p>1.能访问静态成员变量</p><p>2.能访问静态成员方法</p><h1 id="十二，多态"><a href="#十二，多态" class="headerlink" title="十二，多态"></a>十二，多态</h1><ul><li><p>多态是同1个行为具有不同的表现形式或形态的能力</p></li><li><p>同1方法可以根据发送对象的不同而采用不同的行为方式</p><p><strong>多态就是事物的多种形态，1个对象在不同条件下所表现的不同形式</strong></p><p>举例：猫</p><p>我们可以说猫是猫：猫 cat&#x3D;new 猫（）;</p><p>我们也可以说猫是动物：动物 animal&#x3D;new 猫（）;</p><h3 id="1-格式"><a href="#1-格式" class="headerlink" title="1,格式"></a>1,格式</h3><ul><li><p>父类类型 变量名 &#x3D; new 子类类型（）；</p></li><li><p>然后通过 <strong>变量名.方法名（）</strong>调用在子类中重写的方法</p></li><li><p><strong>\多态体现为父类引用变量可以指向子类对象：\定义了1个父类类型的引用，指向新建的子类类型的对象，由于子类是继承他的父类的，所以父类类型的引用是可以指向子类类型的对象的</strong></p></li><li><h3 id="2，特点"><a href="#2，特点" class="headerlink" title="2，特点"></a>2，特点</h3></li></ul></li></ul><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 200531.png)</p><h6 id="父类"><a href="#父类" class="headerlink" title="&#x2F;&#x2F;父类"></a>&#x2F;&#x2F;父类</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;午餐吃狗粮&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="子类Dog"><a href="#子类Dog" class="headerlink" title="子类Dog:"></a>子类Dog:</h6><p>&#x2F;&#x2F;子类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Dog extends Animal &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void eat() &#123;</span><br><span class="line">    System.out.println(&quot;晚餐吃狗粮&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">//父类类型 对象 = new 子类类型（）</span><br><span class="line">Animal dog = new Dog();</span><br><span class="line"></span><br><span class="line">dog.eat();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台打印输出：调用的是子类中重写的方法</p><p>晚餐吃狗粮</p><h3 id="3，好处与弊端"><a href="#3，好处与弊端" class="headerlink" title="3，好处与弊端"></a>3，好处与弊端</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-11 212052.png)</p><p>左边与右边同名输出的是右边</p><h5 id="左边与右边不1样，假如右边没有左边的方法就无法使用，而左边除重名外无限制而右边的方法必须在左边存在"><a href="#左边与右边不1样，假如右边没有左边的方法就无法使用，而左边除重名外无限制而右边的方法必须在左边存在" class="headerlink" title="左边与右边不1样，假如右边没有左边的方法就无法使用，而左边除重名外无限制而右边的方法必须在左边存在"></a>左边与右边不1样，假如右边没有左边的方法就无法使用，而左边除重名外无限制而右边的方法必须在左边存在</h5><h2 id="4，多态的转型（向上转型：可以使用父类独有，向下转型：可以使用子类独有，但是无论如何转换重名仍然是子类）"><a href="#4，多态的转型（向上转型：可以使用父类独有，向下转型：可以使用子类独有，但是无论如何转换重名仍然是子类）" class="headerlink" title="4，多态的转型（向上转型：可以使用父类独有，向下转型：可以使用子类独有，但是无论如何转换重名仍然是子类）"></a>4，多态的转型（向上转型：可以使用父类独有，向下转型：可以使用子类独有，但是无论如何转换重名仍然是子类）</h2><p>由于子类无法输出父类没有的<br>而且我们在多态情况下调用方法时，首先会检查等式左边的引用类型（父类）中是否有该方法存在，如果父类中没有该方法，则编译器直接报错，也就代表着，父类无法调用子类独有的方法<br>既然编译都出错了，更别说运行了，这也是多态所造成的，因此如果我们想要调用子类的方法，必须做到向下转型</p><h3 id="父类引用指向子类对象-向上转型；"><a href="#父类引用指向子类对象-向上转型；" class="headerlink" title="父类引用指向子类对象&#x2F;向上转型；"></a>父类引用指向子类对象&#x2F;向上转型；</h3><p>Animal dog &#x3D; new Dog（）；</p><p><strong>左边的Animal是引用类型，而dog是由右边的Dog实例对象new出来的，在上面这个等式中，左边的引用Animal指向了子类的对象dog，原本是子类对象的dog完成了向上转型</strong></p><p>Animal父类是大范围的类型，而Cat和Dog类均属于动物类的子类，所以对于子类这种范围小的，我们可以自动转型给父类的变量，儿子向上转型，父亲是唯1的，因此是自动转换</p><p>使用格式：</p><p>父类类型  变量名  &#x3D; new 子类类型（）；</p><p>Animal       dog     &#x3D; new  Dog（）</p><p>通过由实例变量Dog类new出来的变量dog作为中介，使得引用变量Animal有所指向，从而完成了向上转型</p><p>相当于是</p><p>Animal       dog     &#x3D; （Animal) new  Dog（）</p><p>这是系统默认的</p><h3 id="向下转型-父亲变儿子，需要强制转换"><a href="#向下转型-父亲变儿子，需要强制转换" class="headerlink" title="向下转型(父亲变儿子，需要强制转换):"></a>向下转型(父亲变儿子，需要强制转换):</h3><p>向下转型是父类向子类转换的过程，这个过程需要强制转换（父亲变儿子肯定是需要条件的），1个可以将父类对象转换为子类对象，可以使用强制类型转换的格式，这便是向下转型</p><p><strong>对于Dog、Cat这些子类来说，他们只是父类Animal的1部分，而对于父类来说。他拥有更多的子类 牛、羊等</strong>，<strong>所以1旦父类要转换成子类，就必须指定要变成哪个子类，必须有指向性，所以向下转型才是强制转换</strong></p><p>向上转型</p><p>父类类型  变量名  &#x3D; new 子类类型（）；</p><p>Animal       dog     &#x3D; new  Dog（）</p><p>向下转型</p><p>子类类型 子类变量名 &#x3D; （子类类型） 父类变量名</p><p>Dog dog1 &#x3D; (Dog) dog;</p><p>dog1.walk； &#x2F;&#x2F;此时可以使用子类独有的方法了<br>&#x2F;&#x2F;dog1由dog强制转换到Dog形态的变量</p><h1 id="十三，抽象类"><a href="#十三，抽象类" class="headerlink" title="十三，抽象类"></a>十三，抽象类</h1><p>在java中1个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 081848.png)</p><p>animal a&#x3D;new Cat() </p><p><img src="C:\Users\31502\AppData\Roaming\Typora\typora-user-images\image-20240712083731083.png" alt="image-20240712083731083"></p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 192604.png)                                             </p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 192640.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 192650.png)</p><h1 id="十四，接口"><a href="#十四，接口" class="headerlink" title="十四，接口"></a>十四，接口</h1><h3 id="1，概述-3"><a href="#1，概述-3" class="headerlink" title="1，概述"></a>1，概述</h3><p>接口就是1种公共的规范资源，只要符合规范标准，大家都可以通用，Java中的接口更多的体现在对行为的抽象</p><p>接口可以理解为1种特殊的类，里面全部是由<strong>**全局常量*<em><strong>和</strong>公共的抽象方法</em>*所组成。接口是解决</strong>**Java无法使用多继承*<em><strong>的1种手段，但是接口在实际中更多的作用是</strong></em>*制定标准*<em><strong>的。或者我们可以直接把接口理解为</strong></em>*100%的抽象类*<em><strong>，既接口中的方法</strong></em>*必须全部****是抽象方法。（JDK1.8之前可以这样理解）</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 090230.png)</p><h3 id="2，接口的成员特点"><a href="#2，接口的成员特点" class="headerlink" title="2，接口的成员特点"></a>2，接口的成员特点</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 092833.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 191543.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 191435.png)</p><p>​void show（）；</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 191235.png)</p><h3 id="3，类与接口的关系"><a href="#3，类与接口的关系" class="headerlink" title="3，类与接口的关系"></a>3，类与接口的关系</h3><p>1个类可以进行多继承接口，初次之外还可继承1个父类</p><h3 id="4，抽象类与接口的区别"><a href="#4，抽象类与接口的区别" class="headerlink" title="4，抽象类与接口的区别"></a>4，抽象类与接口的区别</h3><ul><li><strong>抽象类</strong>更适合用于定义具有共同属性和行为的类族，可以提供1些通用的实现，同时保持其他方法的抽象性供子类去具体实现。</li><li><strong>接口</strong>则主要用于定义类的行为规范，特别适用于需要多个类共享相同行为的场景，以及实现多重继承的情况</li><li>调用的话都是采用先实例化才调用其中方法</li></ul><h1 id="十五，形参和返回值"><a href="#十五，形参和返回值" class="headerlink" title="十五，形参和返回值"></a>十五，形参和返回值</h1><h4 id="1，类名作为形参和返回值"><a href="#1，类名作为形参和返回值" class="headerlink" title="1，类名作为形参和返回值"></a>1，类名作为形参和返回值</h4><p>方法的形参是类名，其实需要的是该类的对象</p><p>方法的返回值是类名，其实返回的是该类的对象</p><h3 id="2，抽象类名作为形参和返回值"><a href="#2，抽象类名作为形参和返回值" class="headerlink" title="2，抽象类名作为形参和返回值"></a>2，抽象类名作为形参和返回值</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 144955.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 145021.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 145425.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 145455.png)</p><p>方法的形参是抽象类名，其实需要的是该抽象类的子类对象</p><p>方法的返回值是抽象类名，其实返回的是该抽象类的子类对象</p><h3 id="3，接口名作为形参和返回值"><a href="#3，接口名作为形参和返回值" class="headerlink" title="3，接口名作为形参和返回值"></a>3，接口名作为形参和返回值</h3><p>方法的形参是接口名，其实需要的是该接口的实现类对象</p><p>方法的返回值是接口名，其实返回的是该接口的实现类对象</p><h1 id="十六，内部类"><a href="#十六，内部类" class="headerlink" title="十六，内部类"></a>十六，内部类</h1><h3 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1.概述"></a>1.概述</h3><p>内部类：就是在1个类中定义1个类。</p><p>举例在1个类A的内部定义1个类B,类B就被称为内部类</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 160644.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 160654.png)</p><h5 id="class修饰类"><a href="#class修饰类" class="headerlink" title="class修饰类"></a>class修饰类</h5><p>内部类可以直接访问外部类的成员，包括私有</p><p>外部类要访问内不类的成员，必须创建对象</p><p>例子</p><p><img src="C:\Users\31502\AppData\Roaming\Typora\typora-user-images\image-20240712162813436.png" alt="image-20240712162813436"></p><h3 id="2-，成员内部类"><a href="#2-，成员内部类" class="headerlink" title="2.，成员内部类"></a>2.，成员内部类</h3><p>在类的成员位置:成员内部类</p><p>在类的局部位置: 局部内部类</p><p>成员内部类，外界如何创建对象使用呢？</p><p>格式：外部类名.内部类名 对象名&#x3D;外部类对象.内部类对象；</p><p>范例：outer.inner oi &#x3D; new outer().new inner()；</p><p>不针对 private</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 172232.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// final String y = &quot;good&quot;;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="string">&quot;good&quot;</span>;  <span class="comment">// JDK8 以后，final可以省略</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;  <span class="comment">// 定义在外部类的某个方法里</span></span><br><span class="line">        <span class="comment">// static int a = 10; 不能定义静态变量!  </span></span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(age);</span><br><span class="line">            <span class="comment">// 不能修改外部函数的局部变量</span></span><br><span class="line"><span class="comment">// y = &#x27;yes&#x27;;</span></span><br><span class="line">            <span class="comment">// 只能访问被 final 修饰的外部函数的局部变量</span></span><br><span class="line">            <span class="comment">// JDK8 以后，如果外部函数的局部变量没有加 final,编译器会自动加 final</span></span><br><span class="line">            System.out.println(y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    inner.demo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-局部内部类"><a href="#3-局部内部类" class="headerlink" title="3,局部内部类"></a>3,局部内部类</h3><p>局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用，该类可以直接访问外部类的成员，也可以访问方法内的局部变量</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 174225.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 174159.png)</p><h3 id="4，匿名内部类"><a href="#4，匿名内部类" class="headerlink" title="4，匿名内部类"></a>4，匿名内部类</h3><p>前提：存在1个类或者1个接口，这里的类可以使具体类也可以是抽象类</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 174723.png)</p><p>本质是1个<strong>继承了该类</strong>或者实现了该接口的<strong>子类匿名对象</strong></p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 180248.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 081627.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 180259.png)</p><h3 id="5，匿名内部类在开发中的使用"><a href="#5，匿名内部类在开发中的使用" class="headerlink" title="5，匿名内部类在开发中的使用"></a>5，匿名内部类在开发中的使用</h3><h5 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cry</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;这是匿名内部类~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        animal.cry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分界线————————————</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    abstract public void cry();</span><br><span class="line">&#125;//定义1个抽象类包含抽象方法cry</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line">    public void method()&#123;</span><br><span class="line">        Animal animal = new Animal() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void cry() &#123;</span><br><span class="line">                System.out.println(&quot;这是匿名内部类~&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        animal.cry();</span><br><span class="line">    &#125;//继承了Animal的子类对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">        Outer outer = new Outer();</span><br><span class="line">        outer.method();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在接口中是实现接口</p><p>在抽象类中是其子类</p><hr><h1 id="十七，Api"><a href="#十七，Api" class="headerlink" title="十七，Api"></a>十七，Api</h1><h3 id="1-math"><a href="#1-math" class="headerlink" title="1,math"></a>1,math</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 204104.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 204153.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 204410.png)</p><h2 id="2-system"><a href="#2-system" class="headerlink" title="2,system"></a>2,system</h2><p>System包含几个有用的类字段和方法，他不能被实例化</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 210448.png)</p><h3 id="3，object类"><a href="#3，object类" class="headerlink" title="3，object类"></a>3，object类</h3><p>构造方法：public Object()</p><p>回想面向对象中，为什么说子类的构造方法默认访问的是父类的无参构造方法？</p><p>因为他们的顶级父亲只有无参构造方法</p><p>equal方法</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 213128.png)</p><p>![屏幕截图 2024-07-12 213251](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-12 213251.png)</p><h3 id="4，Arrays"><a href="#4，Arrays" class="headerlink" title="4，Arrays"></a>4，Arrays</h3><p>①冒泡排序</p><p>排序：将一组数据按照固定的顺序进行排列</p><p>如果有n个数据进行排序，总共需要比较n-1次</p><p>每一次比较完毕，下一次的比较就会少一个数据参与</p><p>从第一个开始比较将大的放在最后。</p><p>②</p><p>需要导包</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 095050.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 100216.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 100222.png)</p><h3 id="5，基本类型包装类"><a href="#5，基本类型包装类" class="headerlink" title="5，基本类型包装类"></a>5，基本类型包装类</h3><p>将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据</p><p>常用的操作之一：用于基本数据类型与字符串之间的转换</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 104816.png)</p><h4 id="除了char和int都是首字母大写"><a href="#除了char和int都是首字母大写" class="headerlink" title="除了char和int都是首字母大写"></a>除了char和int都是首字母大写</h4><p>①integer</p><p> Integer i1&#x3D;new Integer(“100”)</p><p>sout(i1)</p><p>输出的是100</p><p>②int 和String的相互转换</p><p>用于基本类型和字符串之间的相互转换</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 111542.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 111512.png)</p><p>③字符串数据排序例子</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 151705.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 111512.png)</p><p>⑤自动装箱和拆箱</p><p>装箱：把基本数据类型转换为对应的包装类类型</p><p>拆箱：把包装类类型转换为对应的基本类型</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 171635.png)</p><p>⑥日期类</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 172158.png)</p><p>需要实例化</p><p>Date b&#x3D;new Date()使用</p><p>实例化自动打印当前时期和时间</p><p>b.getData()&#x2F;&#x2F;将时间转换成毫秒数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date now = new Date();</span><br><span class="line">       System.out.println(&quot;当前时间: &quot; + now);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long currentTimeMillis = now.getTime();</span><br><span class="line">       System.out.println(&quot;当前时间的毫秒数: &quot; + currentTimeMillis);</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：1689244245000</span><br></pre></td></tr></table></figure><p>b.setTime(time)&#x2F;&#x2F;将毫秒数转换为时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Date customDate = new Date();</span><br><span class="line">7        </span><br><span class="line">8        // 计算从1970年1月1日到目标日期的毫秒数</span><br><span class="line">9        long targetTimeMillis = 1672531200000L; // 2023年1月1日 00:00:00 的毫秒数</span><br><span class="line">10        </span><br><span class="line">11        // 使用setTime()方法设置时间</span><br><span class="line">12        customDate.setTime(targetTimeMillis);</span><br><span class="line">13        </span><br><span class="line">14        // 输出设置后的时间</span><br><span class="line">15        System.out.println(customDate);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：Sat Jan 01 00:00:00 GMT 2023</span><br></pre></td></tr></table></figure><h4 id="SimpleDataFormat"><a href="#SimpleDataFormat" class="headerlink" title="SimpleDataFormat"></a>SimpleDataFormat</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 175309.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 201157.png)</p><p>⑥calendar </p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 211006.png)</p><p>![屏幕截图 2024-07-13 212600](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 212600.png)</p><p>⑦</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 213149.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-13 214734.png)</p><h1 id="十八-异常"><a href="#十八-异常" class="headerlink" title="十八,异常"></a>十八,异常</h1><h3 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1.概述"></a>1.概述</h3><p>程序出现了不正常的情况</p><p>error：严重问题，不需要处理</p><p>exception:称为异常类，他表示程序本身可以处理的问题</p><p>RuntimeException:在编译器是不检查的，出现问题后，需要我们回来修改代码</p><p>非RuntimeException：编译器就必须处理的，否则程序不能通过编译，就更不能正常运行了</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 081714.png)</p><h3 id="2，jym处理方法"><a href="#2，jym处理方法" class="headerlink" title="2，jym处理方法"></a>2，jym处理方法</h3><p>把异常的名称，异常原因及异常出现的位置等信息输出在了控制台</p><p>程序停止执行</p><h3 id="3-异常处理"><a href="#3-异常处理" class="headerlink" title="3.异常处理"></a>3.异常处理</h3><p>①try…catch…![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 082604.png)</p><p>从  ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 083333.png)</p><p>②Throwable成员方法</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 083501.png)</p><p>输出getMessage&#x3D;printStackTrace</p><h3 id="4-编译时异常和运行时异常区别"><a href="#4-编译时异常和运行时异常区别" class="headerlink" title="4.编译时异常和运行时异常区别"></a>4.编译时异常和运行时异常区别</h3><p>编译时异常：必须显示处理，否则程序就会发生错误，无法通过编译</p><p>运行时异常：无需显示处理，也可以和编译时异常一样处理    </p><h4 id="4，throws处理异常"><a href="#4，throws处理异常" class="headerlink" title="4，throws处理异常"></a>4，throws处理异常</h4><p>throws 异常类是方法上的，不是main函数上的；意为方法上的错误留到main函数上修正</p><p>编译时异常必须要处理：try…catch…或者throws,如果采用throws这种方案，将来谁调用谁处理</p><h3 id="5，自定义异常"><a href="#5，自定义异常" class="headerlink" title="5，自定义异常"></a>5，自定义异常</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 095551.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 095719.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 103243.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 103414.png)</p><h3 id="6-throws和throw的区别"><a href="#6-throws和throw的区别" class="headerlink" title="6.throws和throw的区别"></a>6.throws和throw的区别</h3><p>throws：用在方法声明后面，跟的是异常类名</p><p>​表示抛出异常，由该方法的调用者来处理</p><p>​表示出现异常的一种可能性，并不一定会发生这些异常</p><p>throw: 用在方法体内，跟的是异常对象名</p><p>​表示抛出异常，由方法体内的语句处理</p><p>​执行throw一定抛出了某种异常</p><h1 id="十九，集合进阶"><a href="#十九，集合进阶" class="headerlink" title="十九，集合进阶"></a>十九，集合进阶</h1><h4 id="1-集合类体系结构"><a href="#1-集合类体系结构" class="headerlink" title="1.集合类体系结构"></a>1.集合类体系结构</h4><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 110316.png)</p><h4 id="2，①collection集合概念和使用"><a href="#2，①collection集合概念和使用" class="headerlink" title="2，①collection集合概念和使用"></a>2，①collection集合概念和使用</h4><p>是单例集合的顶层接口，他表示一组对象，这些对象也称为Collection的元素</p><p>JDK不提供此接口的任何直接实现，他提供更具体的子接口（如Set和List）实现</p><h5 id="创建Collection集合的对象："><a href="#创建Collection集合的对象：" class="headerlink" title="创建Collection集合的对象："></a>创建Collection集合的对象：</h5><p>多态的方式</p><p>具体的实现类ArrayList</p><h4 id="②，collection集合常用方法"><a href="#②，collection集合常用方法" class="headerlink" title="②，collection集合常用方法"></a>②，collection集合常用方法</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 142006.png)</p><h4 id="③，collection的遍历"><a href="#③，collection的遍历" class="headerlink" title="③，collection的遍历"></a>③，collection的遍历</h4><p>lterator:迭代器，集合的专用遍历方式 </p><p>lterator<e>iterator():返回此集合中元素的迭代器，通过集合的iterator()方法得到</p><p>迭代器是通过集合的iterator()方法得到的，所以我们说他是依赖于集合而存在的</p><p>lterator中的常用方法</p><p>E.next():f返回迭代中的下一个元素</p><p>boolean hasNext():如果迭代有更多元素，则返回true</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 150508.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 150529.png)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;student&gt; it=a.iterator();//设置一个it迭代器用于遍历a中student元素</span><br></pre></td></tr></table></figure><h5 id="④，集合使用步骤"><a href="#④，集合使用步骤" class="headerlink" title="④，集合使用步骤"></a>④，集合使用步骤</h5><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 151428.png)</p><p>先添加元素，再创建迭代器</p><h4 id="2-list①"><a href="#2-list①" class="headerlink" title="2.list①"></a>2.list①</h4><p>List集合概念</p><p>有序集合（也称为序列），用户可以精准控制列表中每个元素的插入位置。用户可以通过整数索引访问元素，并搜索列表中的元素</p><p>与Set集合不同，列表通常允许重复的元素</p><p>List集合特点</p><p>有序：存储和取出的元素顺序一致</p><p>可重复：存储的元素可以重复</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 163423.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 164543.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 165116.png)</p><p>迭代器方式</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 170126.png)</p><p>for循环方式</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 170207.png)</p><p>②并发修改异常</p><p>ConcurrentModificationException</p><p>产生原因：迭代器遍历过程中，通过集合对象修改了集合元素的长度，造成了迭代器获取元素中判断预期修改值和实际修改值不一致</p><p>解决方案</p><p>用for循环遍历，然后用集合对象做对应的操作即可</p><p>③列表迭代器 </p><p>![《](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 174842.png)</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 192615.png)</p><p>不会像普通迭代器一样产生并发错误，因为他会将实际值赋给预期值</p><h2 id="3，增强for循环"><a href="#3，增强for循环" class="headerlink" title="3，增强for循环"></a>3，增强for循环</h2><p>简化数组和collection集合的遍历</p><p>实现Iterable接口的类允许其对象成为增强型for语句的目标</p><p>它是jdk5之后出现的，其内部原理是一个Iterator迭代器</p><p> 增强for的格式</p><h2 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h2><p>for(元素数据类型 变量名&#x2F;&#x2F;<em>这个数据类型指的是数组&#x2F;集合内部存储的值</em>:数组或者Collection集合){</p><p>要做的循环</p><p>&#x2F;&#x2F;在此使用变量即可，该变量就是元素&#x2F;&#x2F;}</p><p>范例：</p><p>int[] arr&#x3D;{1,2,3,4,5};</p><p>for(int i:arr&#x2F;&#x2F;将arr中元素赋给i){</p><p>System.out.println(i);</p><p>}</p><p>![ ](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 194835.png)</p><p>三种方式遍历集合</p><p>![:](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 195942.png)</p><p>有索引选for</p><h4 id="④，数据结构"><a href="#④，数据结构" class="headerlink" title="④，数据结构"></a>④，数据结构</h4><p>入栈出栈：先进后出</p><p>入队出队：先进先出，后进后出</p><p> 数组：</p><p>数组是一种查询快，增删慢的模型</p><p>查询数据通过索引定位，查询任意数据耗时相同，查询效率高</p><p>删除数据时，要将原始数据删除，同时后面每个数据前移，删除效率低</p><p>添加数据时，添加位置后每个数据后移，再添加元素，添加效率低</p><p>链表：</p><p>链表是一种查询慢，增删快的模型</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 203221.png)</p><p>在数据AC之间添加一个数据B，保存在地址54位置 删除数据BD之间的数据C</p><p>查询必须从头节点开始</p><h3 id="⑤，List集合子类特点"><a href="#⑤，List集合子类特点" class="headerlink" title="⑤，List集合子类特点"></a>⑤，List集合子类特点</h3><p>List集合常用子类：ArrayList,LinkedList</p><p>ArrayList:底层数据结构是数组，查询块，增删慢</p><p>Linklist：底层数据结构是链表，查询慢，增删块</p><h3 id="⑥-LinkedList集合的特有功能"><a href="#⑥-LinkedList集合的特有功能" class="headerlink" title="⑥.LinkedList集合的特有功能"></a>⑥.LinkedList集合的特有功能</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 212357.png)</p><h2 id="4-set集合"><a href="#4-set集合" class="headerlink" title="4.set集合"></a>4.set集合</h2><p>特点：</p><p>不包括重复元素的集合</p><p>没有带索引的方法，所以不能使用普通for循环遍历</p><p>哈希值：是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p><p> Object类中有一个方法可以获取对象的哈希值</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-15 215035.png)</p><h4 id="②HashSet集合概述和特点"><a href="#②HashSet集合概述和特点" class="headerlink" title="②HashSet集合概述和特点"></a>②HashSet集合概述和特点</h4><p>HashSet集合特点</p><p>底层数据结构是哈希表</p><p>对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致</p><p>没有带索引的方法，所以不能使用普通for循环遍历</p><p>由于是Set集合，所以是不包含重复元素的集合</p><h4 id="③哈希表"><a href="#③哈希表" class="headerlink" title="③哈希表"></a>③哈希表</h4><p>底层为数组+链表实现，可以说是一个元素为链表的<strong>数组</strong></p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-16 163814.png)</p><p>由于哈希值的根据地址计算，所以纵使值相同，哈希值也不同需要重写哈希值及hashCode（）和equals()自动生成alt+insert</p><h4 id="④，linkhashset集合概述和特点"><a href="#④，linkhashset集合概述和特点" class="headerlink" title="④，linkhashset集合概述和特点"></a>④，linkhashset集合概述和特点</h4><p>LinkHashSet集合特点</p><p><strong>哈希表和链表实现的Set接口</strong></p><p><strong>哈希表和链表实现的Set接口，具有可预测的迭代次序</strong></p><p><strong>有哈希表保证元素唯一，也就是说没有重复的元素</strong></p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-16 174547.png)</p><h4 id="⑤Treeset集合概述和特点"><a href="#⑤Treeset集合概述和特点" class="headerlink" title="⑤Treeset集合概述和特点"></a>⑤Treeset集合概述和特点</h4><p>TreeSet集合特点</p><p>1,元素有序，这里的顺序不是指存储和取出的顺序,而是按照一定的规则进行排序，具体排序方式取决于构造方法</p><p>2,TreeSet():根据其元素的自然排序进行排序</p><p>3,TreeSet(Comparator comparator):根据指定的比较器进行排序</p><p>4,没有带索引的方法，所以不能使用普通for循环遍历</p><p>5,由于是Set集合，所以不包含重复元素的集合</p><h4 id="⑥，自然排序Comparable的使用（return的是正数把S2放在S1前面，）s2-s1为从大到小，s1-s2为从小到大"><a href="#⑥，自然排序Comparable的使用（return的是正数把S2放在S1前面，）s2-s1为从大到小，s1-s2为从小到大" class="headerlink" title="⑥，自然排序Comparable的使用（return的是正数把S2放在S1前面，）s2-s1为从大到小，s1-s2为从小到大"></a>⑥，自然排序Comparable的使用（return的是正数把S2放在S1前面，）s2-s1为从大到小，s1-s2为从小到大</h4><p>存储学生对象并遍历，创 建TreeSet集合使用无参构造方法</p><p>要求：按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序</p><p>当你尝试向 <code>TreeSet</code> 添加一个新元素时，<code>add()</code> 方法需要确定该元素在树中的适当位置，以保持树的排序性质。为了找到这个位置，<code>TreeSet</code> 需要比较新元素与其他已存在的元素。如果新元素实现了 <code>Comparable</code> 接口，那么 <code>TreeSet</code> 将调用新元素的 <code>compareTo()</code> 方法来与树中现有的元素进行比较。</p><p><code>compareTo()</code> 方法返回一个整数值，指示了新元素相对于现有元素的顺序：</p><ul><li>如果 <code>compareTo()</code> 返回负数，表示新元素小于现有元素，<code>TreeSet</code> 将继续在现有元素的左子树中查找适当位置。</li><li>如果 <code>compareTo()</code> 返回正数，表示新元素大于现有元素，<code>TreeSet</code> 将继续在现有元素的右子树中查找适当位置。</li><li>如果 <code>compareTo()</code> 返回零，表示新元素与现有元素相等（根据 <code>Comparable</code> 接口的自然排序规则），在这种情况下，<code>TreeSet</code> 不会添加重复的元素，因为它只存储唯一的元素。</li></ul><p>总结：1，当你add新数据时会自动安排位置及调用compare to 方法</p><p>​2，用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</p><p>​3，自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(to)方法</p><p>​4，重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;Student&gt; &#123;<span class="comment">//实现接口</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写compareTo</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student s)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return 0;//返回0则认为是同一个元素，不添加</span></span><br><span class="line"><span class="comment">//return 1;//返回正数是升序</span></span><br><span class="line"><span class="comment">//return -1; //返回负数是倒序</span></span><br><span class="line"><span class="comment">// 按照年龄从小到达排序</span></span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span>.age - s.age) == <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#96;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"><span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a小明&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;b小红&quot;</span>, <span class="number">21</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;c小李&quot;</span>, <span class="number">22</span>);</span><br><span class="line"><span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d小蓝&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d小蓝&quot;</span>, <span class="number">10</span>);</span><br><span class="line">ts.add(s1);</span><br><span class="line">ts.add(s2);</span><br><span class="line">ts.add(s3);</span><br><span class="line">ts.add(s4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Student s : ts) &#123;</span><br><span class="line">System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * a小明,10 d小蓝,10 b小红,21 c小李,22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>⑦比较器排序Comparator的使用</p><p>1，用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</p><p>2，比较器排序，就是让集合构造方法接受Compartor的实现类对象，重写compare(To1,To2)方法</p><p>3，重写方法时，一定要注意排序规则必须按照要求的主要条件和次要条件来写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class Student &#123;</span><br><span class="line">private String name;</span><br><span class="line">private int age;</span><br><span class="line"></span><br><span class="line">public Student() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Student(String name, int age) &#123;</span><br><span class="line">super();</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getName() &#123;</span><br><span class="line">return name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setName(String name) &#123;</span><br><span class="line">this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getAge() &#123;</span><br><span class="line">return age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setAge(int age) &#123;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeSetTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">TreeSet&lt;Student&gt; ts = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student s1, Student s2)</span> &#123;</span><br><span class="line"><span class="comment">// this.age - s.age</span></span><br><span class="line"><span class="comment">// s1,s2</span></span><br><span class="line"><span class="keyword">return</span> s1.getAge() - s2.getAge();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">​<span class="type">Student</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;a小明&quot;</span>, <span class="number">10</span>);</span><br><span class="line">​<span class="type">Student</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;b小红&quot;</span>, <span class="number">21</span>);</span><br><span class="line">​<span class="type">Student</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;c小李&quot;</span>, <span class="number">22</span>);</span><br><span class="line">​<span class="type">Student</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d小蓝&quot;</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">​<span class="type">Student</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;d小蓝&quot;</span>, <span class="number">10</span>);</span><br><span class="line">​ts.add(s1);</span><br><span class="line">​ts.add(s2);</span><br><span class="line">​ts.add(s3);</span><br><span class="line">​ts.add(s4);</span><br><span class="line"></span><br><span class="line">​<span class="keyword">for</span> (Student s : ts) &#123;</span><br><span class="line">​System.out.println(s.getName() + <span class="string">&quot;,&quot;</span> + s.getAge());</span><br><span class="line">​&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5，泛型"><a href="#5，泛型" class="headerlink" title="5，泛型"></a>5，泛型</h2><h4 id="①，泛型本质是参数化数据类型"><a href="#①，泛型本质是参数化数据类型" class="headerlink" title="①，泛型本质是参数化数据类型"></a>①，泛型本质是参数化数据类型</h4><p>​参数化类型即将类型由原来的具体的类型参数化，然后在使用&#x2F;调用时传入具体的类型</p><p>可以用在类，方法和接口中，分别被称为泛型类，泛型方法，泛型接口</p><h4 id="②，泛型定义格式："><a href="#②，泛型定义格式：" class="headerlink" title="②，泛型定义格式："></a>②，泛型定义格式：</h4><p>1，&lt;类型&gt;：制定一种类型的格式。这里的类型可以看成是形参</p><p>2，&lt;类型1，类型2…&gt;:指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参,将来具体调用时候给定的类型可以看成是实参，并且实参的类型只能是引用类型</p><p>3，泛型的好处：</p><p>4，把运行时期的问题提前到了编译期间，避免了强制类型转换</p><p>e.g.Collection c &#x3D; new ArrayList();</p><p>​Collection<String> c &#x3D; new ArrayList<String>()</p><p>允许使用参数化的类型，如 List<T>，这里的 T 是类型参数，可以是任何具体的类型。</p><h4 id="③泛型类"><a href="#③泛型类" class="headerlink" title="③泛型类"></a>③泛型类</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 101940.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 102054.png)</p><p>泛型方法的定义格式：</p><p>格式：修饰符&lt;类型&gt;返回值类型 方法名(类型 变量名){}</p><p>范例:public<T>void show(T t){}</p><p>当一个方法的形参不确定的情况下,会使用泛型方法</p><p>泛型方法可以脱离泛型类单独存在</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 102304.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 102331.png)</p><h4 id="④泛型接口"><a href="#④泛型接口" class="headerlink" title="④泛型接口"></a>④泛型接口</h4><p> 格式:修饰符interface接口名&lt;类型&gt;{}</p><p>范例:public interface Generic<T>{}</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 110611.png)</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 110544.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 110743.png)</p><p>⑤类型通配符</p><p>为了表示各种泛型List的父类，可以使用类型通配符</p><h4 id="⑤类型通配符"><a href="#⑤类型通配符" class="headerlink" title="⑤类型通配符&lt;?&gt;"></a>⑤类型通配符&lt;?&gt;</h4><p><strong>当我们为一个类指定泛型并创建对象之后，对象中不仅可以加入泛型所指定的类对象，还可以加入泛型类子类的类对象，这就是数据的继承性。</strong></p><p>List&lt;?&gt;:表示元素类型未知的List，它的元素可以匹配任何的类型</p><p>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</p><p>如果我们说不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p><h4 id="类型通配符上限"><a href="#类型通配符上限" class="headerlink" title="类型通配符上限:&lt;?extends类型&gt;"></a>类型通配符上限:&lt;?extends类型&gt;</h4><p>List&lt;?extends Number&gt;:他表示的类型是Number或者其子类型</p><p>除了可以指定类型通配符的上限，还有下线</p><h4 id="类型通配符下限"><a href="#类型通配符下限" class="headerlink" title="类型通配符下限:&lt;?super类型&gt;"></a>类型通配符下限:&lt;?super类型&gt;</h4><p>List&lt;?super Number&gt;:他表示的类型是Number或者其父类型</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 144025.png)</p><h4 id="⑥可变参数"><a href="#⑥可变参数" class="headerlink" title="⑥可变参数"></a>⑥可变参数</h4><p>  可变参数又称参数个数可变，用作方法的形参出现，那么方法参数个数就是可变的了</p><p>格式：修饰符返回值类型方法名(数据类型…变量名){}</p><p>范例：public static int sum(int…a){}</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 145738.png)</p><p>![屏幕截图 2024-07-17 145743](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 145743.png)</p><p>可变参数注意事项</p><p>这里的变量其实是一个数组</p><p>如果一个方法有多个参数，包含可变参数，可变参数要放在最后</p><p>⑦可变参数的使用</p><p>1，Arrays</p><p>public static<T>List<t><strong>asList</strong>(T…a):返回由指定数组支持的固定大小的列表</p><p>返回的集合不能做增删操作，可以做修改操作</p><p>2，List接口 </p><p>public static<E>List<E>**of(**E…elements):返回包含任意数量元素的不可变列表</p><p>返回的集合不能做增删改操作</p><p>3，set接口</p><p>public static<E>Set<E><strong>of</strong>(E…elements):返回一个包含任意数量元素的不可变集合</p><p>再给元素时，不能给重复的元素</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 152718.png)</p><h3 id="6，map集合"><a href="#6，map集合" class="headerlink" title="6，map集合"></a>6，map集合</h3><h4 id="①-概述"><a href="#①-概述" class="headerlink" title="① 概述"></a>① 概述</h4><p>Interface Map&lt;K,V&gt;  K：键的类型;V:值的类型</p><p>将键映射到值的对象;不能包含重复到键;每个键可以映射到最多的一个值</p><p>举例:学生的学号和姓名</p><p>​itheima001 林青霞</p><p>​itheima002 张曼玉</p><p>​itheima003 王祖贤</p><p>创建Map集合的对象</p><p>多态得方式</p><p>具体的实现类HashMap </p><p>Map&lt;String,String&gt; map&#x3D; new HashMap&lt;String,String&gt;();</p><h4 id="②-Map集合的基本功能"><a href="#②-Map集合的基本功能" class="headerlink" title="② Map集合的基本功能"></a>② Map集合的基本功能</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 160125.png)</p><p>③Map集合的获取功能</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 172349.png)</p><p><img src="C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 173555.png" style="zoom:200%;" />![屏幕截图 2024-07-17 173544](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 173544.png)</p><h4 id="③Map集合的遍历（方式1）"><a href="#③Map集合的遍历（方式1）" class="headerlink" title="③Map集合的遍历（方式1）"></a>③Map集合的遍历（方式1）</h4><p>夫妻对集合</p><p>思路</p><p>把所有的丈夫集中起来</p><p>遍历丈夫的集合，<em>获取到每一个丈夫</em>********</p><p>根据丈夫去找对应的妻子</p><h3 id="转换成map"><a href="#转换成map" class="headerlink" title="转换成map:"></a>转换成map:</h3><p>获取所有键的集合。用keySet()方式实现</p><p>遍历键的集合，获取每一个键。用增强for实现</p><p>根据键去找值。用get(Object key)方式实现&#x2F;&#x2F;<code>map.get(key)</code> 是在 Java 的 <code>Map</code> 接口中定义的一个方法，用于根据提供的键（<code>key</code>）检索与之关联的值</p><p>如果 <code>key</code> 存在于 <code>Map</code> 中，方法将返回与该键关联的值。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 174724.png)</p><h4 id="④Map集合的遍历（方式2）"><a href="#④Map集合的遍历（方式2）" class="headerlink" title="④Map集合的遍历（方式2）"></a>④Map集合的遍历（方式2）</h4><p>思路</p><p>获取所有结婚证的集合</p><p>遍历结婚证的集合，得到每一个结婚证</p><p>根据结婚证获取丈夫和妻子</p><h5 id="转换为Map集合中的操作："><a href="#转换为Map集合中的操作：" class="headerlink" title="转换为Map集合中的操作："></a>转换为Map集合中的操作：</h5><p><em>获取所有键值对对象的集合</em></p><p>Set&lt;Map.Entry&lt;k,y&gt;&gt;entrySet():获取所有键值对对象的集合</p><p><em>遍历键值对对象的集合，得到每一个键值对对象</em></p><p>用增强for实现，得到每一个Map.Entry</p><p><em>根据键值对对象获取键和值</em></p><p>用getKey()得到键</p><p>用getValue()得到值</p><p>![](C:\Users\31502\Desktop\屏幕截图 2024-07-17 180307.png)</p><p><code>getKey()</code> 是 <code>Map.Entry</code> 接口的一个方法，它返回当前键值对中的键。</p><ol><li><strong><code>Map.get(key)</code></strong>:<ul><li>这个方法用于根据给定的键从<code>Map</code>中检索值。如果键存在，它返回与该键关联的值；如果键不存在，它返回<code>null</code>。</li><li>语法：<code>V get(Object key)</code>，其中<code>V</code>是<code>Map</code>中值的类型。</li><li>它用于获取与特定键关联的值。</li></ul></li><li><strong><code>Map.Entry.getKey()</code></strong>:<ul><li>这个方法用于从<code>Map.Entry</code>对象中获取键。<code>Map.Entry</code>是一个接口，表示<code>Map</code>中的一个键值对。</li><li>语法：<code>K getKey()</code>，其中<code>K</code>是<code>Map</code>中键的类型。</li><li>它用于获取<code>Map.Entry</code>对象中的键。</li></ul></li></ol><h4 id="⑤，嵌套遍历"><a href="#⑤，嵌套遍历" class="headerlink" title="⑤，嵌套遍历"></a>⑤，嵌套遍历</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 201032.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 201019.png)</p><p>_______________________——-</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-17 203510.png)</p><h2 id="7-Collections概念和使用（导包）"><a href="#7-Collections概念和使用（导包）" class="headerlink" title="7,Collections概念和使用（导包）"></a>7,Collections概念和使用（导包）</h2><p>Collections类的概述</p><p>是针对集合操作的工具类</p><p>Collections类的常用方法</p><p>public static&lt;T extends Comparable&lt;?super T&gt;&gt;void <strong>sort</strong>(List<T>list):将指定的列表按升序排列</p><p>public static void <strong>reverse</strong>(List&lt;?&gt;list):反转指定列表中元素的顺序</p><p>public static void <strong>shuffle</strong>(List&lt;?&gt;list):使用默认的随机源排列指定的列表</p><p>由于是静态方法可直接调用不需要实例化</p><p>看一下comepareto</p><h1 id="二十，io流"><a href="#二十，io流" class="headerlink" title="二十，io流"></a>二十，io流</h1><h2 id="1-file（需要导包）：它是文件和目录路径名的抽象表示"><a href="#1-file（需要导包）：它是文件和目录路径名的抽象表示" class="headerlink" title="1,file（需要导包）：它是文件和目录路径名的抽象表示"></a>1,file（需要导包）：它是文件和目录路径名的抽象表示</h2><p>文件和目录是可以通过File封装成对象的</p><p>对于File而言，其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。他可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转换为具体存在的</p><h5 id="①构造方法"><a href="#①构造方法" class="headerlink" title="①构造方法"></a>①构造方法</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 101244.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 101959.png)</p><p>是创建实例不是创建File</p><h5 id="②File类创建功能"><a href="#②File类创建功能" class="headerlink" title="②File类创建功能"></a>②File类创建功能</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 102225.png)</p><p>目录&#x2F;存在返回false，不存在创建并返回true; </p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 104046.png)</p><h5 id="③file类判断和获取功能"><a href="#③file类判断和获取功能" class="headerlink" title="③file类判断和获取功能"></a>③file类判断和获取功能</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 104236.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 110211.png)</p><h5 id="④File类删除功能"><a href="#④File类删除功能" class="headerlink" title="④File类删除功能"></a>④File类删除功能</h5><p>public boolen delete()</p><p>删除由此抽象路径名表示的文件或目录</p><p>绝对路径:完整的路径名，不需要任何其他信息就可以定位它表示的文件</p><p>相对路径：必须使用取自其他路径名的信息进行解释。例如myFile\java.txt</p><p>删除目录注意事项</p><p>如果一个目录中有内容，就不能直接删除，必须先删除其中内容</p><h5 id="⑤递归"><a href="#⑤递归" class="headerlink" title="⑤递归"></a>⑤递归</h5><p>以编程的角度来看，递归是指方法定义中调用方法本身的现象</p><p><strong>思路</strong>:</p><p>把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解</p><p>递归策略只需少量程序就可以描述出解题过程所需要的多次重复计算</p><h5 id="递归解决问题要找到两个内容"><a href="#递归解决问题要找到两个内容" class="headerlink" title="递归解决问题要找到两个内容:"></a>递归解决问题要找到两个内容:</h5><p>递归出口:否则会出现内存溢出</p><p>递归规则:与原问题相似的规模较小的问题</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 143735.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 143746.png)</p><p>递归阶乘</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 150646.png)</p><h2 id="2，字节流"><a href="#2，字节流" class="headerlink" title="2，字节流"></a>2，字节流</h2><h4 id="①io流概述："><a href="#①io流概述：" class="headerlink" title="①io流概述："></a>①io流概述：</h4><p>文件输出流（FileOutputStream）是Java中用于向文件写入字节流的一种方式。</p><p>IO:输入&#x2F;输出(Input&#x2F;Output)</p><p>流：是一种抽象概念，是对数据运输的总称。也就是说数据在设备间的运输成为流，流的本质是数据运输</p><p>io流就是用来处理设备间数据运输问题的</p><p>常见的应用:文件复制；文件上传;文件下载</p><p>输入：读数据，输出：写数据</p><p><strong>根据数据类型来分：</strong></p><p><em><strong>字节流：</strong></em></p><p><em><strong>字节输入流;字节输出流</strong></em></p><p><em><strong>字符流：</strong></em></p><p><em><strong>字符输入流;字符输出流</strong></em></p><p><strong>注：如果数据通过Window自带的记事本软件打开，我们还可以读懂里面的内容，就使用字符流，否则使用字节流</strong></p><p>  <strong>②写数据</strong></p><p><strong>字节流抽象基类</strong></p><p><strong>InputStream:这个抽象类是表示字节输出流的所有类的超类</strong></p><p><strong>OutputStream:这个抽象类是表示字节输出流的所有类的超类</strong></p><p><strong>子类名特点:子类名称都是以其父类名作为子类名的后缀</strong></p><p><strong>FileOutStream:文件输出流用于将数据写入File</strong></p><p><strong>FileOutputStream(String name):创建文件输出流以指定的名称写入文件</strong></p><p><strong>使用字节输出流写数据的步骤：</strong></p><p><strong>创建字节输出流对象(调用系统功能创建了文件，创建字节输出流对象，R让字节输出流对象指向文件)</strong></p><p><strong>调用字节输出流对象的写数据方法</strong></p><p><strong>释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)</strong></p><h3 id="③字节流写数据的3种方式"><a href="#③字节流写数据的3种方式" class="headerlink" title="③字节流写数据的3种方式"></a>③字节流写数据的3种方式</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 162117.png)</p><p><code>FileOutputStream()</code> 括号内的参数是指定目标文件的信息，不是要输出的具体内容 </p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 172113.png)</p><h4 id="④换行和追加写入"><a href="#④换行和追加写入" class="headerlink" title="④换行和追加写入"></a>④换行和追加写入</h4><p><strong>换行写完数据化，加换行符</strong></p><p>windows:\r\n</p><p>linux:\n</p><p>mac:\r</p><p>![](C:\Users\31502\Desktop\屏幕截图 2024-07-18 175743.png)</p><p><strong>追加写入：</strong></p><p>publicFileOutStream(String name,boolean append)</p><p>创建文件输出流以指定的名称写入文件。如果第二个参数为true,则字节将写入文件的末尾而不是开头</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 175743.png)</p><h4 id="⑤字节流写数据加异常处理（kan"><a href="#⑤字节流写数据加异常处理（kan" class="headerlink" title="⑤字节流写数据加异常处理（kan)"></a>⑤字节流写数据加异常处理（kan)</h4><p>finally:在异常处理时提供finally块来执行所有清除操作。比如说IO流中的释放资源</p><p>特点:被finally控制的语句一定会执行，除非JYM退出</p><p>try{</p><p>}catch(异常类名 变量名){</p><p>异常 的处理代码;</p><p>}finally{</p><p>执行所有清除操作；</p><p>}</p><h4 id="①字节流读数据-一次读一个字节数据"><a href="#①字节流读数据-一次读一个字节数据" class="headerlink" title="①字节流读数据(一次读一个字节数据)"></a>①字节流读数据(一次读一个字节数据)</h4><p>FileInputStream是用来读文件数据的流，所以它需要一个文件对象用来实例化，这个文件可以是一个File对象,也可以是文件名路径字符串.【这里文件不存在会抛错】</p><p>FilelnputStream:从文件系统中的文件获取输入字节</p><p>需求:把文件fos.txt中的内容读取出来再控制台输出</p><p>FilelnputStream(String name):通过打开与实际文件的连接来创建一个FilelnputStream，该文件由文件系统中的路径名name命名</p><p>使用字节输入流读数据的步骤:</p><p>①创建字节输入流对象&#x2F;&#x2F;FileInputStream(String name)</p><p>②调用字节输入流对象的读数据方法&#x2F;&#x2F;int read():从该输入流读取一个字节的数据</p><p>③释放资源   ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 201034.png)</p><h5 id="注意：在Java中，InputStream-的-read-方法每次调用时，都会尝试从输入流中读取下一个字节。这意味着，如果你连续调用两次-read-方法（假设输入流中有足够的数据），第一次调用会读取流中的第一个字节，而第二次调用会读取紧随其后的第二个字节。"><a href="#注意：在Java中，InputStream-的-read-方法每次调用时，都会尝试从输入流中读取下一个字节。这意味着，如果你连续调用两次-read-方法（假设输入流中有足够的数据），第一次调用会读取流中的第一个字节，而第二次调用会读取紧随其后的第二个字节。" class="headerlink" title="注意：在Java中，InputStream 的 read() 方法每次调用时，都会尝试从输入流中读取下一个字节。这意味着，如果你连续调用两次 read() 方法（假设输入流中有足够的数据），第一次调用会读取流中的第一个字节，而第二次调用会读取紧随其后的第二个字节。"></a>注意：在Java中，<code>InputStream</code> 的 <code>read()</code> 方法每次调用时，都会尝试从输入流中读取下一个字节。这意味着，如果你连续调用两次 <code>read()</code> 方法（假设输入流中有足够的数据），第一次调用会读取流中的第一个字节，而第二次调用会读取紧随其后的第二个字节。</h5><h5 id="read-从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据"><a href="#read-从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据" class="headerlink" title="read():从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据"></a>read():从流中读取1个字节的数据，返回结果是一个int，（如果编码是以一个字节一个字符的，可以尝试转成char，用来查看数据</h5><h5 id="read-byte-b-：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）"><a href="#read-byte-b-：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）" class="headerlink" title="read(byte[] b)：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）"></a>read(byte[] b)：从流中读取b的长度个字节的数据存储到b中，返回结果是读取的字节个数（当再次读时，如果返回-1说明到了结尾，没有了数据）</h5><p>②复制文本文件</p><p>FileInputStream fis &#x3D; new FileInputStream(name)&#x2F;&#x2F;输出流对象</p><p>FileOutputStream fos&#x3D; new FileOutputStream(name)&#x2F;&#x2F;输入流对象</p><h4 id="②字节流读取数据（一次读一个字节数组数据"><a href="#②字节流读取数据（一次读一个字节数组数据" class="headerlink" title="②字节流读取数据（一次读一个字节数组数据)"></a>②字节流读取数据（一次读一个字节数组数据)</h4><p>需求:把文件fos.txt中的内容读取出来在控制台输出</p><p>使用字节输入流读数据的步骤:</p><p>① 创建字节输入流对象</p><p>②调用字节输入流对象的读数据方法</p><p>③释放资源</p><h3 id="注意-read（byte）读取的是所读字节的长度"><a href="#注意-read（byte）读取的是所读字节的长度" class="headerlink" title="注意:read（byte）读取的是所读字节的长度"></a>注意:read（byte）读取的是所读字节的长度</h3><p>byte[] bu &#x3D; new byte[6];</p><p> fis.read(bu)</p><h5 id="将读取的字节存到bu里面"><a href="#将读取的字节存到bu里面" class="headerlink" title="将读取的字节存到bu里面"></a>将读取的字节存到bu里面</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 204634.png)</p><h4 id="③复制图片"><a href="#③复制图片" class="headerlink" title="③复制图片"></a>③复制图片</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 205215.png)</p><h4 id="①字节缓冲流"><a href="#①字节缓冲流" class="headerlink" title="①字节缓冲流"></a>①字节缓冲流</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 210211.png)</p><p>读数据</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 212701.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 212708.png)</p><p>写数据</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 212822.png)</p><p>案例（复制）视频</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213815.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213828.png)</p><p>![屏幕截图 2024-07-18 213851](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213851.png)</p><p>![屏幕截图 2024-07-18 213922](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213922.png)</p><p>!(C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-18 213940.png)</p><h2 id="3，字符流"><a href="#3，字符流" class="headerlink" title="3，字符流"></a>3，字符流</h2><p>存在原因:</p><p><code>FileInputStream</code> 本身只能读取字节流，不关心字符编码。当你使用 <code>FileInputStream</code> 读取文件时，它会逐个读取文件中的字节，并将每个字节转换为字符。如果文件中的字节表示的是 ASCII 字母，那么每个字节恰好是一个字符，所以你可以看到字母被正确地打印出来。</p><p>然而，如果你的文件包含汉字，情况就会变得复杂。因为汉字可能占用多个字节，而 <code>FileInputStream</code> 没有考虑到这一点，所以它不能正确地解码汉字。这就是为什么你不能用 <code>FileInputStream</code> 直接读取汉字的原因</p><p>汉字编码第一个都是负数</p><p>由于字节流操作中文不是特别的方便，所以java就提供字符流</p><p>字符流&#x3D;字节流+编码表</p><p>用字节流复制文本文件时，文本文件也会有中文，但是没有问题原因是最终底层操作会自动进行字节拼接成中文，汉字编码第一个都是负数，这个特点用于编码存储</p><h4 id="①编码表"><a href="#①编码表" class="headerlink" title="①编码表"></a>①编码表</h4><p>计算机中储存的信息都是用二进制数表示的:我们看到的字符都是二进制数转换之后的结果</p><p>按照规则将字符存储到计算机中称为编码，反之，解析二进制数出来称为解码，</p><h5 id="注-按照A编码表存储，必须按照A编码解析，否则出现乱码现象"><a href="#注-按照A编码表存储，必须按照A编码解析，否则出现乱码现象" class="headerlink" title="注:按照A编码表存储，必须按照A编码解析，否则出现乱码现象"></a>注:按照A编码表存储，必须按照A编码解析，否则出现乱码现象</h5><p>字符编码:就是一套自然语言的字符与二进制数之间的对应规则（A,650</p><p>字符集:</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 074717.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 075539.png)</p><h4 id="②编码解码问题"><a href="#②编码解码问题" class="headerlink" title="②编码解码问题"></a>②编码解码问题</h4><p>编码</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 080402.png)</p><p>![屏幕截图 2024-07-19 080407](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 080407.png)</p><p>![屏幕截图 2024-07-19 080412](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 080412.png)</p><p>解码</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 080510.png)</p><p>字符流抽象基类</p><p>Reader:字符输入流的抽象类</p><p>Writer:字符输出流的抽象类</p><p>字符流中和编码解码为问题相关的两个类:</p><p>InputStreamReader</p><p>OutputStreamWriter</p><p>输出:</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 082516.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 083302.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 083357.png)</p><p>输入:</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 083505.png)</p><h4 id="③字符流写数据的⑤种方式"><a href="#③字符流写数据的⑤种方式" class="headerlink" title="③字符流写数据的⑤种方式"></a>③字符流写数据的⑤种方式</h4><p>![](C:\Users\31502\Desktop\屏幕截图 2024-07-19 084526.png)</p><p>由于字节是数字，所以接受的是int类型</p><h3 id="注-写入的字符实际是由c转换成字符的"><a href="#注-写入的字符实际是由c转换成字符的" class="headerlink" title="注:写入的字符实际是由c转换成字符的"></a>注:写入的字符实际是由c转换成字符的</h3><p><code>OutputStreamWriter</code> 接收 <code>FileOutputStream</code> 因为它是用来将字符数据写入文件的。<code>FileOutputStream</code> 提供了将字节写入文件的功能，而 <code>OutputStreamWriter</code> 则提供了将字符数据转换为字节的功能。通过将两者结合在一起，你可以方便地将字符数据写入文件。</p><p>具体来说，<code>OutputStreamWriter</code> 使用 <code>OutputStream</code> 实现底层的字节写入功能，同时根据指定的字符集将字符数据转换为字节。这样，你可以使用 <code>OutputStreamWriter</code> 写入任意字符数据，而不需要担心如何将字符转换为字节的问题。</p><hr><p><code>OutputStreamWriter</code> 类继承自 <code>Writer</code> 类，<code>Writer</code> 类提供了一些基本的写入字符的方法，例如 <code>write(char)</code>、<code>write(String)</code> 和 <code>write(char[], int, int)</code>。这些方法允许你直接写入字符数据，而无需手动将字符转换为字节。</p><p>当你调用这些方法时，<code>OutputStreamWriter</code> 自动将字符转换为字节，并使用指定的字符集将字节写入底层的 <code>OutputStream</code>。这样，你就不必自己处理字符与字节之间的转换，简化了编程过程。</p><p>close()先刷新再关闭流 </p><p>flush()刷新流，还可以继续写数据</p><h4 id="④字符流读数据的2种方式"><a href="#④字符流读数据的2种方式" class="headerlink" title="④字符流读数据的2种方式"></a>④字符流读数据的2种方式</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 094215.png)</p><p><code>read(char[] cbuf)</code> 方法是 <code>Reader</code> 类的一个方法，用于从输入流中读取字符数据。它将读取的字符存储在 <code>cbuf</code> 数组中，并返回实际读取的字符数。如果到达流的末尾，返回 <code>-1</code>。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 095342.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 102544.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 103345.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 103419.png)</p><h3 id="⑤字符缓冲流"><a href="#⑤字符缓冲流" class="headerlink" title="⑤字符缓冲流"></a>⑤字符缓冲流</h3><p>BufferedWritter:将文本写入字符输出流，缓冲字符，已提供单个字符，数组和字符串的高效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</p><p>BufferedReader:从字符输入流读取文本，缓冲字符，已提供字符,数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途</p><p>构造方法:</p><p>BufferedWriter(Writer out)</p><p>BufferedReader(Reader in)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 110516.png)</p><p>字节缓冲流复制文件案例</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 111929.png)</p><p>字符缓冲流特有功能</p><p>BufferedWriter:</p><p>void newLine():写一行行分隔符，行分隔符字符串由系统属性定义(换行)</p><p>BufferedReader:</p><p>public String readLine():读一行文字，不读换行符号，返回那一行文字，用String类型接受。结果包含行的内容的字符串，不包含任何行终止字符（不能换行），如果流的结尾已经到达，则为null</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 142154.png)</p><h3 id="io流小结"><a href="#io流小结" class="headerlink" title="io流小结"></a>io流小结</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 142510.png)</p><p>![屏幕截图 2024-07-19 142537](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 142537.png)</p><p>q：为什么</p><p>FileInputStream的read方法在做类型提升（将byte提升为int）</p><p>FileOutputStream的write的方法在做类型强转(将int强转为byte)</p><p>java 字节读取流的read方法一次读一个byte但返回int的原因</p><p>读取二进制数据按字节读取，每次读一个字节（byte）。</p><p>read()的底层是由C++实现的，返回的是unsigned byte，取值范围为[0~255]，在java中没有对应的类型，所以只能用int类型接收，由Java接收得到的就是int[0、255]。</p><h4 id="字符流存在原因"><a href="#字符流存在原因" class="headerlink" title="字符流存在原因"></a>字符流存在原因</h4><p>存在原因:</p><p><code>FileInputStream</code> 本身只能读取字节流，不关心字符编码。当你使用 <code>FileInputStream</code> 读取文件时，它会逐个读取文件中的字节，并将每个字节转换为字符。如果文件中的字节表示的是 ASCII 字母，那么每个字节恰好是一个字符，所以你可以看到字母被正确地打印出来。</p><p>然而，如果你的文件包含汉字，情况就会变得复杂。因为汉字可能占用多个字节，而 <code>FileInputStream</code> 没有考虑到这一点，所以它不能正确地解码汉字。这就是为什么你不能用 <code>FileInputStream</code> 直接读取汉字的原因</p><h5 id="write-read与write-read-byte-b-的区别："><a href="#write-read与write-read-byte-b-的区别：" class="headerlink" title="write&#x2F;read与write&#x2F;read(byte[] b)的区别："></a>write&#x2F;read与write&#x2F;read(byte[] b)的区别：</h5><p>write(byte[] b)<code> 方法直接接受一个字节数组作为参数，数组中的每个元素就是一个字节 (</code>byte<code>)，不需要额外将其转换为 </code>int</p><h2 id="308"><a href="#308" class="headerlink" title="308"></a>308</h2><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>1.复制单级文件夹</p><p>![屏幕截图 2024-07-19 174457](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 174457.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 174531.png)</p><p>2.复制多级文件夹</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 191155.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 191332.png)</p><p>3，复制文件的基本处理</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 192440.png)</p><h2 id="4，特殊操作流"><a href="#4，特殊操作流" class="headerlink" title="4，特殊操作流"></a>4，特殊操作流</h2><h4 id="①标准输入输出流"><a href="#①标准输入输出流" class="headerlink" title="①标准输入输出流"></a>①标准输入输出流</h4><p>System类中有两个静态的成员变量:</p><p>public static final InputStream in:标准输入流。通常该流对应于键盘输入或由主句环境光国用户指定的另一个输入源</p><p>public static final PringStream out:标准输出流。通常该流对应于键盘输入或由主句环境光国用户指定的另一个输出目标</p><p>自己实现键盘录入数据:</p><p>BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(System.in));</p><p>写起来太麻烦，java就提供了一个类实现键盘录入</p><p>Scanner sc &#x3D; new Scanner(System,in);</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 195356.png)</p><p>输出</p><p>输出语句的本质:是一个标准的输出流</p><p>PrintStream ps&#x3D;System.out;</p><p>System.out.print()&#x2F;&#x2F;括号必须有数值</p><p>System.out.println()&#x2F;&#x2F;括号不一定有数值</p><p>PrintStream类有的方法，System.out都可以使用</p><h4 id="②打印流"><a href="#②打印流" class="headerlink" title="②打印流"></a>②打印流</h4><p>打印流分类:</p><p>字节打印流:PrintStream</p><p>字符打印流:PrintWriter</p><p>打印流的特点:</p><p>只负责输出数据，不负责读取数据</p><p>有自己的特有方法</p><p>字节打印流</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 202112.png)</p><p>PrintStream(String fileName):使用指定的文件名创建新的打印流</p><p>使用继承父类的方法写数据&#x2F;&#x2F;指write（），查看的时候会转码;使用自己的特有方法写数据&#x2F;&#x2F;print&#x2F;println()，查看的数据原样输出</p><p>字符打印流 </p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 202512.png)</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 203411.png)</p><h3 id="③对象序列化流"><a href="#③对象序列化流" class="headerlink" title="③对象序列化流"></a>③对象序列化流</h3><p>对象序列化流:ObjectOutputStream</p><p>将Java对象的原始数据类型和图形写入OutputStream.可以使用ObjectlnputStream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以在另一个主机或另一个进程中重构对象</p><p>构造方法:ObjectOutputStream(OutputStream out):创建一个写入指定的OutputStream的ObjectOutputStream</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 211715.png)</p><p>eg</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 211807.png)</p><p>④对象反序列化流:ObjectlnputStream</p><p>ObjectlnputStream反序列化先前使用ObjectOutputStream编写的原始数据和对象</p><p>构造方法:</p><p>ObjectlnputStream(lnputStream in):创建从指定的lnputStream读取的ObjectputStream</p><p>反序列化对象的方法:</p><p>Object readObject():从ObjectlnputStream读取一个对象</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 213707.png)</p><p>注意:Object obj &#x3D; ois.readObject(),是将已经反实例化的对象变成 Object类</p><p>而Student s &#x3D; (Student) obj,是将Object类强转为Student类</p><h5 id="⑤三个问题"><a href="#⑤三个问题" class="headerlink" title="⑤三个问题"></a>⑤三个问题</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 215931.png)</p><p>例子</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-19 220009.png)</p><h4 id="⑥properties"><a href="#⑥properties" class="headerlink" title="⑥properties"></a>⑥properties</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 090521.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 091135.png)</p><p>Propertier和io流结合的方法:</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 091258.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 092548.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 092718.png)</p><p>​         案例:游戏次数</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 095050.png)</p><h1 id="二十一，多线程"><a href="#二十一，多线程" class="headerlink" title="二十一，多线程"></a>二十一，多线程</h1><h2 id="1，实现多线程"><a href="#1，实现多线程" class="headerlink" title="1，实现多线程"></a>1，实现多线程</h2><h3 id="①线程"><a href="#①线程" class="headerlink" title="①线程"></a>①线程</h3><p>线程:是进程中的单个顺序控制流，是一条执行路径</p><p>单线程:是一个进程如果只有一条执行路径，则称为单线程程序，如main方法</p><p>多线程:一个进程如果有多条执行路径，则称为多线程程序</p><p>假设你有一个计算密集型的任务，可以有两种处理方式：</p><ul><li><strong>调用方法</strong>：你可以写一个方法，然后在主线程中调用它。这将导致主线程在该方法执行期间阻塞，无法执行其他任务。</li><li><strong>启动线程</strong>：相反，你可以将这个任务封装在一个实现了 <code>Runnable</code> 接口的类中，并创建一个线程来执行这个类的 <code>run</code> 方法。这样，主线程可以继续执行其他任务，而计算密集型的任务在另一个线程中独立完成。</li></ul><p>举例：</p><p>记事本程序</p><p>扫雷程序</p><h3 id="②多线程的实现方式"><a href="#②多线程的实现方式" class="headerlink" title="②多线程的实现方式"></a>②多线程的实现方式</h3><p>方式1:继承Thread类</p><p>定义一个类MyThread继承Thread类</p><p>在MyThread类中重写run()方法</p><p>创建MyThread类的对象</p><p>启动线程</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 102317.png)</p><p>![屏幕截图 2024-07-20 102323](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 102323.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 102404.png)</p><p>两个小问题:</p><p>为什么要重写run()方法?</p><p>​因为run()是用来封装被线程执行的代码</p><p>run()方法和start()方法的区别 ?</p><p>​run():封装线程执行的代码，直接调用，相当于普通方法的调用</p><p>​start():启动线程；然后由JYM调用此线程的run()方法 （有了start()之后就不用run()方法）</p><h3 id="③设置和获取线程名称的方法"><a href="#③设置和获取线程名称的方法" class="headerlink" title="③设置和获取线程名称的方法"></a>③设置和获取线程名称的方法</h3><p>Thread类设置和获取线程名称的方法</p><p>void setName(String name):将此线程的名称更改为等于参数name</p><p>String getName():返回此线程的名称</p><p>通过构造方法也可以设置线程名称</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 105533.png)</p><p>![屏幕截图 2024-07-20 105552](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 105552.png)</p><p>如何获取main()方法所在的线程名称?</p><p>public static Thread currentThread():返回对当前执行的线程对象的引用</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 105849.png)</p><h3 id="④线程调度"><a href="#④线程调度" class="headerlink" title="④线程调度"></a>④线程调度</h3><p>线程有两种调度模型</p><p>分时调度模型:所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</p><p>抢占式调度模型:优先让优先权高的线程使用CPU,如果线程的优先级相同，那么会随机选择一个获取Cpu时间片相对多一些</p><p>Java使用的是抢占式调度模型</p><p>假如计算机只有一个CPU，那么CPU在某一时刻只能执行一条指令，线程只有得到Cpu时间片，也就是使用权，才可以执行指令，所以说多线程程序的执行是有随机性，抢到CPU的使用权的对象不一定</p><p>Thread类中设置和获取线程优先级的方法</p><h5 id="public-final-int-getPriority-返回此线程的优先级"><a href="#public-final-int-getPriority-返回此线程的优先级" class="headerlink" title="public final int getPriority():返回此线程的优先级"></a>public final int getPriority():返回此线程的优先级</h5><h5 id="public-final-void-setPriority-int-newPriority-更改此线程的优先级"><a href="#public-final-void-setPriority-int-newPriority-更改此线程的优先级" class="headerlink" title="public final void setPriority(int newPriority):更改此线程的优先级"></a>public final void setPriority(int newPriority):更改此线程的优先级</h5><p>优先级最低为1，默认为5，最高为10</p><p>线程优先级高仅仅表示线程获取CPU的时间片的几率高，但是要在次数比较多，或者多次运行时才能看到你的效果</p><h3 id="⑤线程控制"><a href="#⑤线程控制" class="headerlink" title="⑤线程控制"></a>⑤线程控制</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 112021.png)</p><p> 用于方法类而非main方法</p><p>join</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113426.png)</p><p>![屏幕截图 2024-07-20 113502](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113502.png)</p><p>setDa</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113549.png)</p><p>![屏幕截图 2024-07-20 113619](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113619.png)</p><h3 id="⑥线程生命周期"><a href="#⑥线程生命周期" class="headerlink" title="⑥线程生命周期"></a>⑥线程生命周期</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 113902.png)</p><h3 id="⑦多线程的实现方式"><a href="#⑦多线程的实现方式" class="headerlink" title="⑦多线程的实现方式"></a>⑦多线程的实现方式</h3><p>方式2:实现Runnable接口</p><p>启动线程</p><p>多线程的实现方案：</p><p>继承Thread类</p><p>实现Runnable接口</p><p>相比继承Thread类，实现Runnablle接口的好处</p><p>避免了Java单继承的局限性</p><p>适合多个相同程序的代码1去处理同一个资源的情况，把线程和程序的代码，数据有效分离，较好的体现了面向对象的设计思想</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 143611.png)</p><p>![屏幕截图 2024-07-20 143632](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 143632.png)</p><h2 id="2，线程同步"><a href="#2，线程同步" class="headerlink" title="2，线程同步"></a>2，线程同步</h2><h3 id="①为什么会出现线程同步"><a href="#①为什么会出现线程同步" class="headerlink" title="①为什么会出现线程同步"></a>①为什么会出现线程同步</h3><p>当、有多线程环境、有共享数据、有多条语句操作共享数据、同时存在时会出现数据安全问题</p><p>解决:</p><p>基本思想:让程序没有安全问题的环境</p><p>方法:1,把多条语句操作共享数据的代码给锁起来，让任意时刻只能有一个线程执行即可</p><p>​2,Java提供了同步代码块的方式来解决</p><h3 id="②同步代码块"><a href="#②同步代码块" class="headerlink" title="②同步代码块"></a>②同步代码块</h3><p>锁多条语句操作共享数据，可以使用同步代码块实现</p><p><code>synchronized</code> 是Java中用于实现线程同步的关键字，主要用于解决多线程环境中对共享资源的并发访问问题。它可以确保在同一时刻，只有一个线程能够执行特定的代码段或访问特定的对象</p><p><code>synchronized</code> 块或方法在进入时会自动获取锁，并在正常退出或抛出异常时自动释放锁</p><p>格式:</p><p>synchronized(任意对象){</p><p>​多条语句操作共享数据的代码</p><p>​}</p><p>synchronized(任意对象):就相当于给代码枷锁了，任意对象就可以看成一把锁</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 154003.png)</p><p>![屏幕截图 2024-07-20 154012](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 154012.png)</p><h3 id="③同步方法"><a href="#③同步方法" class="headerlink" title="③同步方法"></a>③同步方法</h3><p>同步方法:就是把Synchronized关键字加到方法上</p><p>格式:</p><p>修饰符Synchronized返回值类型 方法名(方法参数){}</p><p>同步方法的锁对象是什么呢？</p><p>this</p><p>同步静态方法:就是把synchronized关键字加到静态方法上</p><p>格式:</p><p>修饰符:static synchronized返回值类型 方法名(方法参数){}</p><p>同步静态方法的锁对象是什么呢？</p><p>类名.class</p><h3 id="④线程安全的类"><a href="#④线程安全的类" class="headerlink" title="④线程安全的类"></a>④线程安全的类</h3><p>线程安全的类是指那些在多线程环境中能够正确处理共享资源访问，避免数据竞争、脏读、死锁等问题的类。</p><p>StringBuffer   Vector   Hashtable</p><p>StringBuffer:</p><p>线程安全，可变的字符序列</p><p>通常使用StringBuilder类，因为它支持所有相同的操作，因为他不执行同步</p><p>Vector:</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 162616.png)</p><p>Hashtable</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 162621.png)</p><p> ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 164013.png)</p><h3 id="⑤lock锁"><a href="#⑤lock锁" class="headerlink" title="⑤lock锁"></a>⑤lock锁</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 164256.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 165016.png)</p><h3 id="3，生产者消费者"><a href="#3，生产者消费者" class="headerlink" title="3，生产者消费者"></a>3，生产者消费者</h3><p>为了体现生产和消费过程中的等待和唤醒，Java就提供了几个方法供我们使用，这几个方法在Object类中Object类的等待和唤醒功能:</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 165453.png)</p><p>监视器:锁</p><h1 id="二十二，网络编程"><a href="#二十二，网络编程" class="headerlink" title="二十二，网络编程"></a>二十二，网络编程</h1><h2 id="1，网络编程入门"><a href="#1，网络编程入门" class="headerlink" title="1，网络编程入门"></a>1，网络编程入门</h2><h3 id="①计算机网络"><a href="#①计算机网络" class="headerlink" title="①计算机网络"></a>①计算机网络</h3><p>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 174028.png)</p><h3 id="②网络编程三要素"><a href="#②网络编程三要素" class="headerlink" title="②网络编程三要素"></a>②网络编程三要素</h3><p>ip地址：</p><p>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接受数据的计算机和识别发送的计算机，而Ip地址就是这个标识号，也就是设备的标识</p><p>端口:</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 174613.png)</p><p>协议:</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 174643.png)</p><h3 id="④ip地址"><a href="#④ip地址" class="headerlink" title="④ip地址"></a>④ip地址</h3><p>IP地址:是网络中设备的唯一标识</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 191435.png)</p><p>命令与地址</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 193504.png)</p><h3 id="⑤InetAddress的使用"><a href="#⑤InetAddress的使用" class="headerlink" title="⑤InetAddress的使用"></a>⑤InetAddress的使用</h3><p>为了方便我们对ip地址的获取和操作，提供了一个类InetAddress供我们使用</p><p>InetAddress:此类表示Internet（ip）协议</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 194007.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 195131.png)</p><h3 id="⑥端口"><a href="#⑥端口" class="headerlink" title="⑥端口"></a>⑥端口</h3><p>端口:设备上应用程序的为标识</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-20 195820.png)</p><h3 id="⑤协议"><a href="#⑤协议" class="headerlink" title="⑤协议"></a>⑤协议</h3><p>协议:计算机</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 073647.png)</p><p>TCP协议</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 073900.png)</p><p>三次握手</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 073933.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 074023.png)</p><p>在吗?在，好的</p><p>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件，下载文件，浏览网页等</p><h2 id="2，UDP通信程序"><a href="#2，UDP通信程序" class="headerlink" title="2，UDP通信程序"></a>2，UDP通信程序</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 074702.png)</p><p>发送数据的步骤:</p><p>①创建发送端的Socket对象(DatagramSocket)</p><p>②创建数据，并把数据打包</p><p>③调用DatagramSocket对象的方法发送数据</p><p>④关闭发送端</p><p>void close()</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 075211.png)</p><p>接受数据的步骤</p><p>①创建接受端的Socket对象(DatagramSocket)</p><p>②创建一个数据包，用于接受数据</p><p>③调用DatagramSocket对象的方法接收数据</p><p>④解析数据包，并把数据在控制台显示</p><p>⑤关闭接收端</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 090135.png)</p><p>![屏幕截图 2024-07-22 090212](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 090212.png)</p><h2 id="3，TCP通信程序"><a href="#3，TCP通信程序" class="headerlink" title="3，TCP通信程序"></a>3，TCP通信程序</h2><h3 id="①TCP通信原理"><a href="#①TCP通信原理" class="headerlink" title="①TCP通信原理"></a>①TCP通信原理</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 090518.png)</p><p>发送数据的步骤</p><p>①创建客户端的Socket对象(Socket)</p><p>Socket(String host,int port)</p><p>②获取输出流，写数据</p><p>OutputStream getOutputStream()</p><p>③释放资源</p><p>void close()</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 092627.png)</p><h3 id="②TCP接受数据"><a href="#②TCP接受数据" class="headerlink" title="②TCP接受数据"></a>②TCP接受数据</h3><p>接受数据的步骤</p><p>①创建服务器端的Socket对象(ServerSocket)</p><p>ServerSocket(int port)</p><p>②监听客户端连接，返回一个Socket对象</p><p>Socket accept()</p><p>②获取输入流，读数据，并把数据显示在控制台</p><p>InputStream getlnputStream()</p><p>③释放资源</p><p> void close()</p><ol><li><strong>创建ServerSocket</strong>：首先，你需要创建一个<code>ServerSocket</code>对象，该对象将绑定到一个特定的端口上。这是服务器监听客户端连接的基础。</li><li>**调用accept()**：<code>ServerSocket</code>对象提供了一个<code>accept()</code>方法，该方法会阻塞并等待客户端的连接请求。当客户端尝试连接时，<code>accept()</code>方法将返回一个<code>Socket</code>对象，代表了与客户端之间的连接。</li><li><strong>处理客户端连接</strong>：一旦<code>accept()</code>方法返回了<code>Socket</code>对象，你就可以通过该对象的输入输出流与客户端进行通信。通常，你会在一个新的线程中处理每个客户端连接，以允许多个客户端同时连接。</li><li><strong>关闭连接</strong>：在处理完客户端的请求后，记得关闭<code>Socket</code>对象，以释放系统资源。</li></ol><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 094054.png)</p><h3 id="③例子"><a href="#③例子" class="headerlink" title="③例子"></a>③例子</h3><p>1，服务器给反馈</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 102504.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 103441.png)</p><p>2，输入</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 110450.png)</p><p>![屏幕截图 2024-07-22 110347](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 110347.png)</p><p>3，写入文本数据</p><p><img src="C:\Users\31502\AppData\Roaming\Typora\typora-user-images\image-20240722110526263.png" alt="image-20240722110526263"></p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 110450.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 111434.png)</p><p>4，文本文件接受与写入</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 112324.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 112137.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 111434.png)</p><p>5，文本文件接受与写入加反馈</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 142617.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 150614.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 150632.png)</p><p>出现问题:程序一直等待</p><p>原因:读数据的方法时阻塞式的</p><p>解决方法:自定义结束标记;使用shutdownOutput()方法</p><p>6，封装</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 151155.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 153253.png)</p><p>![屏幕截图 2024-07-22 153313](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 153313.png)</p><p>![屏幕截图 2024-07-22 153326](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 153326.png)</p><p>q：</p><p>1，为什么while ((line &#x3D; br.readLine()) !&#x3D; null) { System.out.println(line);如果在网络中读不到数据不会停止运行?</p><p>在Java中，当你使用 <code>BufferedReader</code> 的 <code>readLine()</code> 方法从网络输入流（例如通过 <code>Socket</code> 连接）读取数据时，<code>readLine()</code> 方法会阻塞（等待）直到读取到一行数据或者到达流的末尾。如果网络连接中断，或者远程服务器停止发送数据，<code>readLine()</code> 方法最终会返回 <code>null</code>，这将使 <code>while</code> 循环终止。</p><h1 id="二十三，Lambda表达式"><a href="#二十三，Lambda表达式" class="headerlink" title="二十三，Lambda表达式"></a>二十三，Lambda表达式</h1><h2 id="1，函数式编程思想概述"><a href="#1，函数式编程思想概述" class="headerlink" title="1，函数式编程思想概述"></a>1，函数式编程思想概述</h2><p>在数学中，函数就是有输入量，输出流的一套计算方案，也就是”拿数据做操作”面向对象思想强调”必须通过对象的形式来做事情”</p><p>函数式思想则尽量忽略面向对象的复杂语法:”强调做什么，而不是以什么形式去做”而我们要学习的Lambda表达式就是函数式思想的体现</p><p>方式1</p><p>定义一个类</p><p>定义一个类MyRunnable实现Runnable接口</p><p>在MyRunnable类中重写run()方法&#x2F;&#x2F;不能使用getName方法</p><p>创建MyRunnable类对象</p><p>创建Thread类的对像&#x2F;&#x2F;他是自带的，把MyRunnable对象作为构造方法的参数</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 155806.png)</p><h2 id="2，Lambda表达式的标准格式"><a href="#2，Lambda表达式的标准格式" class="headerlink" title="2，Lambda表达式的标准格式"></a>2，Lambda表达式的标准格式</h2><p> 组成Lambda表达式的三要素:形式参数，箭头，代码块</p><p>格式:(形式参数)-&gt;{代码块}</p><p>形式参数:如果有多个参数，参数之间用逗号隔开;如果没有参数，留空即可</p><p>-&gt;:由英文中划线和大于符号组成，固定写法。代表指向动作</p><p>代码块:是我们具体要做的实景，也就是我们写的方法体内容</p><p>Lambda表达式的方法中必须有参数</p><h2 id="3，练习"><a href="#3，练习" class="headerlink" title="3，练习"></a>3，练习</h2><p>Lambda表达式的使用前提</p><p>有一个接口</p><p>接口中有且仅有一个抽象方法</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 191310.png)</p><p>![屏幕截图 2024-07-22 191322](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 191322.png)</p><p>![屏幕截图 2024-07-22 170520](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 170520.png)</p><p>2，</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 174557.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 175411.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 175443.png)</p><h4 id="Lambda表达式其实就是接口方法的重写（参数）-方法体"><a href="#Lambda表达式其实就是接口方法的重写（参数）-方法体" class="headerlink" title="Lambda表达式其实就是接口方法的重写（参数）-&gt;{方法体}"></a>Lambda表达式其实就是接口方法的重写（参数）-&gt;{方法体}</h4><h2 id="4，省略规则"><a href="#4，省略规则" class="headerlink" title="4，省略规则"></a>4，省略规则</h2><p>1.参数类型可以省略。但是有多个参数的情况下，不能只省略一个</p><p>2.如果参数有且仅有一个，那么小括号可以省略</p><p>3.如果代码块的语句只有一条，可以省略大括号和分号，甚至是return</p><h2 id="5，注意事项"><a href="#5，注意事项" class="headerlink" title="5，注意事项"></a>5，注意事项</h2><p>在匿名内部类中实例化即代表重写</p><p>如new fdf()&#x2F;&#x2F;接口名{}</p><p>1，使用Lambda必须要有接口，并且要求接口中有且仅有一个抽象方法</p><p>2，必须有上下文环境，才能推导出Lambda对应的接口</p><p>​根据局部变量的赋值得知Lambda对应的接口:Runnabler r&#x3D;()-&gt;System.out.println(“Lambda表达式”)；</p><p>​根据调用方法的参数得知Lambda对应的接口：new Thread(()-&gt;System.out.println(“Lambda表达式”)).start（）；</p><p><strong>在Java中，你可以创建任意数量的同一接口的实例，并为每个实例单独提供具体的实现。这通常通过Lambda表达式或匿名内部类来完成，尤其是对于函数式接口（即只有一个抽象方法的接口）</strong></p><h2 id="6-Lambda表达式和匿名内部类的区别"><a href="#6-Lambda表达式和匿名内部类的区别" class="headerlink" title="6,Lambda表达式和匿名内部类的区别"></a>6,Lambda表达式和匿名内部类的区别</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 212132.png)</p><h1 id="二十四，接口组成更新"><a href="#二十四，接口组成更新" class="headerlink" title="二十四，接口组成更新"></a>二十四，接口组成更新</h1><h2 id="1，概述-4"><a href="#1，概述-4" class="headerlink" title="1，概述"></a>1，概述</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 212459.png)</p><h2 id="2，接口默认方法"><a href="#2，接口默认方法" class="headerlink" title="2，接口默认方法"></a>2，接口默认方法</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 213235.png)</p><p>重写的时候要在实现类去掉default</p><h2 id="3-接口中静态方法"><a href="#3-接口中静态方法" class="headerlink" title="3.接口中静态方法"></a>3.接口中静态方法</h2><p>接口中并不是所有都是抽象方法</p><p>只有抽象方法，静态方法，默认方法</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 214218.png)</p><h2 id="4，接口中私有方法"><a href="#4，接口中私有方法" class="headerlink" title="4，接口中私有方法"></a>4，接口中私有方法</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 215055.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 214749.png)</p><p>![屏幕截图 2024-07-22 214912](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-22 214912.png)</p><h1 id="二十五，方法引用（进行重写（实现），同时调用方法"><a href="#二十五，方法引用（进行重写（实现），同时调用方法" class="headerlink" title="二十五，方法引用（进行重写（实现），同时调用方法)"></a>二十五，方法引用（进行重写（实现），同时调用方法)</h1><h2 id="1，方法引用符"><a href="#1，方法引用符" class="headerlink" title="1，方法引用符"></a>1，方法引用符</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 073144.png)</p><h2 id="2-Lambda表达式支持的方法"><a href="#2-Lambda表达式支持的方法" class="headerlink" title="2,Lambda表达式支持的方法"></a>2,Lambda表达式支持的方法</h2><p>常用的引用方式:</p><p>引用类方式</p><p>引用对象的实例方法</p><p>引用类的实例方法</p><p>引用构造器</p><h3 id="①引用类方法"><a href="#①引用类方法" class="headerlink" title="①引用类方法"></a>①引用类方法</h3><p>引用类方法:其实就是引用类（大多为工具类）的静态方法</p><p>格式:类名::静态方法</p><p>范例:Integer::parselnt</p><p>Integer类的方法:public static int parselnt(String s)将此String 转换为int类型</p><p>Lambda表达式被类方法替代时，它的形式参数全部传递给静态方法作为参数</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 082023.png)</p><h3 id="②引用对象的实例方法"><a href="#②引用对象的实例方法" class="headerlink" title="②引用对象的实例方法"></a>②引用对象的实例方法</h3><p>引用对象的实例方法，其实是引用类中的成员方法</p><p>格式:对象::成员方法</p><p>范例:”HelloWorld”::toUpperCase</p><p>String类中的方法:public String toUpperCase()将此String所有字符转换为大写</p><p>Lambda表达式被对象的实例方法替代时，它的形式参数全部传递给该方法作为参数</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 084055.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 084336.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 084404.png)</p><h3 id="③引用类的的实例方法"><a href="#③引用类的的实例方法" class="headerlink" title="③引用类的的实例方法"></a>③引用类的的实例方法</h3><p>引用类的实例方法，其实就是引用类中成员方法</p><p>格式:类名::成员方法</p><p>范例:String::substring</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 085735.png)</p><p>![屏幕截图 2024-07-23 085747](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 085747.png)</p><h3 id="④引用构造器"><a href="#④引用构造器" class="headerlink" title="④引用构造器"></a>④引用构造器</h3><p>其实就是引用构造方法</p><p>格式:类名::new</p><p>范例:Student::new</p><h1 id="二十六，函数式接口"><a href="#二十六，函数式接口" class="headerlink" title="二十六，函数式接口"></a>二十六，函数式接口</h1><p>函数式接口:有且仅有一个抽象方法的接口</p><p>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口</p><p>只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利地进行推导</p><p>如何检测一个接口是不是函数式接口呢</p><p>@Functionallnterface</p><p>放在接口定义的上方:如果接口是函数式接口，编译通过;如果不是，编译失败</p><p>注意</p><p>我们自己定义函数式接口的时候，@Functionallnterface是可选的，但是建议加上该注解</p><h2 id="1，函数式接口作为方法的参数"><a href="#1，函数式接口作为方法的参数" class="headerlink" title="1，函数式接口作为方法的参数"></a>1，函数式接口作为方法的参数</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 094418.png)</p><h2 id="2，函数式接口作为方法的返回值"><a href="#2，函数式接口作为方法的返回值" class="headerlink" title="2，函数式接口作为方法的返回值"></a>2，函数式接口作为方法的返回值</h2><p>需求</p><p>定义一个类（ComparatorDemo），在类中提供两个方法<br>一个方法是：Comparator&lt; String &gt; getComparator() 方法返回值Comparator是一个函数式接口</p><p>一个方法是主方法，在主方法中调用getComparator方法</p><p>如果一个方法的返回值是一个函数式接口，我们可以把一个Lambda表达式作为结果返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private static Comparator&lt;String&gt; getComparator() &#123;    </span><br><span class="line">//Lambda表达式写法</span><br><span class="line">    return (s1, s2) -&gt; s1.length() - s2.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Collections;</span><br><span class="line">import java.util.Comparator;</span><br><span class="line"></span><br><span class="line">public class ComparatorDemo &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(&quot;cccc&quot;);</span><br><span class="line">        list.add(&quot;aa&quot;);</span><br><span class="line">        list.add(&quot;b&quot;);</span><br><span class="line">        list.add(&quot;ddd&quot;);</span><br><span class="line"></span><br><span class="line">​    System.out.println(&quot;排序前&quot; + list);</span><br><span class="line">​    Collections.sort(list, getComparator());</span><br><span class="line">​    System.out.println(&quot;排序后&quot; + list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//如果一个方法的返回值是一个函数式接口，我们可以把一个Lambda表达式作为结果返回</span><br><span class="line">private static Comparator&lt;String&gt; getComparator() &#123;</span><br><span class="line">    //使用匿名内部类实现</span><br><span class="line"></span><br><span class="line">//        return new Comparator&lt;String&gt;() &#123;</span><br><span class="line">//            @Override</span><br><span class="line">//            public int compare(String s1, String s2) &#123;</span><br><span class="line">//                return s1.length()-s2.length();</span><br><span class="line">//            &#125;</span><br><span class="line">//        &#125;;</span><br><span class="line"></span><br><span class="line">​    //Lambda表达式写法</span><br><span class="line">​    return (s1, s2) -&gt; s1.length() - s2.length();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3，常用的函数式接口"><a href="#3，常用的函数式接口" class="headerlink" title="3，常用的函数式接口"></a>3，常用的函数式接口</h2><ul><li>Supplier接口</li><li>Consumer接口</li><li>Predicate接口</li><li>Function接口</li></ul><h3 id="①Supplier接口"><a href="#①Supplier接口" class="headerlink" title="①Supplier接口"></a>①Supplier接口</h3><p>Supplier&lt; T &gt;：包含一个无参的方法</p><p>T get()：获得结果<br>该方法不需要参数，他会按照某种实现逻辑（由Lambda表达式实现）返回一个数据<br>Supplier&lt; T &gt;接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get方法就会产生什么类型的数据供我们使用</p><h5 id="注意-return可以省略"><a href="#注意-return可以省略" class="headerlink" title="注意:return可以省略"></a>注意:return可以省略</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 102856.png)</p><p>多条语句</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 103636.png)</p><h3 id="②consumer接口"><a href="#②consumer接口" class="headerlink" title="②consumer接口"></a>②consumer接口</h3><p><code>Consumer&lt;T&gt;</code>是Java中的一个函数式接口，它主要用来<strong>消费或处理类型为<code>T</code>的对象</strong>。<code>Consumer&lt;T&gt;</code>接口只有一个抽象方法<code>void accept(T t);</code>，这个方法接收一个类型为<code>T</code>的参数，并对其执行某种操作，但不返回任何值。</p><p><code>Consumer&lt;T&gt;</code>接口非常适合用来作为参数传递给方法，或者在流（<code>Stream</code>）操作中作为终端操作的一部分，用于处理数据。例如，你可以使用<code>Consumer&lt;T&gt;</code>来打印列表中的每个元素，或者更新数据库中的记录等</p><p>Consumer&lt; T &gt;：包含两个方法</p><p>1.void accept(T t)：对给定的参数执行此操作 </p><p>2.default Consumer &lt; T &gt; andThen(Consumer after)：返回一个组</p><p>合的Consumer，依次执行此操作，然后执行after操作</p><p>Consumer&lt; T &gt;接口也被称为消费型接口，它消费的数据类型由泛型指定</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">  operatorString(<span class="string">&quot;张三&quot;</span>, (s) -&gt; System.out.println(s));</span><br><span class="line">        </span><br><span class="line">  operatorString(<span class="string">&quot;张三&quot;</span>, (s) -&gt; System.out.println(s), (s)-&gt; System.out.println(<span class="keyword">new</span>  </span><br><span class="line">                                                                              <span class="title class_">StringBuilder</span>(s).reverse().toString()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个方法，消费一个字符串数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con)</span> &#123;</span><br><span class="line">    con.accept(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个方法，用不同的方式消费同一个字符串两次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorString</span><span class="params">(String name, Consumer&lt;String&gt; con1,Consumer&lt;String&gt; con2)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        con1.accept(name);</span></span><br><span class="line"><span class="comment">//        con2.accept(name);</span></span><br><span class="line">        <span class="comment">//返回一个组合的Consumer</span></span><br><span class="line">        con1.andThen(con2).accept(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="q："><a href="#q：" class="headerlink" title="q："></a>q：</h5><p>你没有在同一个类中实现<code>accept</code>方法两次，而是创建了两个独立的<code>Consumer&lt;String&gt;</code>实例，每个实例都有自己的<code>accept</code>方法实现。当你在<code>operatorString</code>方法中使用<code>andThen</code>方法时，你实际上是在创建一个新的<code>Consumer&lt;String&gt;</code>实例，这个实例包含了两个操作的顺序执行。也就是说，你创建了两个独立的<code>Consumer&lt;String&gt;</code>，并通过<code>andThen</code>将它们串联起来，形成一个新的<code>Consumer&lt;String&gt;</code>。</p><p>这里的关键点是，虽然<code>accept</code>方法在两个Lambda表达式中都被实现了，但这不是在同一个类中的重复实现，而是两个独立的实现，每个都在不同的<code>Consumer&lt;String&gt;</code>实例中。因此，这不属于同一个抽象方法实现两次，而是两个独立的实现，它们恰好覆盖了同一个接口的抽象方法。</p><h3 id="③Predicate接口"><a href="#③Predicate接口" class="headerlink" title="③Predicate接口"></a>③Predicate接口</h3><p><code>Predicate&lt;T&gt;</code>接口在Java中是一个函数式接口，它主要<strong>用于测试类型为<code>T</code>的对象是否满足某种条件</strong>。<code>Predicate&lt;T&gt;</code>接口定义了一个抽象方法<code>boolean test(T t);</code>，用于对给定的<code>T</code>类型对象进行评估并返回一个布尔值表示是否满足条件。</p><p><strong>也就是实现的是Test()方法</strong>，测试实现的具体内容</p><p>Predicate&lt; T &gt;：常用的四个方法</p><p>boolean test(T t)：对给定的参数进行判断（判断逻辑由Lambda表达式实现），返回一个布尔值<br>default Predicate&lt; T &gt; negate()：返回一个逻辑的否定，对应逻辑非<br>default Predicate&lt; T &gt; and(Predicate other)：返回一个组合判断，对应短路与<br>default Predicate&lt; T &gt; or(Predicate other)：返回一个组合判断，对应短路或<br>Predicate&lt; T &gt;：接口通常用于判断参数是否满足指定的条件</p><p>![ ](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 143702.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 145504.png)</p><p>进行重写，同时调用方法</p><h3 id="④Function接口"><a href="#④Function接口" class="headerlink" title="④Function接口"></a>④Function接口</h3><p>Function&lt;T,R&gt;：接口通常用于对参数进行<strong>处理，转换</strong>（处理逻辑由Lambda表达式实现），然后返回一个新值</p><p><strong>R</strong> apply(<strong>T</strong> t)：将此函数应用于给定的参数</p><p>default&lt; V &gt;：Function andThen(Function after)：返回一个组合函数，首先将该函数应用于输入，然后将after函数应用于结果</p><p>T表示函数输入的类型</p><p>R表示函数结果的类型</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 152944.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 153124.png)</p><h1 id="二十七，Stream流"><a href="#二十七，Stream流" class="headerlink" title="二十七，Stream流"></a>二十七，Stream流</h1><h2 id="1，体验"><a href="#1，体验" class="headerlink" title="1，体验"></a>1，体验</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 155932.png)</p><h2 id="2，Stream流的生成方式"><a href="#2，Stream流的生成方式" class="headerlink" title="2，Stream流的生成方式"></a>2，Stream流的生成方式</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 160126.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 160322.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 161322.png)</p><h2 id="3，Stream流的常见中间操作方法"><a href="#3，Stream流的常见中间操作方法" class="headerlink" title="3，Stream流的常见中间操作方法"></a>3，Stream流的常见中间操作方法</h2><h4 id="①Streamfilter-Predicate-predicate-用于对流中的数据进行过滤"><a href="#①Streamfilter-Predicate-predicate-用于对流中的数据进行过滤" class="headerlink" title="①Streamfilter(Predicate predicate):用于对流中的数据进行过滤"></a>①Stream<T>filter(Predicate predicate):用于对流中的数据进行过滤</h4><h4 id="Predicate接口中的方法-boolean-test-T-t-对给定的参数进行判断，返回一个布尔值"><a href="#Predicate接口中的方法-boolean-test-T-t-对给定的参数进行判断，返回一个布尔值" class="headerlink" title="Predicate接口中的方法          boolean test(T t):对给定的参数进行判断，返回一个布尔值"></a>Predicate接口中的方法          boolean test(T t):对给定的参数进行判断，返回一个布尔值</h4><p>过滤流中的元素，只保留满足给定谓词（条件）的元素。</p><ul><li>参数：一个<code>Predicate</code>接口的实例，表示要应用的过滤条件。</li></ul><p> 当你调用 <code>list.stream()</code> 方法时，就已经创建了一个流。流是基于集合元素的一次性计算，它不会改变源集合的内容，而是产生一个新的结果。所以不用声明一个流</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 162357.png)</p><h4 id="②Streamlimit-long-maxSize-返回此流中的元素组成的流，截取前指定参数个数的数据"><a href="#②Streamlimit-long-maxSize-返回此流中的元素组成的流，截取前指定参数个数的数据" class="headerlink" title="②Streamlimit(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据"></a>②Stream<T>limit(long maxSize):返回此流中的元素组成的流，截取前指定参数个数的数据</h4><h4 id="Streamskip-long-n-跳过指定参数个数的数据，返回由该流的剩余元素组成的流"><a href="#Streamskip-long-n-跳过指定参数个数的数据，返回由该流的剩余元素组成的流" class="headerlink" title="Streamskip(long n):跳过指定参数个数的数据，返回由该流的剩余元素组成的流"></a>Stream<T>skip(long n):跳过指定参数个数的数据，返回由该流的剩余元素组成的流</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 164325.png)</p><h4 id="③staticStreamconcat-Stream-a-Stream-b-合并a和b两个流为一个流"><a href="#③staticStreamconcat-Stream-a-Stream-b-合并a和b两个流为一个流" class="headerlink" title="③staticStreamconcat(Stream a,Stream b):合并a和b两个流为一个流"></a>③static<T>Stream<T>concat(Stream a,Stream b):合并a和b两个流为一个流</h4><h4 id="Streamdistinct-返回由该流的不同元素-根据Object-equals-Object-组成的流"><a href="#Streamdistinct-返回由该流的不同元素-根据Object-equals-Object-组成的流" class="headerlink" title="Streamdistinct():返回由该流的不同元素(根据Object.equals(Object))组成的流"></a>Stream<T>distinct():返回由该流的不同元素(根据Object.equals(Object))组成的流</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 170108.png)</p><h4 id="④Streamsorted-返回由此流的元素组成的流，根据自然顺序排序"><a href="#④Streamsorted-返回由此流的元素组成的流，根据自然顺序排序" class="headerlink" title="④Streamsorted():返回由此流的元素组成的流，根据自然顺序排序"></a>④Stream<T>sorted():返回由此流的元素组成的流，根据自然顺序排序</h4><h4 id="Streamsorted-Comparator-comparator-返回由此流的元素组成的流，根据提供的Comparator进行排序"><a href="#Streamsorted-Comparator-comparator-返回由此流的元素组成的流，根据提供的Comparator进行排序" class="headerlink" title="Streamsorted(Comparator comparator):返回由此流的元素组成的流，根据提供的Comparator进行排序"></a>Stream<T>sorted(Comparator comparator):返回由此流的元素组成的流，根据提供的Comparator进行排序</h4><p>**sorted(Comparator&lt;? super T&gt; comparator)**： 对流中的元素进行排序。</p><ul><li>参数：一个<code>Comparator</code>接口的实例，表示排序规则。</li></ul><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 171511.png)</p><h4 id="⑤Streammap-Function-mapper-返回由给定函数应用于此流的元素的结果组成的流"><a href="#⑤Streammap-Function-mapper-返回由给定函数应用于此流的元素的结果组成的流" class="headerlink" title="⑤Streammap(Function mapper):返回由给定函数应用于此流的元素的结果组成的流"></a>⑤<R>Stream<R>map(Function mapper):返回由给定函数应用于此流的元素的结果组成的流</h4><p>​Function接口中的方法               R apply(T t)</p><p>**map(Function&lt;T, R&gt; mapper)**： 将流中的每个元素转换为另一种类型。</p><ul><li>参数：一个<code>Function</code>接口的实例，表示转换逻辑。</li></ul><h4 id="IntStream-map-Tolnt-TolntFunction-mapper-返回一个IntStream其中包含将给定函数应用于此流的元素的结果"><a href="#IntStream-map-Tolnt-TolntFunction-mapper-返回一个IntStream其中包含将给定函数应用于此流的元素的结果" class="headerlink" title="IntStream map Tolnt(TolntFunction mapper):返回一个IntStream其中包含将给定函数应用于此流的元素的结果"></a>IntStream map Tolnt(TolntFunction mapper):返回一个IntStream其中包含将给定函数应用于此流的元素的结果</h4><p>​IntStream:表示原始int流</p><p>​TolntFunction接口中的方法                       int applyAslnt(T value)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 172842.png)</p><h2 id="4-常见终结操作方法"><a href="#4-常见终结操作方法" class="headerlink" title="4,常见终结操作方法"></a>4,常见终结操作方法</h2><p>void forEach(Consumer sction):对此流的每个元素执行操作</p><p>​Consumer接口中的方法                   void accept(T t):对给定的参数执行此操作</p><p>long count():返回此流中的元素数</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 174326.png)</p><h2 id="5，练习"><a href="#5，练习" class="headerlink" title="5，练习"></a>5，练习</h2><p>![屏幕截图 2024-07-23 175745](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 175745.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 175759.png)</p><h2 id="6，Stream流的收集操作"><a href="#6，Stream流的收集操作" class="headerlink" title="6，Stream流的收集操作"></a>6，Stream流的收集操作</h2><p>对数据使用Stream流的方式操作完毕后，我想把流中的数据收集到集合中，该怎么办呢?</p><p>Stream流的收集方法</p><p>R collect(Collector collector)</p><p>但是这个收集方法的参数是一个Collector接口</p><p>工具类Collector提供了具体的收集方式</p><p>public static<T>Collector toList():把元素收集到List集合中</p><p>public static<T>Collector toSet():把元素收集到List集合中</p><p>public static Collector toMap(Function keyMapper,Function valueMapper):把元素收集到Map集合中</p><p>**collect(Collector&lt;? super T, A, R&gt; collector)**： 将流转换为其他形式的数据结构，如列表、集合、Map等。</p><ul><li>参数：一个<code>Collector</code>接口的实例，表示收集逻辑。</li></ul><p>List</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193750.png)</p><p>Set</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193654.png)</p><p>map</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193356.png)</p><p>![屏幕截图 2024-07-23 193512](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193512.png)</p><p>![屏幕截图 2024-07-23 193540](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 193540.png)</p><h2 id="二十八，反射"><a href="#二十八，反射" class="headerlink" title="二十八，反射"></a>二十八，反射</h2><h2 id="1，类加载器"><a href="#1，类加载器" class="headerlink" title="1，类加载器"></a>1，类加载器</h2><p>当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过类的加载，类的连接，类的初始化这三个步骤来对类进行初始化。如果不出现意外情况，JYM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类加载或者类初始化</p><p>类的加载</p><p>就是指将class文件读入内存，并为之创建一个java.lang.Class对象</p><p>任何类被使用时，系统都会为之建立一个java.lang.Class对象</p><p>类的连接</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 194636.png)</p><p>类的初始化</p><p>在该阶段，主要是对类变量进行初始化</p><h3 id="①类加载"><a href="#①类加载" class="headerlink" title="①类加载"></a>①类加载</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 194848.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 194953.png)</p><h3 id="②类加载器"><a href="#②类加载器" class="headerlink" title="②类加载器"></a>②类加载器</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 195948.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 195902.png)</p><p>类加载器:ClassLoader</p><h2 id="2-反射"><a href="#2-反射" class="headerlink" title="2,反射"></a>2,反射</h2><h3 id="①反射概述"><a href="#①反射概述" class="headerlink" title="①反射概述"></a>①反射概述</h3><p>反射就是把java类中的各种成分映射成一个个的Java对象</p><p>Java反射机制:是指在运行时去获取一个类的变量和方法信息。然后通过获取到的信息来创建对象，调用方法的一种机制。由于这种动态性，可以极大的增强程序的灵活性，程序不用在编译器就完成确定，在运行期仍然可以扩展</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 200658.png)</p><h3 id="②获取Class类的对象"><a href="#②获取Class类的对象" class="headerlink" title="②获取Class类的对象"></a>②获取Class类的对象</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 201545.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 202549.png)</p><h3 id="③反射获取构造方法并使用"><a href="#③反射获取构造方法并使用" class="headerlink" title="③反射获取构造方法并使用"></a>③反射获取构造方法并使用</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 204011.png)</p><p>newInstance(Object… initargs)<br>           使用此 Constructor 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。<br>它的返回值是T类型，所以newInstance是创建了一个构造方法的声明类的新实例对象。并为之调用<br>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 204241.png)</p><h3 id="④练习"><a href="#④练习" class="headerlink" title="④练习"></a>④练习</h3><p>1</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 205301.png)</p><p>2</p><p>public void setAccessible(boolean flag):值为true,取消访问检查</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 210343.png)</p><h3 id="⑤反射获取成员变量并使用"><a href="#⑤反射获取成员变量并使用" class="headerlink" title="⑤反射获取成员变量并使用"></a>⑤反射获取成员变量并使用</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 211509.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 211544.png)</p><h3 id="⑥反射获取成员方法并使用"><a href="#⑥反射获取成员方法并使用" class="headerlink" title="⑥反射获取成员方法并使用"></a>⑥反射获取成员方法并使用</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 213258.png)</p><h1 id="二十九，模块化"><a href="#二十九，模块化" class="headerlink" title="二十九，模块化"></a>二十九，模块化</h1><h2 id="1，模块化概述"><a href="#1，模块化概述" class="headerlink" title="1，模块化概述"></a>1，模块化概述</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 213609.png)</p><h2 id="2，模块的基本使用"><a href="#2，模块的基本使用" class="headerlink" title="2，模块的基本使用"></a>2，模块的基本使用</h2><p><img src="/">![屏幕截图 2024-07-23 214553](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214553.png)</p><p>![屏幕截图 2024-07-23 214605](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214605.png)</p><p>![屏幕截图 2024-07-23 214648](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214648.png)</p><p>![屏幕截图 2024-07-23 214713](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214713.png)</p><h2 id="3，模块服务的使用"><a href="#3，模块服务的使用" class="headerlink" title="3，模块服务的使用"></a>3，模块服务的使用</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 214934.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 215856.png)</p><p>![屏幕截图 2024-07-23 215907](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 215907.png)</p><p>![屏幕截图 2024-07-23 215953](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 215953.png)</p><p>![屏幕截图 2024-07-23 220009](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 220009.png)</p><p>![屏幕截图 2024-07-23 220017](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 220017.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-23 220147.png)</p><style>        *{            margin: 0;            padding: 0;            box-sizing: border-box;        }        ul{            list-style: none;        }        a{            text-decoration: none;            color: #000;        }        .head{ width:100%; height: 84px; display:block;position: sticky;top: 0; z-index: 2;transition: all 0.3s;background-color: #fff;}        /* 设置页头内logo*/        .head .logo{ display:block; height: 60px; width: 202px; position: absolute; left: 150px; top: 12px;background: url(img/logo2.png) no-repeat;background-size: contain;transition:background 0.3s;}        /* 设置无序表 */        .menu_list{ display: block; height:72px; width: 600px;;position: absolute; left: 700px; top: 0px; cursor: pointer; opacity: 1; transition:opacity 0.3s linear;transform: translate(0px,0);}        /* 设置无序表的项 */        .menu_list .menu_item{ display: inline-block; height:72px;  margin-left:72px; position: relative; }        /* 设置无序表项的文本元素*/        .menu_list .menu_item .txt{ display: block; height:72px; line-height: 72px; font-size: 16px; color: black; font-weight: bold; opacity: 0.95; transition:color 0.3s linear; position: relative; z-index: 2;}        /* 用伪元素设置一个蓝条条，提升用户选中时的反馈 */        .menu_list .menu_item .txt::after{content: "";background-color: rgb(4, 99, 231);display: block;border-radius: 4px;height: 4px;width: 100%;position: absolute;top: 50px;opacity: 0; transform: scale(0.01,1);transition: transform 0.2s ease-out, opacity 0.2s ease-out;}        .menu_list .menu_item:hover .txt::after{content: "";background-color: rgb(4, 99, 231);display: block;border-radius: 4px;height: 4px;width: 100%;position: absolute;top: 50px;opacity: 1;transform: scale(1,1);transition: transform 0.2s ease-out, opacity 0.2s ease-out;}    </style>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>javeweb</title>
      <link href="/2024/09/10/Javaweb/"/>
      <url>/2024/09/10/Javaweb/</url>
      
        <content type="html"><![CDATA[<h1 id="一，整体介绍与安排"><a href="#一，整体介绍与安排" class="headerlink" title="一，整体介绍与安排"></a>一，整体介绍与安排</h1><p>javaWeb:使用Java语言完成服务器端程序开发</p><p>数据库课程:数字存储技术</p><p>前端课程:页面展示技术</p><p>web课程:服务器端编程技术</p><p> Junit单元测试:</p><p>测试分类:</p><h1 id="二，Junit"><a href="#二，Junit" class="headerlink" title="二，Junit"></a>二，Junit</h1><h2 id="1，步骤"><a href="#1，步骤" class="headerlink" title="1，步骤:"></a>1，步骤:</h2><p>1，定义一个测试类（测试用例）</p><p>​*建议:</p><p>​*测试类名:被测试的类名Test       CalculatorTest</p><p>​*包名:xxx.xxx.xx.test           cn.itcast.test</p><p>2，定义测试方法:可以独立运行</p><p>​*建议:</p><p>​*方法名:test测试的方法名        testAdd()</p><p>​*返回值:void</p><p>​*参数列表:空参</p><p>3，给方法加  <strong>@Test</strong></p><p>4，导入junit依赖环境</p><p><strong>注意</strong>：判定结果：</p><p>​红色:失败</p><p>​绿色:成功</p><p>​一般我们会用断言操作来处理结果</p><p>​Assert.assertEquals(期望的结果，运算的结果)；</p><p>​<strong>补充</strong>:</p><p>​*@Before:修饰的方法会在测试方法之前被自动执行</p><p>​*@After:修饰的方法会在测试方法执行之后自动被执行</p><h1 id="三，反射"><a href="#三，反射" class="headerlink" title="三，反射"></a>三，反射</h1><h2 id="1-反射-框架设计的灵魂"><a href="#1-反射-框架设计的灵魂" class="headerlink" title="1,反射:框架设计的灵魂"></a>1,反射:框架设计的灵魂</h2><p>​*框架:半成品软件。可以在框架的基础上进行软件开发，简化编码</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h3><p>将类的各个组成部分封装为其他对象，这就是反射机制</p><p>​*好处:</p><p>​1,可以在程序运行过程中，操作这些对像。</p><p>​2，可以解耦，提高程序的可拓展性</p><h2 id="2-获取class对象的方式"><a href="#2-获取class对象的方式" class="headerlink" title="2,获取class对象的方式"></a>2,获取class对象的方式</h2><p>1，Class.forName （”全类名”）:将字节码文件加载到内存中，返回Class对象</p><p><strong>多用于配置文件，将类名定义在配置文件中。读取文件，加载类</strong>*</p><p>2，类名.class:通过类名的属性class获取</p><p><strong>多用于参数的传递</strong></p><p>3，对象.getClass():getClass()方法在Object类中定义着</p><p><strong>多用于对象的获取字节码的方式</strong></p><p>结论:</p><p>​同一个字节码文件(*.class)再一次程序运行中，只会被加载一次，不论通过哪一种方式获取的Class对象都是同一个</p><p>Class c&#x3D;getClass()</p><h2 id="3-使用Class对象"><a href="#3-使用Class对象" class="headerlink" title="3,使用Class对象:"></a>3,使用Class对象:</h2><p>获取功能:</p><p>1,获取成员变量们(Field)</p><p><u>*Field[] getFields()</u></p><p><u>*Field getField(String name)</u></p><p><u>*Field getDeclaredFields()</u></p><p><u>*Field getDeclaredField(String name)</u></p><p>2,获取构造方法们</p><p><u>*Constructor&lt;?&gt;[] getConstructors()</u></p><p><u>*Constructor<T>[] getConstructor( 类&lt;?&gt;…parameterTypes)</u></p><p><u>*Constructor<T>[] getDeclaredConstructors(类&lt;?&gt;…parameterTypes)</u></p><p><u>*Constructor&lt;?&gt;[] getDeclaredConstructors()</u></p><p>3,获取成员方法们</p><p><u>*Method[] getMethods()</u></p><p><u>*Method[] getMethod(string name,类&lt;?&gt;…parameterTypes)</u></p><p><u>*Method[] getDeclaredMethods()</u></p><p><u>*Method[] getDeclaredMethod(string name,类&lt;?&gt;…parameterTypes)</u></p><p>4,获取类名</p><p>String getName</p><h3 id="②Field-成员变量"><a href="#②Field-成员变量" class="headerlink" title="②Field:成员变量"></a>②Field:成员变量</h3><h4 id="获取："><a href="#获取：" class="headerlink" title="获取："></a>获取：</h4><p>*Field[] getFields():获取所有public修饰的成员变量</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 143926.png)</p><p>*Field getField(String name):获取指定参数public修饰的成员变量</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 144259.png)</p><p>&#x2F;&#x2F;a为成员变量的名字类似public String s</p><p>*Field[] getDeclaredFields():获取所有的成员变量，不考虑修饰符</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 145901.png)</p><p>*Field getDeclaredField(String name):通过成员变量名称获取成员变量，不考虑修饰符</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 152013.png)</p><p><strong>注意:Field[] getDeclaredFields()和Field getDeclaredField(String name)在返回由private修饰的成员变量时，并不需要暴力反射，但在调用get和set时需要暴力反射</strong></p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 151801.png)</p><h3 id="③构造方法"><a href="#③构造方法" class="headerlink" title="③构造方法"></a>③构造方法</h3><p>在Java中，<code>println</code>方法并不会直接打印构造器的具体内容，而是打印<code>Constructor</code>对象的字符串表示。这个字符串通常包含了构造器的访问级别、类名、参数类型等信息。</p><p>Constructor&lt;?&gt;[] getConstructors():获取所有public修饰的成员方法</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 154048.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 154217.png)</p><p>*Constructor<T>[] getConstructor( 类&lt;?&gt;…parameterTypes):获取指定参数public修饰的成员方法&#x2F;&#x2F;</p><p><code>Constructor&lt;T&gt;[] getConstructor(Class&lt;?&gt;... parameterTypes)</code>方法是<code>Class</code>类的一个方法，用于获取指定参数类型的公共构造器。<code>T</code>是泛型类型参数，表示构造器的目标类型。<code>（Class&lt;?&gt;... parameterTypes）</code>表示构造器的参数类型。</p><p>也就是根具参数获取构造方法</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 153853.png)</p><p>*Constructor<T>[] getDeclaredConstructors(类&lt;?&gt;…parameterTypes):获取指定参数的成员方法，不考虑修饰符</p><p>*Constructor&lt;?&gt;[] getDeclaredConstructors():获取所有的成员方法，不考虑修饰符</p><h3 id="④成员方法"><a href="#④成员方法" class="headerlink" title="④成员方法"></a>④成员方法</h3><p>*Method[] getMethods()：获取所有public修饰的成员方法</p><p>*Method[] getMethod(string name,类&lt;?&gt;…parameterTypes):获取指定名字+参数public修饰的成员变量</p><p>*Method[] getDeclaredMethods():获取指定名字+参数的成员方法，不考虑修饰符</p><p>*Method[] getDeclaredMethod(string name,类&lt;?&gt;…parameterTypes):获取所有的成员方法，不考虑修饰符</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 162015.png)</p><h4 id="Field-操作"><a href="#Field-操作" class="headerlink" title="Field:操作:"></a>Field:操作:</h4><p>1,设置值</p><p>   void set(Object obj,Object value)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 145448.png)</p><p>2,获取值</p><p>​get(Object obj)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 145433.png)</p><p>3，忽略访问权限修饰符的安全检查</p><p>   setAccessible(true):暴力反射</p><h4 id="Constructor-操作"><a href="#Constructor-操作" class="headerlink" title="Constructor:操作"></a>Constructor:操作</h4><p>1,创建对象</p><p>​T newInstance(Object…initargs)</p><p>​如果使用空参数构造方法创建对象，操作可以简化:class对象的newInstance</p><p>使用此 <code>Constructor</code> 对象表示的构造方法来创建该构造方法的声明类的新实例，并用指定的初始化参数初始化该实例。</p><p>它的返回值是T类型，<strong>所以newInstance是创建了一个构造方法的声明类的新实例对象</strong>。并为之调用</p><h4 id="Method-操作"><a href="#Method-操作" class="headerlink" title="Method:操作"></a>Method:操作</h4><p>1，执行方法:</p><p>​Object invoke(Object obj,oObject…args)括号里是真实的对象和方法实际参数</p><p>2，获取方法名称</p><p>​String getName</p><p>打印输出的都是方法名和参数实际使用还要调操作</p><h1 id="四，注解"><a href="#四，注解" class="headerlink" title="四，注解"></a>四，注解</h1><h2 id="1，概念"><a href="#1，概念" class="headerlink" title="1，概念"></a>1，概念</h2><p>注释:用文字来描述程序的。给程序员看的</p><p>注解:说明程序，给计算机看的</p><p> Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p><p>Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p><p>作用分类：</p><p>①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】</p><p>② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】</p><p>③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】</p><h2 id="2，JDK内置注解"><a href="#2，JDK内置注解" class="headerlink" title="2，JDK内置注解"></a>2，JDK内置注解</h2><h3 id="①-Override-检测被该注解标注的方法是否是继承自父类"><a href="#①-Override-检测被该注解标注的方法是否是继承自父类" class="headerlink" title="①@Override:检测被该注解标注的方法是否是继承自父类"></a>①@Override:检测被该注解标注的方法是否是继承自父类</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 164117.png)</p><h3 id="②-Deprecated-将该注解标注的内容，表示也过时"><a href="#②-Deprecated-将该注解标注的内容，表示也过时" class="headerlink" title="②@Deprecated:将该注解标注的内容，表示也过时"></a>②@Deprecated:将该注解标注的内容，表示也过时</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 164251.png)</p><p>相比于直接删掉可以兼容低版本</p><h3 id="③-SuppressWarnings-压制警告"><a href="#③-SuppressWarnings-压制警告" class="headerlink" title="③@SuppressWarnings:压制警告"></a>③@SuppressWarnings:压制警告</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 164439.png)</p><p>把黄色的警告压制住</p><p>一般用@SuppressWarnings(“all”)压制方法中的所有警告</p><h2 id="3-自定义注解"><a href="#3-自定义注解" class="headerlink" title="3,自定义注解"></a>3,自定义注解</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 170633.png)</p><p>注解使用</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 171841.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 170717.png)</p><p>注解并不是真的在给方法名赋值，而是向方法添加了元数据（metadata）</p><h2 id="4，元注解"><a href="#4，元注解" class="headerlink" title="4，元注解"></a>4，元注解</h2><p>用注解来限制自定义注解</p><p>@Target:描述注解能够作用的位置</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 172516.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 172431.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 173250.png)</p><p>图片在注解的定义类中</p><p>@Retention:描述注解被保留的阶段</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 173323.png)</p><p>@Documented:描述注解是否被抽取到api文档&#x2F;&#x2F;在这个使用这个注解的自定义注解生成的文档中会有该注解</p><p>@Inherited:描述注解是否被子类继承</p><p>后面两个直接加就行不用加括号</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-24 180130.png)</p><h1 id="五（数），数据库的基本概念"><a href="#五（数），数据库的基本概念" class="headerlink" title="五（数），数据库的基本概念"></a>五（数），数据库的基本概念</h1><h2 id="1，数据库"><a href="#1，数据库" class="headerlink" title="1，数据库"></a>1，数据库</h2><p>:DateBase简称：DB</p><h2 id="2-什么是数据库"><a href="#2-什么是数据库" class="headerlink" title="2,什么是数据库"></a>2,什么是数据库</h2><p>用于存储和管理数据的仓库</p><h2 id="3，数据库的特点"><a href="#3，数据库的特点" class="headerlink" title="3，数据库的特点:"></a>3，数据库的特点:</h2><h3 id="①持久化存储数据的。其实数据库就是一个文件系统"><a href="#①持久化存储数据的。其实数据库就是一个文件系统" class="headerlink" title="①持久化存储数据的。其实数据库就是一个文件系统"></a>①持久化存储数据的。其实数据库就是一个文件系统</h3><h3 id="②方便存储和管理数据"><a href="#②方便存储和管理数据" class="headerlink" title="②方便存储和管理数据"></a>②方便存储和管理数据</h3><h3 id="③使用了统一的方式操作数据库-–SQL"><a href="#③使用了统一的方式操作数据库-–SQL" class="headerlink" title="③使用了统一的方式操作数据库 –SQL"></a>③使用了统一的方式操作数据库 –SQL</h3><h2 id="4-常见的数据库软件"><a href="#4-常见的数据库软件" class="headerlink" title="4,常见的数据库软件"></a>4,常见的数据库软件</h2><p>mysql</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 080754.png)</p><h3 id="②-录入mysql-uroot-p回车再录密码登录可以隐藏密码"><a href="#②-录入mysql-uroot-p回车再录密码登录可以隐藏密码" class="headerlink" title="②,录入mysql -uroot -p回车再录密码登录可以隐藏密码"></a>②,录入mysql -uroot -p回车再录密码登录可以隐藏密码</h3><p>hip指的是host的ip地址</p><h3 id="③mysql目录结构"><a href="#③mysql目录结构" class="headerlink" title="③mysql目录结构"></a>③mysql目录结构</h3><p>1，MySQL安装目录</p><p>​*配置文件 my.ini</p><p>2，MySQL数据目录</p><pre><code>      几个概念</code></pre><p>​数据库:文件夹</p><p>​表:文件</p><p>​数据:数据</p><h1 id="六-数-，SQL概念"><a href="#六-数-，SQL概念" class="headerlink" title="六(数)，SQL概念"></a>六(数)，SQL概念</h1><h2 id="1，什么是SQL"><a href="#1，什么是SQL" class="headerlink" title="1，什么是SQL"></a>1，什么是SQL</h2><p>structured query Language:结构化查询语言</p><p>其实就是定义了操作所有关系型数据库的规则。</p><p>每一种数据库操作的方式存在不一样的地方称为”方言”</p><h2 id="2，SQL通用语法"><a href="#2，SQL通用语法" class="headerlink" title="2，SQL通用语法"></a>2，SQL通用语法</h2><p>①SQL语句可以单行或多行书写，以分号结尾</p><p>②可使用空格和缩进来增强语句的可读性。</p><p>③MySQL数据库的SQL语句不区分大小写，关键字建议使用大写</p><p>④ 3种注释</p><p>*单行注释: –注释内容或#注释内容(mysql特有)</p><p>多行注释:&#x2F;注释&#x2F;</p><h2 id="3-SQL分类"><a href="#3-SQL分类" class="headerlink" title="3,SQL分类"></a>3,SQL分类</h2><p>①DDL(Data Definiton Language)数据定义语言</p><p>​用来定义数据库对象:数据库，表，列等。关键字:create,drop,alter等</p><p>②DML(Data Manipulation Language)数据操作语言</p><p>​用来对数据库中表的数据进行增删改。关键字:insert,delete,update等</p><p>③DQL(Data Query Language)数据查询语言</p><p>​用来查询数据库中表的记录(数据)。关键字:select,where等</p><p>④DCL(Data Control Language)数据控制语言(了解)</p><p>用来定义数据库的访问权限和安全级别，及创建用户。关键字:GRANT,REVOKE等</p><h1 id="七-数-Sql-DDL"><a href="#七-数-Sql-DDL" class="headerlink" title="七(数-&gt;Sql)DDL"></a>七(数-&gt;Sql)DDL</h1><h2 id="1-操作数据库-CRUD"><a href="#1-操作数据库-CRUD" class="headerlink" title="1,操作数据库:CRUD"></a>1,操作数据库:CRUD</h2><h3 id="①C-Create-创建"><a href="#①C-Create-创建" class="headerlink" title="①C(Create):创建"></a>①C(Create):创建</h3><p>1，创建db4数据库，判断是否存在，并指定字符集为gbk</p><pre><code>             create database if not exists db4 character set gbk;</code></pre><p>2,创建数据库:</p><p>​create database 数据库名称；</p><p>3,创建数据库，判断不存在，再创建:</p><p>​create database if not exists 数据库名称;</p><p>4，创建数据库，并指定字符集</p><p>​create database 数据库名称 character set 字符集名</p><h3 id="②R-Retrieve-查询"><a href="#②R-Retrieve-查询" class="headerlink" title="②R(Retrieve):查询"></a>②R(Retrieve):查询</h3><p>1，查询所有数据库的名称:</p><p>​show databases;</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 094105.png)</p><p>test可以随便用其他最好不要用</p><p>2，查询某个数据库的字符集:查询某个数据库的创建语句</p><p>​show create database;</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 094901.png)</p><h3 id="③U-Update-修改"><a href="#③U-Update-修改" class="headerlink" title="③U(Update):修改"></a>③U(Update):修改</h3><p>1，修改数据库的字符集</p><p>​alter database 数据库名称 character set 字符集名称;</p><h3 id="④D-Delete-删除"><a href="#④D-Delete-删除" class="headerlink" title="④D(Delete):删除"></a>④D(Delete):删除</h3><p>1,删除数据库</p><p>​drop database 数据库名称</p><p>2,判断数据库存在，存在再删除</p><p>​drop database if exists 数据库名称;</p><h3 id="⑤使用数据库"><a href="#⑤使用数据库" class="headerlink" title="⑤使用数据库"></a>⑤使用数据库</h3><p>1,查询当前正在使用的数据库名称;</p><p>​select database();</p><p>2,使用数据库:</p><p>​use 数据库名称;</p><h2 id="2-操作表"><a href="#2-操作表" class="headerlink" title="2,操作表:"></a>2,操作表:</h2><h3 id="①C-Create-创建-1"><a href="#①C-Create-创建-1" class="headerlink" title="①C(Create):创建"></a>①C(Create):创建</h3><h5 id="1，语法"><a href="#1，语法" class="headerlink" title="1，语法:"></a>1，语法:</h5><p>​create table 表名（</p><p>​列名1 数据类型1，</p><p>​列名2 数据类型2，</p><p>​….</p><p>​列名n 数据类型n);</p><p>注意:最后一列，不需要加逗号(,)</p><h5 id="1，数据库类型"><a href="#1，数据库类型" class="headerlink" title="1，数据库类型:"></a>1，数据库类型:</h5><p>​1,int:整数类型</p><p>​*age int,</p><p>​2,double:小数类型</p><p>​*score double(5,2)&#x2F;&#x2F;&#x2F;括号后是有多少位和保留到多少位</p><p>​3,date:日期,只包含年月日，yyyy-MM-dd</p><p>​4,datetime:日期,包含年月日时分秒  yyyy-MM-dd  HH:mm:ss</p><p>​5,timestamp:时间错类型 包含年月日时分秒   yyyy-MM-dd  HH:mm:ss</p><p>​     如果将来不给这个字段赋值，或者赋值为null,则默认使用当前的系统时间，来自动赋值</p><p>​6，varchar:字符串</p><p>​name varchar(20):姓名最大20个字符</p><p>​zhangsan  8个字符     张三:2个字符</p><h4 id="3-创建表"><a href="#3-创建表" class="headerlink" title="3,创建表"></a>3,创建表</h4><p>create table s (<br>    id int ,<br>    name varchar(32),<br>    age int,<br>    score double(4,1),<br>    birthday date,<br>    insert_time timestamp<br>);</p><hr><p>CREATE TABLE student (<br>    id INT,<br>    name VARCHAR(32),<br>    age INT,<br>    score DOUBLE(4, 1),<br>    birthday DATE,<br>    insert_time TIMESTAMP<br>);</p><h5 id="看源代码，"><a href="#看源代码，" class="headerlink" title="看源代码，"></a>看源代码，</h5><h3 id="②R-Retrieve-查询-1"><a href="#②R-Retrieve-查询-1" class="headerlink" title="②R(Retrieve):查询"></a>②R(Retrieve):查询</h3><p>1，查询某个数据库中所有的表名称</p><p>​use 数据库名称；</p><p>​show tables;</p><p>2,查询表结构</p><p>​use 数据库名称；</p><p>​desc 表名；</p><p>注意:但同时要查询表名称和结构时只要在最上面加use 数据库名称就好，表示进入里面</p><h3 id="③U-Update-修改-1"><a href="#③U-Update-修改-1" class="headerlink" title="③U(Update):修改"></a>③U(Update):修改</h3><p>1，修改表名</p><p>​alter table 表名 rename to 新的表名;</p><p>2，修改表的字符集</p><p>​alter table 表名 character set 字符集名称;</p><p>3，添加一列（实际是行）</p><p>​alter table 表名 add列名 数据类型;</p><p>4,修改列名称 类型</p><p>​alter table 表名 change 列名 新列名 新数据类型;&#x2F;&#x2F;都修改</p><p>​alter table 表名 modify 列名 新数据类型&#x2F;&#x2F;只修改数据类型</p><p>5，删除列</p><p>​alter table 表名 drop列名;</p><h3 id="④D-Delete-删除-1"><a href="#④D-Delete-删除-1" class="headerlink" title="④D(Delete):删除"></a>④D(Delete):删除</h3><p>​1,drop table 表名;</p><p>​ 2,drop table if exists 表名;</p><h1 id="八-数-Sql-DML"><a href="#八-数-Sql-DML" class="headerlink" title="八,(数-&gt;Sql)DML:"></a>八,(数-&gt;Sql)DML:</h1><p>增删改表中数据</p><h2 id="1-添加数据"><a href="#1-添加数据" class="headerlink" title="1,添加数据:"></a>1,添加数据:</h2><h3 id="①语法"><a href="#①语法" class="headerlink" title="①语法:"></a>①语法:</h3><p>​insert into 表名(列名1，列名2，…列名n) values(值1，值2,…值n);</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 165627.png)</p><h3 id="②注意"><a href="#②注意" class="headerlink" title="②注意:"></a>②注意:</h3><p>​1，列名和值要一一对应。</p><p>​ 2，如果表名后,不定义列名,则默认给所有列添加值</p><p>​intsert into 表名 values(值1,值2,…值n);</p><p>​3,除了数字类型，其他类型需要使用引号（单双都可以）引起来</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 165616.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 165633.png)</p><h2 id="2，删除数据"><a href="#2，删除数据" class="headerlink" title="2，删除数据:"></a>2，删除数据:</h2><h3 id="①语法-1"><a href="#①语法-1" class="headerlink" title="①语法:"></a>①语法:</h3><p>​  delete from 表名 where 条件</p><p>​e.g:delete from stu where id&#x3D;2;</p><p>​delete from stu where age&#x3D;17;</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 173651.png)</p><p>均能删掉这一行</p><h3 id="②注意-1"><a href="#②注意-1" class="headerlink" title="②注意:"></a>②注意:</h3><p>​1，如果不加条件，则删除表中所有记录。</p><p>​2，如果要删除所有记录</p><ul><li>delete from 表名;–不推荐使用。有多少条记录就会执行多少次删除操作</li><li>TRUNCATE TABLE 表名;–推荐使用。效率更高 先删除表，然后再创建一张一样的表。</li></ul><h2 id="3，修改数据"><a href="#3，修改数据" class="headerlink" title="3，修改数据"></a>3，修改数据</h2><h3 id="①语法-2"><a href="#①语法-2" class="headerlink" title="①语法:"></a>①语法:</h3><h3 id="update-表名-set-列名1-值1-列名2-值2，…where-条件"><a href="#update-表名-set-列名1-值1-列名2-值2，…where-条件" class="headerlink" title="update 表名 set 列名1 &#x3D; 值1,列名2 &#x3D; 值2，…where 条件;"></a>update 表名 set 列名1 &#x3D; 值1,列名2 &#x3D; 值2，…where 条件;</h3><h3 id="update-stu-set-age-117，score-100-where-id-3"><a href="#update-stu-set-age-117，score-100-where-id-3" class="headerlink" title="update stu set age &#x3D; 117，score &#x3D; 100 where id &#x3D; 3;"></a>update stu set age &#x3D; 117，score &#x3D; 100 where id &#x3D; 3;</h3><p>​set后是被修改的数据，where后的是需要修改的行的标志；</p><h3 id="②注意-2"><a href="#②注意-2" class="headerlink" title="②注意:"></a>②注意:</h3><p>​1,如果不加任何条件，则会将表中的所有记录（修改的列名之下）全部修改。</p><h1 id="九-数-Sql-DQL"><a href="#九-数-Sql-DQL" class="headerlink" title="九.(数-&gt;Sql)DQL:"></a>九.(数-&gt;Sql)DQL:</h1><p>DQL:查询表中的记录</p><h2 id="1-语法"><a href="#1-语法" class="headerlink" title="1,语法:"></a>1,语法:</h2><p>​select</p><p>​字段列表(指列名)</p><p>​from</p><pre><code>         表名列表</code></pre><p>​where</p><p>​条件列表</p><p>​group by</p><p>​分组字段</p><p>​having</p><p>​分组之后的条件</p><p>​order by</p><p>​排序</p><p>​limit</p><p>​分页限定</p><h2 id="2，基础查询"><a href="#2，基础查询" class="headerlink" title="2，基础查询"></a>2，基础查询</h2><p>​1，多个字段的查询:</p><p>​        select 字段名 1，字段名 2..from 表名;</p><p>​        当你查询全部字段使用 *</p><p>​        e.g.:select * from student;</p><p>​2，去除重复式的查询 </p><p>​select distinct 字段列表 from 表名列表;</p><p>​e.g.:select distinct name,address from student;</p><p>​3，计算列</p><p>​一般可以使用四则运算计算一系列的值。(一般只会进行数值型的计算)</p><p>​如果值为0：ifnull(表达式1，表达式2)：null参与的计算，计算结果都为null</p><p>​表达式1:哪个字段需要判断是否为null。</p><p>​如果该字段为null后的替换值。</p><p>​e.g：select name,math,english,math +IFNULL(english,0) from student;</p><p>​4，起别名</p><p>​* as；as也可以省略</p><p>​e.g：select name,math,english,math +IFNULL(english,0) as 总分 from student;</p><p>​将列名math + ifnull(english,0)变成总分</p><h2 id="3，条件查询"><a href="#3，条件查询" class="headerlink" title="3，条件查询"></a>3，条件查询</h2><h3 id="①，where字句后跟条件"><a href="#①，where字句后跟条件" class="headerlink" title="①，where字句后跟条件"></a>①，where字句后跟条件</h3><p>​SELECT 字段列表 FROM 表名 WHERE 条件列表 ;</p><h3 id="②，运算符"><a href="#②，运算符" class="headerlink" title="②，运算符"></a>②，运算符</h3><table><thead><tr><th align="center">&gt;</th><th>大于</th></tr></thead><tbody><tr><td align="center">&gt;&#x3D;</td><td>大于等于</td></tr><tr><td align="center">&lt;</td><td>小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td>小于等于</td></tr><tr><td align="center">&#x3D;</td><td>等于</td></tr><tr><td align="center">&lt;&gt; 或 !&#x3D;</td><td>不等于</td></tr><tr><td align="center">BETWEEN … AND …</td><td>在某个范围之内(含最小、最大值)</td></tr><tr><td align="center">IN(…)</td><td>在in之后的列表中的值，多选一</td></tr><tr><td align="center">LIKE</td><td>占位符 模糊匹配(_匹配单个字符, %匹配任意个字符)</td></tr><tr><td align="center">OR</td><td>和</td></tr><tr><td align="center">IS NULL</td><td>是NULL</td></tr></tbody></table><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 201453.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 201543.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 201920.png)</p><p>![屏幕截图 2024-07-25 202201](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 202201.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 202822.png)</p><p>![屏幕截图 2024-07-25 202835](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 202835.png)</p><p>总之，当使用Like字符时，%表示无数，前面(后面)有几个字符加几个_如果不知道直接加%</p><h2 id="4，排序查询"><a href="#4，排序查询" class="headerlink" title="4，排序查询"></a>4，排序查询</h2><h3 id="①语法-3"><a href="#①语法-3" class="headerlink" title="①语法:"></a>①语法:</h3><p>order by 子句</p><p>​order by 排序字段1 排序方式1，排序字段2 排序方式2…</p><p>先1后2</p><h3 id="②排序方式"><a href="#②排序方式" class="headerlink" title="②排序方式:"></a>②排序方式:</h3><p>ASC:升序，默认的。</p><p>DESC:降序。</p><h3 id="③注意"><a href="#③注意" class="headerlink" title="③注意:"></a>③注意:</h3><p>如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 204719.png)</p><h2 id="5，聚合函数"><a href="#5，聚合函数" class="headerlink" title="5，聚合函数:"></a>5，聚合函数:</h2><p>将<strong>一列</strong>数据作为一个整体，进行纵向计算。</p><h3 id="①count-计算个数"><a href="#①count-计算个数" class="headerlink" title="①count:计算个数"></a>①count:计算个数</h3><p>​1,一般选择非空的列:主键</p><p>​2,count(*)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 211414.png)</p><h3 id="②max-计算最大值"><a href="#②max-计算最大值" class="headerlink" title="②max:计算最大值"></a>②max:计算最大值</h3><p>eg:Select Max(math) from student;</p><h3 id="③min-计算最小值"><a href="#③min-计算最小值" class="headerlink" title="③min:计算最小值"></a>③min:计算最小值</h3><p>eg:Select Min(math) from student;</p><h3 id="④sum-计算和"><a href="#④sum-计算和" class="headerlink" title="④sum:计算和"></a>④sum:计算和</h3><p>eg:select Sum(english) from student;</p><h3 id="⑤avg-计算平均值"><a href="#⑤avg-计算平均值" class="headerlink" title="⑤avg:计算平均值"></a>⑤avg:计算平均值</h3><p>eg:select Avg(math) from student;</p><p>注意:聚合函数的计算，排除null值。</p><p>解决方案:</p><p>1，选择非空的列进行计算</p><p>2，IFNULL函数</p><h2 id="6-分组查询："><a href="#6-分组查询：" class="headerlink" title="6,分组查询："></a>6,分组查询：</h2><h3 id="①，语法-group-by-分组字段；"><a href="#①，语法-group-by-分组字段；" class="headerlink" title="①，语法:group by 分组字段；"></a>①，语法:group by 分组字段；</h3><p>eg：select sex , avg(math) from student group by sex;</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-25 213428.png)</p><p>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组<br>后过滤条件 ];</p><h3 id="②注意-3"><a href="#②注意-3" class="headerlink" title="②注意:"></a>②注意:</h3><p>1,分组之后查询的字段:分组字段，聚合函数</p><p>2，where 和 having的区别?</p><ul><li><strong>执行时机不同：</strong> where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组 之后对结果进行过滤。</li><li><strong>判断条件不同：</strong> where不能对聚合函数进行判断，而having可以</li></ul><p>A. 根据性别分组 , 统计男性员工 和 女性员工的数量</p><p>select gender, count(*) from emp group by gender ;</p><p>B. 根据性别分组 , 统计男性员工 和 女性员工的平均年龄</p><p>select gender, avg(age) from emp group by gender ;</p><p>C. 查询年龄小于45的员工 , 并根据工作地址分组 , 获取员工数量大于等于3的工作地址</p><p>select workaddress, count(*) address_count from emp where age &lt; 45 group by<br>workaddress having address_count &gt;&#x3D; 3;</p><p>D. 统计各个工作地址上班的男性及女性员工的数量</p><p>select workaddress, gender, count(*) ‘数量’ from emp group by gender, workaddress;</p><h2 id="7-分页查询"><a href="#7-分页查询" class="headerlink" title="7,分页查询"></a>7,分页查询</h2><p>分页操作在业务系统开发时，也是非常常见的一个功能，我们在网站中看到的各种各样的分页条，后台<br>都需要借助于数据库的分页操作。</p><p>①语法</p><p>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数 ;</p><p><strong>注意事项：</strong></p><ul><li><p>起始索引从0开始，公式:起始索引 &#x3D; （查询页码 - 1）* 每页显示记录数。</p></li><li><p>分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。</p></li><li><p>如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。</p><p>A. 查询第1页员工数据, 每页展示10条记录</p><p>select * from emp limit 0,10;<br>select * from emp limit 10;</p></li></ul><p>​B. 查询第2页员工数据, 每页展示10条记录 ——–&gt; (页码-1)*页展示记录数</p><p>​select * from emp limit 10,10;</p><p>​C.第3页</p><p>​select * from emp limit 20,10;</p><p>limit是一个MySQL方言</p><h1 id="十-数-Sql-约束"><a href="#十-数-Sql-约束" class="headerlink" title="十.(数-&gt;Sql)约束"></a>十.(数-&gt;Sql)约束</h1><p>概念:对表中数据进行限定，保证数据的正确性，有效性和完整性</p><p>分类:</p><h2 id="1-主键约束-primary-key"><a href="#1-主键约束-primary-key" class="headerlink" title="1,主键约束:primary key"></a>1,主键约束:primary key</h2><h3 id="①注意"><a href="#①注意" class="headerlink" title="①注意:"></a>①注意:</h3><p>​1,含义:非空且唯一</p><p>​2，一张表只能有一个字段为主键</p><p>​3，主键就是表中记录的唯一标识</p><h3 id="②，在创建表时，添加主键约束"><a href="#②，在创建表时，添加主键约束" class="headerlink" title="②，在创建表时，添加主键约束"></a>②，在创建表时，添加主键约束</h3><p>​create table stu(</p><p>​id int primary key,</p><p>​name varchar(20)</p><p>);</p><p>给id添加主键约束</p><h3 id="③删除主键"><a href="#③删除主键" class="headerlink" title="③删除主键"></a>③删除主键</h3><p>​alter table stu <strong>drop</strong> primary key;</p><h3 id="④创建完表后，添加主键"><a href="#④创建完表后，添加主键" class="headerlink" title="④创建完表后，添加主键"></a>④创建完表后，添加主键</h3><p>​alter table stu <strong>modify</strong> id int primary key;</p><h3 id="⑤自动增长"><a href="#⑤自动增长" class="headerlink" title="⑤自动增长"></a>⑤自动增长</h3><p>​1，概念:如果某一列是数值类型的，使用auto_increment 可以来完成值得自动增长</p><p>​    2，在创建表时，添加主键约束，并且完成主键自增长</p><p>create table stu(</p><p>​id int primary key auto_intcrement,–给id添加主键约束</p><p>​name varchar(20)</p><p>);</p><p>​执行操作</p><p>​Insert into stu values (10,ccc)&#x2F;&#x2F;第一个为增长值，第二个是重复值</p><p>​3，删除自动增长</p><p>​alter table stu modify id int;</p><p>​4,添加自动增长(创建表完事后)</p><p>​alter table stu modify id int auto_increment;</p><p>一个表中只能有一个自动增长字段，该字段的数据类型是整数类型，且必须定义为键，如unique key、primary key。</p><p>如果为自动增长字段插入NULL、0、DEFAULT或在插入时省略该字段，则该字段就会使用自动增长值；如果插入的是一个具体的值，则不会使用自动增长值。</p><p>自动增长值从1开始自增，每次加1。如果插入的值大于自动增长的值，则下次插入的自动增长值会自动使用最大值加1；如果插入的值小于自动增长值，则不会对自动增长值产生影响。</p><p>使用DELETE删除记录时，自动增长值不会减小或填补空缺。</p><p>一般执行产生的一行只跟上一行有关</p><h2 id="2-非空约束-not-null"><a href="#2-非空约束-not-null" class="headerlink" title="2,非空约束:not null"></a>2,非空约束:not null</h2><h3 id="①创建表时添加约束"><a href="#①创建表时添加约束" class="headerlink" title="①创建表时添加约束"></a>①创建表时添加约束</h3><p>create table stu(</p><p>​id int,</p><p>​name varchar(20) <strong>not null</strong></p><p>);</p><p>对varchar一列进行不为空约束</p><p> 控制台显示错误:不能为空</p><h3 id="②创建表时完事后，添加非空约束"><a href="#②创建表时完事后，添加非空约束" class="headerlink" title="②创建表时完事后，添加非空约束"></a>②创建表时完事后，添加非空约束</h3><p>alter table stu <strong>modify</strong> name varchar(20) not null;</p><h3 id="③删除name的非空约束"><a href="#③删除name的非空约束" class="headerlink" title="③删除name的非空约束"></a>③删除name的非空约束</h3><p>alter table stu <strong>modify</strong> name varchar(20);</p><h2 id="3-唯一约束-unique"><a href="#3-唯一约束-unique" class="headerlink" title="3,唯一约束:unique"></a>3,唯一约束:unique</h2><h3 id="①创建表时添加约束-1"><a href="#①创建表时添加约束-1" class="headerlink" title="①创建表时添加约束"></a>①创建表时添加约束</h3><p>create table stu(</p><p>​id int,</p><p>​ phone_number varchar(20) unique</p><p>);</p><p>将phone列只能唯一,不能重复</p><p>注意:</p><p>​唯一约束可以有NULL值，但只能有一条记录为null</p><h3 id="②创建表时完事后，添加非空约束-1"><a href="#②创建表时完事后，添加非空约束-1" class="headerlink" title="②创建表时完事后，添加非空约束"></a>②创建表时完事后，添加非空约束</h3><p>alter table stu <strong>modify</strong> phone_number varchar(20) <strong>unique</strong>;</p><h3 id="③删除phone-number的唯一约束"><a href="#③删除phone-number的唯一约束" class="headerlink" title="③删除phone_number的唯一约束"></a>③删除phone_number的唯一约束</h3><p>alter table stu <strong>drop INdex</strong> phone _number;</p><h2 id="4-外键约束-foreign-key"><a href="#4-外键约束-foreign-key" class="headerlink" title="4,外键约束:foreign key"></a>4,外键约束:foreign key</h2><p>让表与表产生关系，从而保证数据的正确性</p><h3 id="①在创建表示，可以添加外键"><a href="#①在创建表示，可以添加外键" class="headerlink" title="①在创建表示，可以添加外键"></a>①在创建表示，可以添加外键</h3><p>​语法:</p><p>​create table 表名(</p><p>​…</p><p>​外键列(外键对应主表的主键)</p><p>​constraint  外键名称 foreign key  (外键列名称) references 主表名称(主表列名称)</p><p>​);</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-26 095009.png)</p><h3 id="②删除外键"><a href="#②删除外键" class="headerlink" title="②删除外键"></a>②删除外键</h3><p>alter table 表名 drop foreign key 外键名称;</p><p>alter table employee drop foreign key emp_dept_fk;</p><h3 id="③创建表之后，添加外键"><a href="#③创建表之后，添加外键" class="headerlink" title="③创建表之后，添加外键"></a>③创建表之后，添加外键</h3><p>alter table 表名 add consitraint 外键名称 foreign key  (外键列名称) references 主表名称(主表列名称)</p><p>alter table employ add consitraint emp_dept_fk foreign key  (dep_id) references department(id)</p><h3 id="④级联操作"><a href="#④级联操作" class="headerlink" title="④级联操作"></a>④级联操作</h3><p>1，添加级联操作</p><p>​语法:alter table 表名 add constraint 外键名称</p><p>​foreign key(外键字段名称) references 主表名称 （主表列名称） on update cascade on delete cascade;</p><p>2,分类:</p><p>​1,级联更新:on update cascate &#x2F;&#x2F;主表改附表改</p><p>​2,级联删除:on delete cascate &#x2F;&#x2F;主表没附表没</p><h1 id="十一-数-Sql-数据库设计"><a href="#十一-数-Sql-数据库设计" class="headerlink" title="十一.(数-&gt;Sql)数据库设计"></a>十一.(数-&gt;Sql)数据库设计</h1><h2 id="1-多表之间的关系"><a href="#1-多表之间的关系" class="headerlink" title="1, 多表之间的关系"></a>1, 多表之间的关系</h2><h3 id="①一对一"><a href="#①一对一" class="headerlink" title="①一对一:"></a>①一对一:</h3><p>​如:人和身份证</p><p>​分析:一个人只有一个身份证，一个身份证只能对应一个人</p><h3 id="②一对多-多对一"><a href="#②一对多-多对一" class="headerlink" title="②一对多(多对一):"></a>②一对多(多对一):</h3><p>​如:部门和员工</p><p>​分析:一个部门有多个员工，一个员工只能对应一个部门</p><h3 id="③多对多"><a href="#③多对多" class="headerlink" title="③多对多:"></a>③多对多:</h3><p>​如:学生和课程</p><p>​分析:一个学生可以选择多门课程，一门课程对应多个人</p><p>​</p><h2 id="2，实现关系"><a href="#2，实现关系" class="headerlink" title="2，实现关系"></a>2，实现关系</h2><p>​1，一对多(多对一):</p><p>​如:部门和员工</p><p>​实现方式:在多的一方建立外键，指向一的一方的主键。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-26 111552.png)</p><p>​2，多对多</p><p>​如:学生和课程</p><p>​ ![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-26 112454.png)</p><p>​3，一对一</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-26 113102.png)</p><p>一般合成一张表</p><h2 id="2，数据库设计的范式"><a href="#2，数据库设计的范式" class="headerlink" title="2，数据库设计的范式"></a>2，数据库设计的范式</h2><p>概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须遵循前边的所有范式要求</p><p>​设计<a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/8999831?fromModule=lemma_inlink">关系型数据库</a>时，遵从不同的规范要求，设计出合理的关系型数据库。这些规范被称作范式。越高的范式数据库的<strong>冗余度就越低</strong></p><p>关系<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE/33305?fromModule=lemma_inlink">数据</a>库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴德斯科范式（BCNF）、第四范式（4NF）和第五范式（5NF又称完美范式）。</p><p>​分类</p><h4 id="①，第一范式-1NF"><a href="#①，第一范式-1NF" class="headerlink" title="①，第一范式(1NF):"></a>①，第一范式(1NF):</h4><p>每一列都是不可分割的原子数据项</p><h4 id="②，第二范式-2NF-在1NF的基础上，非码属性必须完全依赖于候选码-在1NF基础上消除非主属性对主码的部分函数依赖"><a href="#②，第二范式-2NF-在1NF的基础上，非码属性必须完全依赖于候选码-在1NF基础上消除非主属性对主码的部分函数依赖" class="headerlink" title="②，第二范式(2NF):在1NF的基础上，非码属性必须完全依赖于候选码(在1NF基础上消除非主属性对主码的部分函数依赖)"></a>②，第二范式(2NF):在1NF的基础上，非码属性必须完全依赖于候选码(在1NF基础上消除非主属性对主码的部分函数依赖)</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-26 154603.png)</p><h4 id="③第三范式-3NF-在2NF基础上-任何非主属性不依赖于其他非主属性-在2NF基础上消除传递依赖"><a href="#③第三范式-3NF-在2NF基础上-任何非主属性不依赖于其他非主属性-在2NF基础上消除传递依赖" class="headerlink" title="③第三范式(3NF):在2NF基础上,任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)"></a>③第三范式(3NF):在2NF基础上,任何非主属性不依赖于其他非主属性(在2NF基础上消除传递依赖)</h4><p>一张表只能有一个主属性（码属性组）</p><p>可以两个共同推出一个,如:a+b-&gt;c，不能分别推出,如:a-&gt;c ,b-&gt;c;</p><h2 id="3-数据库的备份和还原"><a href="#3-数据库的备份和还原" class="headerlink" title="3,数据库的备份和还原"></a>3,数据库的备份和还原</h2><p>①，命令行:</p><p>​语法:</p><p>​备份:mysqldump -u用户名 -p密码 &gt;保存的路径</p><p>​还原:</p><p>​1.登录数据库;</p><p>​2，创建数据库：create database db1;</p><p>​3，使用数据库:use db1;</p><p>​4，执行文件:source 文件路径</p><p>②图形化工具:  </p><h1 id="十二，多表查询"><a href="#十二，多表查询" class="headerlink" title="十二，多表查询"></a>十二，多表查询</h1><h2 id="1，查询语法"><a href="#1，查询语法" class="headerlink" title="1，查询语法"></a>1，查询语法</h2><p>​select </p><p>​列名列表</p><p>​from</p><p>​表名列表</p><p>​where…</p><p>笛卡尔积:有两个集合A和B，取这两个集合的所有组成情况。</p><p>如集合一为{(a,1)（b,2）}集合二为{1,2,3}</p><p>查询后变成  {(a,1)（a,2）（b,2）（b,1）（a,3）（b,3）}</p><p>要完成多表查询，需要消除无用的数据</p><h2 id="2-内连接查询"><a href="#2-内连接查询" class="headerlink" title="2,内连接查询:"></a>2,内连接查询:</h2><h3 id="①隐式内连接-使用where消除"><a href="#①隐式内连接-使用where消除" class="headerlink" title="①隐式内连接:使用where消除"></a>①隐式内连接:使用where消除</h3><p>语法: select 字段列表 from 表名1, 表名2 </p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-26 164632.png)</p><h3 id="②显式内连接"><a href="#②显式内连接" class="headerlink" title="②显式内连接:"></a>②显式内连接:</h3><p>语法: select 字段列表 from 表名1 [innner] join 表名2 on</p><p>[]:表示可选</p><p>例如:</p><p>​select * from emp inner join dept on emp .<code>dept_id</code>&#x3D;dept.<code>id</code>;</p><p>​select* from emp join dept on emp.<code>dept_id</code>&#x3D;dept.<code>id</code>;</p><p>SELECT *</p><p>FROM table1 </p><p>JOIN table2 </p><p>ON table1.column &#x3D; table2.column;</p><p>在这个例子中，<code>JOIN</code> 关键字后面跟着 <code>ON</code> 条件，用于指定连接条件。这种方式清晰明了，易于阅读和理解。</p><h3 id="③内连接查询-注意"><a href="#③内连接查询-注意" class="headerlink" title="③内连接查询:注意"></a>③内连接查询:注意</h3><p>1,从哪些表中查询数据</p><p>2,条件是什么</p><p>3，查询那些字段</p><h2 id="3，外链接查询"><a href="#3，外链接查询" class="headerlink" title="3，外链接查询:"></a>3，外链接查询:</h2><h3 id="①-左外连接"><a href="#①-左外连接" class="headerlink" title="①,左外连接:"></a>①,左外连接:</h3><p>​语法:select 字段列表 from 表1 left [outer] join表2 on 条件;</p><p>​查询的是左表所有数据(可以不用满足条件)以及其交集部分。</p><h3 id="②-右外连接"><a href="#②-右外连接" class="headerlink" title="②,右外连接;"></a>②,右外连接;</h3><p>​语法:select 字段列表 from 表1 right [outer] join表2 on 条件;</p><p>​查询的是右表所有数据(可以不用满足条件)以及其交集部分。</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-26 173133.png)</p><h3 id="③，子查询"><a href="#③，子查询" class="headerlink" title="③，子查询:"></a>③，子查询:</h3><p>​概念:查询中嵌套查询，称嵌套查询为子查询</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-26 173941.png)</p><p><strong>子查询情况1</strong>:子查询的结果是单行单列的:</p><p>​子查询可以是作为条件，使用运算符去判断。</p><p>​运算符:&gt; &gt; &#x3D; &lt; &lt;&#x3D; &#x3D;</p><p>​查询员工工资小于平均工资的人</p><p>​select * from emp where emp.salary&lt; (select avg(salary) from emp);</p><p>​</p><p><strong>子查询情况2</strong>:子查询的结果是多行单列的:</p><p>​子查询可以作为条件，使用运算符in来判断</p><p>​查询财务部和市场部所有的员工信息:</p><p>​select id from dept where name &#x3D; <code>财务部</code>or name &#x3D; <code>市场部</code>；</p><p>​select * from emp where dept_id &#x3D; 3 or dept_id&#x3D;2;</p><p>·子查询</p><p>select * from emp where dept_id in (select id from dept where name &#x3D; <code>财务部</code>or name &#x3D;<code>市场部</code>)</p><p><strong>子查询情况3</strong>:子查询的结果是多行多列的:</p><p>​子查询可以作为一张虚拟表</p><p>​查询员工入职日期是2011-11-11日之后的员工信息和部门信息</p><p>​普通内连接</p><p>​select*from emp t1,dept t2 where t1.<code>dept_id</code>&#x3D;t2.<code>id </code>and t1.<code>join_data</code>&gt;<code>2011-11-11</code></p><p>​子查询</p><p>​select * from dept t1,(select * from emp where emp.<code>join_data</code>&gt;<code>2011-11-11</code>) t2 where t1.id &#x3D; t2</p><p>.dept_id;</p><p>练习:72-75</p><h1 id="十三-数-Sql-事务"><a href="#十三-数-Sql-事务" class="headerlink" title="十三(数-&gt;Sql)事务"></a>十三(数-&gt;Sql)事务</h1><h2 id="1，基本介绍"><a href="#1，基本介绍" class="headerlink" title="1，基本介绍"></a>1，基本介绍</h2><h3 id="①概念"><a href="#①概念" class="headerlink" title="①概念:"></a>①概念:</h3><p>​如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</p><h3 id="②操作"><a href="#②操作" class="headerlink" title="②操作:"></a>②操作:</h3><p>​1,开启事务:start transaction;</p><p>​2,回滚:rollback(回到开始相当没执行)</p><p>​3,提交:commit</p><p>​他们都需要你手动提交–enter</p><p>​4，Mysql数据库中事务默认自动提交</p><p>​oracle 数据库默认是手动提交事务</p><p>​一条DMl(增删改)语句会自动提交一次事务。</p><p>​事务提交的两种方式:</p><p>​自动提交:</p><p>​mysql就是自动提交的</p><p>​一条DMl(增删改)语句会自动提交一次事务</p><p>​手动提交:</p><p>​需要先开启事务，在提交</p><p>​修改事务的默认提交方式:select @@autocommit;—-1代表自动提交   0代表手动提交</p><p>​修改默认提交方式: set @@autocommit &#x3D; 0</p><p>​<strong>手动提交必须加commit</strong></p><h2 id="2，四大特征"><a href="#2，四大特征" class="headerlink" title="2，四大特征"></a>2，四大特征</h2><p>1，原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。</p><p>2，持久性：当时物体提交或回滚后，数据库会持久化的保存数据。</p><p>3，隔离性；多个事务之间。相互依赖。</p><p>4，一致性实物操作前后，总量不变</p><h2 id="3，隔离级别-了解"><a href="#3，隔离级别-了解" class="headerlink" title="3，隔离级别(了解)"></a>3，隔离级别(了解)</h2><h3 id="①概念："><a href="#①概念：" class="headerlink" title="①概念："></a>①概念：</h3><p>多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题</p><p>②存在问题：</p><p>1，脏读：一个事务，读取到另一个事务中没有提交的数据。</p><p>2，不可重复读：在同一个事务中，两次读取到的数据不一样。</p><p>3，幻读；一个事务操作(dml)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改</p><h3 id="③隔离级别"><a href="#③隔离级别" class="headerlink" title="③隔离级别;"></a>③隔离级别;</h3><p>1，read uncommited:读未提交</p><p>​产生问题:1,2,3</p><p>2,read commited:读已提交（Oracle）</p><p>​产生的问题：2,3</p><p>3，repeatable read:可重复读（mysql默认）</p><p>​产生的问题：3</p><p>4.serializable：串行化</p><p>​可以解决所有问题</p><p>注意：隔离级别越小安全性越低，但效率越高</p><p>数据库查询隔离级别:</p><p>​select @@tx_isolation;</p><p>数据库设置隔离级别：</p><p>​        set global transaction isolation level 级别字符串；</p><h1 id="十四-数-Sql-DCL"><a href="#十四-数-Sql-DCL" class="headerlink" title="十四.(数-&gt;Sql)DCL"></a>十四.(数-&gt;Sql)DCL</h1><p>管理用户，授权</p><p>引号（&#96;）通常用于标识数据库对象的名称，如表名、列名等。当您需要引用特殊字符或者保留字作为对象名时，就需要使用引号。</p><h2 id="1，管理用户"><a href="#1，管理用户" class="headerlink" title="1，管理用户"></a>1，管理用户</h2><h3 id="①，添加用户"><a href="#①，添加用户" class="headerlink" title="①，添加用户:"></a>①，添加用户:</h3><p>create user <code>用户名</code>@<code>主机名</code>  identified by <code>密码</code>;</p><h3 id="②，删除用户"><a href="#②，删除用户" class="headerlink" title="②，删除用户:"></a>②，删除用户:</h3><p>drop user <code>用户名</code>@<code>主机名</code>；</p><h3 id="③，修改用户密码："><a href="#③，修改用户密码：" class="headerlink" title="③，修改用户密码："></a>③，修改用户密码：</h3><p>update user set password &#x3D; password(<code>新密码</code>) where user &#x3D; <code>用户名</code>；</p><p>或者set password for<code>用户名</code>@<code>主机名</code>&#x3D;password(`新密码`)；</p><p>mysql假如忘记root密码</p><p>1，cmd—–&gt;net stop mysql 停止mysql服务</p><p>​需要管理员运行该cmd</p><p>2，使用无验证方式启动mysql服务:mysql–skip-grant-tables</p><p>注意不要关掉先前的cmd窗口</p><p>3,打开新的cmd窗口，直接输入mysql，敲回车。就可以登录成功</p><p>4,use mysql;</p><p>5,update user set password &#x3D; password(`你的新密码`) where user &#x3D;`root`;</p><p>6,关闭两个窗口</p><p>7，打开任务管理器·，手动结束mysqld.exe 的进程</p><p>8，启动mysql服务。</p><p>9，使用新密码登录。</p><h3 id="④，查询用户："><a href="#④，查询用户：" class="headerlink" title="④，查询用户："></a>④，查询用户：</h3><p>​1,切换到mysql数据库</p><p>​use mysql;</p><p>​2,查询user表</p><p>​select * from user</p><p>​通配符:%表示可以在任意主机使用用户登录数据库</p><h2 id="2，权限管理："><a href="#2，权限管理：" class="headerlink" title="2，权限管理："></a>2，权限管理：</h2><p>①查询权限:</p><p>​show grants for `用户名`@`主机名&#96;;</p><p>​show grants for `list`@&#96;%;</p><p>②授予权限:</p><p>​grant 权限列表 on数据库.表名 to <code>用户名</code>@<code>主机名</code>；</p><p>​grant select on db3.accout to `list`@`%&#96;;</p><p>​可以查询db3中的accout表</p><p>​权限:select,delete,update</p><p>​给张三赋予所有权限，在任意数据库任意表上</p><p>​grant all on *.* to `zhangsan`@`localhost&#96;;</p><p>③撤销权限:</p><p>​撤销权限:</p><p>revoke 权限列表 on 数据库名.表名 from `用户名`@`主机名`;</p><p>revoke update on db3.`account` from `list`@`%`;</p><h1 id="十五-数-JDBC"><a href="#十五-数-JDBC" class="headerlink" title="十五.(数)JDBC"></a>十五.(数)JDBC</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1,概念"></a>1,概念</h2><p>:java database connectivity java数据库连接，java语言操作数据库</p><p>本质:其实是官方(sun公司)定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口(jdbc)编程，真正执行的代码是驱动jar包中的实现类</p><p>​person接口          work类             person p&#x3D;new worker();</p><p>连接对象里的方法帮助你用Java和sql取得练习</p><h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2,快速入门;"></a>2,快速入门;</h2><p>​步骤:</p><p>1,导入驱动jar包</p><p>2，注册驱动</p><p>Class.forName()</p><p>3，获取数据库连接对象 Collection</p><p>4，定义sql</p><p>5，获取执行sql语句的对象 statement</p><p>6，执行sql,接受返回结果</p><p>7，处理结果</p><p>8，释放资源</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 112642.png)</p><p>root,”root”)</p><ul><li>   说明<br>第一步：注册驱动                     作用：告诉Java程序，即将要连接的是哪个品牌的数据库<br>第二步：获取连接                     表示JVM的进程和数据库进程之间的通道打开了，这属于进程之间的通信使用完之后一定要关闭通道<br>第三步：获取数据库操作对象        专门执行sql语句的对象<br>第四步：执行SQL语句                DQL DML…<br>第五步：处理查询结果集           只有当第四步执行的是select语句的时候，才有这第五步处理查询结果集<br>第六步：释放资源                      使用完资源之后一定要关闭资源。Java和数据库属于进程间的通信，开启之后一定要关闭</li></ul><h2 id="3-详解各个对象"><a href="#3-详解各个对象" class="headerlink" title="3,详解各个对象:"></a>3,详解各个对象:</h2><h3 id="①DriverManager-驱动管理对象"><a href="#①DriverManager-驱动管理对象" class="headerlink" title="①DriverManager:驱动管理对象"></a>①DriverManager:驱动管理对象</h3><p>​功能：</p><h4 id="1，注册驱动-告诉程序该使用哪一个数据库驱动jar"><a href="#1，注册驱动-告诉程序该使用哪一个数据库驱动jar" class="headerlink" title="1，注册驱动:告诉程序该使用哪一个数据库驱动jar"></a>1，注册驱动:告诉程序该使用哪一个数据库驱动jar</h4><p>​static void registerDriver(Driver driver):注册与给定的驱动程序DriverManager。</p><p>​写代码使用:Class.forName(“com.mysql.jdbc.Driver”);</p><p>​注意:mysql5之后的驱动Jar包可以省略注册驱动的步骤</p><h4 id="2，获取数据库连接："><a href="#2，获取数据库连接：" class="headerlink" title="2，获取数据库连接："></a>2，获取数据库连接：</h4><p>​方法: static  Collection getcollection(String a,String b,String c)</p><p>​参数:</p><p>​a：指定连接的路径</p><p>​语法:jdbc:mysql:&#x2F;&#x2F;ip地址(域名):端口号&#x2F;数据库名称</p><p>​例子:jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db3</p><p>localhost<code> 是一个特殊的网络地址，表示本地主机，即运行应用程序的机器本身。在大多数操作系统中，localhost</code> 地址映射到127.0.0.1 IPv4 地址</p><p>细节:如果连接是本机mysql服务器，并且mysql服务器默认端口是3306,则url可以简写为：jdbc:mysql:&#x2F;&#x2F;&#x2F;数据库名称</p><p>​b：用户名:</p><p>​c：密码</p><h3 id="②Connection-数据库连接对象"><a href="#②Connection-数据库连接对象" class="headerlink" title="②Connection:数据库连接对象"></a>②Connection:数据库连接对象</h3><h4 id="1，功能"><a href="#1，功能" class="headerlink" title="1，功能:"></a>1，功能:</h4><p>​1，获取执行sql 的对象 </p><p>​Statement createStatement()</p><p>​preparedStatement prepareStatement(String sql)</p><h4 id="2，管理事务"><a href="#2，管理事务" class="headerlink" title="2，管理事务:"></a>2，管理事务:</h4><p>​开启事务:void setAutoCommit(boolean autoCommit):调用该方法设置参数为false，即开启事务</p><p>​提交事务:commit()</p><p>​回滚事务:rollback()</p><h3 id="③Statement-执行sql的对象（执行）"><a href="#③Statement-执行sql的对象（执行）" class="headerlink" title="③Statement:执行sql的对象（执行）"></a>③Statement:执行sql的对象（执行）</h3><h4 id="1-执行Sql（少用）"><a href="#1-执行Sql（少用）" class="headerlink" title="1,执行Sql（少用）"></a>1,执行Sql（少用）</h4><p>​1,boolean execute(String sql)</p><p>​           执行给定的sql语句这可能会返回多个结果</p><p>​2,int executeUpdate(String sql) </p><p>​执行DML(insert,update,delete)语句，DDL(create(不经常用),alter,drop)语句</p><p>​返回值为影响的行数，可以通过这个影响的行数判断DML语句是否执行成功，反之，则失败。</p><p>​3,ResultSet executeQuery(String sql)   :执行DQL(select)语句</p><h4 id="2，练习"><a href="#2，练习" class="headerlink" title="2，练习:"></a>2，练习:</h4><p>​1,account表 添加一条记录</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 163527.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 163554.png)</p><p>​2,account表 修改记录</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 164614.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 164705.png)</p><p>​3,account表 删除一条记录</p><p>​ </p><p>​</p><h3 id="④ResultSet-结果集对象（封装查询结果）"><a href="#④ResultSet-结果集对象（封装查询结果）" class="headerlink" title="④ResultSet:结果集对象（封装查询结果）"></a>④ResultSet:结果集对象（封装查询结果）</h3><p>​next():游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false,不是返回true，最初位于第一行之前</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 170849.png)</p><p>getxxx(参数):获取数据</p><p>​xxx:代表返回值数据类型      如: int  getInt(),String getString()</p><pre><code>         参数:</code></pre><p>​1,int:代表列名的编号，从1开始如:getString(1)</p><p>​2,String:代表列名称。如: getString(“balance”)</p><p>​括号里填string表列名，填数字代表第几列</p><p>​3,ResultSet executeQuery(String sql)   :执行DQL(select)语句</p><h5 id="一般先查询在移动游标最后获取数据"><a href="#一般先查询在移动游标最后获取数据" class="headerlink" title="一般先查询在移动游标最后获取数据"></a>一般先查询在移动游标最后获取数据</h5><p>注意</p><p>​使用步骤:</p><p>​1,游标向下移动一行</p><p>​2，判断是否有数据</p><p>​3，获取数据</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 175757.png)</p><p>练习:查询emp表的数据将其封装成对像，然后装载集合，返回。并打印</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 200652.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 200353.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 200959.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 201048.png)</p><p>![ ](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 201230.png)</p><h3 id="⑤PreparedStatement-执行sql对象"><a href="#⑤PreparedStatement-执行sql对象" class="headerlink" title="⑤PreparedStatement:执行sql对象"></a>⑤PreparedStatement:执行sql对象</h3><p>与在执行对象Statement createStatement() 相对</p><pre><code>  1，sql注入问题:在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题  </code></pre><p>​1，输入用户随便，输入密码:a`or`a`&#x3D;&#96;a</p><p>​2,sql:select*from user where username &#x3D; `fhdsjkf` and password &#x3D; `a` or `a`&#x3D;`a`</p><p>​2,解决sql注入问题:使用PreparedStatement对象来解决</p><p>​3，预编译的sql:参数使用?作为占位符</p><p>​4，步骤:</p><p>​1，导入驱动jar包 mysql-connector-java-5.1.37-bin.jar</p><p>​2,注册驱动</p><p>​3，获取数据库连接对象Collection</p><p>​4,定义sql</p><p>​注意:sql的参数使用?作为占位符。如:select * from user where username &#x3D; ? and password &#x3D; ?;</p><p>​5，获取执行sql语句的对象：preparedStatement    Collection.prepareStatement(String sql)</p><p>​6，给？赋值：</p><p>​方法：setXXX(参数1，参数2)</p><p>​参数1：？的位置编号从1开始</p><p>​参数2:？的值</p><p>​7，执行sql,接受返回结果，不需要传递sql语句</p><p>​8，处理结果</p><p>​9，释放资源</p><p>​可以防止sql注入</p><p>​效率更高</p><h5 id="sql语句增添占位符，多了一部设置参数"><a href="#sql语句增添占位符，多了一部设置参数" class="headerlink" title="sql语句增添占位符，多了一部设置参数"></a>sql语句增添占位符，多了一部设置参数</h5><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 080454.png)</p><p>与上面相对比普通的</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 112642.png)</p><p>抽取JDBC工具类</p><p>目的:简化书写</p><p>分析:</p><p>1,注册驱动也抽取</p><p>2，抽取一个方法连接对象</p><p>需求:不想传递参数(麻烦)，还得保证工具类的通用性</p><p>解决:配置文件</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 210049.png)</p><p>​jbdc.properties</p><p>​url&#x3D;</p><p>​user&#x3D;</p><p>​password&#x3D;</p><p>这是在获取路径配置文件</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 205344.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 210252.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 210012.png)</p><p>3，抽取一个方法释放资源</p><p>本质是写了个类，定义了几个方法，又创建了个文件，来进行参数替换即配置文件</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 210352.png)</p><p>![屏幕截图 2024-07-27 210422](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 210422.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 210656.png)</p><p>![屏幕截图 2024-07-27 210502](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 210502.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-27 211043.png)</p><h2 id="4，JDBC控制事务"><a href="#4，JDBC控制事务" class="headerlink" title="4，JDBC控制事务"></a>4，JDBC控制事务</h2><h3 id="①概念-1"><a href="#①概念-1" class="headerlink" title="①概念"></a>①概念</h3><p>如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败</p><h3 id="②操作-1"><a href="#②操作-1" class="headerlink" title="②操作:"></a>②操作:</h3><p>​1,开启事务:</p><p>​2,回滚:</p><p>​3,提交:</p><h3 id="③使用Collection对象来管理事务"><a href="#③使用Collection对象来管理事务" class="headerlink" title="③使用Collection对象来管理事务"></a>③使用Collection对象来管理事务</h3><p>​开启事务:setAutoCommit(boolean autoCommit):调用该方法设置参数为false,即开启事务</p><p>​在执行sql之前开启事务</p><p>​回滚:commit()</p><p>​当所有sql都执行完提交事务</p><p>​提交:rollback()</p><p>​在catch中回滚事务</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 081536.png)</p><p>![屏幕截图 2024-07-29 081608](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 081608.png)</p><p>![屏幕截图 2024-07-29 081623](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 081623.png)</p><h2 id="5，数据库连接池"><a href="#5，数据库连接池" class="headerlink" title="5，数据库连接池"></a>5，数据库连接池</h2><h3 id="①概念-其实就是一个容器-集合-，存放数据库连接的容器。"><a href="#①概念-其实就是一个容器-集合-，存放数据库连接的容器。" class="headerlink" title="①概念:其实就是一个容器(集合)，存放数据库连接的容器。"></a>①概念:其实就是一个容器(集合)，存放数据库连接的容器。</h3><p>​当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库，从容器中获取连接对象，用户访问之后，会将连接对象归还给容器。</p><h3 id="②好处"><a href="#②好处" class="headerlink" title="②好处:"></a>②好处:</h3><p>​1，节约资源</p><p>​2，用户访问高效</p><h3 id="③实现"><a href="#③实现" class="headerlink" title="③实现"></a>③实现</h3><h4 id="1，标准接口-DataSource-javax-sql包下的"><a href="#1，标准接口-DataSource-javax-sql包下的" class="headerlink" title="1，标准接口:DataSource  javax.sql包下的"></a>1，标准接口:DataSource  javax.sql包下的</h4><p>​1，方法:</p><p>​获取连接:getConnection()</p><p>​归还连接:如果连接对象Connection是从连接池中获取的，那么调用Connection.close(),则不会关闭连接了。而是归还连接</p><h4 id="2，一般我们不去实现它，有数据库厂商来实现"><a href="#2，一般我们不去实现它，有数据库厂商来实现" class="headerlink" title="2，一般我们不去实现它，有数据库厂商来实现"></a>2，一般我们不去实现它，有数据库厂商来实现</h4><p>​1，C3P0:数据库连接池技术</p><p>​2，Druid:数据库连接池实现技术，由阿里巴巴提供的</p><h3 id="④C3P0-数据库连接池技术"><a href="#④C3P0-数据库连接池技术" class="headerlink" title="④C3P0:数据库连接池技术"></a>④C3P0:数据库连接池技术</h3><p>​步骤:</p><p>​1,导入jar包</p><p>注:jar包和xml文件不是一个</p><p>jar包需要被导入一个”目录“中,xml直接复制到src文件下就行</p><p>​2,定义配置文件:</p><p>​名称:c3p0.properties或者 c3p0-config.xml</p><p>​路径:直接将文件放在src目录下即可。</p><p>​3,创建核心对象 数据库连接对象: ComboPooledDataSource</p><p>​4,获取连接:getConnection</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 092409.png)</p><p>jar包在libs中</p><h3 id="⑤配置演示"><a href="#⑤配置演示" class="headerlink" title="⑤配置演示"></a>⑤配置演示</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 102204.png)</p><p>一般都在xml文件中直接修改参数，使用默认配置</p><p>还可以在xml文件中创建一个新的配置</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 102345.png)</p><p>展开后</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 102512.png)</p><p>在main函数中获取连接</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 102619.png)</p><h3 id="⑤Druid-数据库连接池实现技术"><a href="#⑤Druid-数据库连接池实现技术" class="headerlink" title="⑤Druid:数据库连接池实现技术"></a>⑤Druid:数据库连接池实现技术</h3><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h4><p>​1,导入jar包 druid-1.jar</p><p>​2,定义配置文件:</p><p>​是properties形式的</p><p>​可以叫任意名称，可以放在任意目录下</p><p>​3，获取数据库连接池对象:通过工厂类来获取:  DruidDataSourceFactory</p><p>​4，获取连接:getConnection</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 104457.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 104430.png)</p><h3 id="⑦定义工具类"><a href="#⑦定义工具类" class="headerlink" title="⑦定义工具类"></a>⑦定义工具类</h3><p>1，定义一个类  JDBCUtils</p><p>2，提供静态代码块加载配置文件，初始化连接池对象</p><p>3，提供方法</p><p>​1，获取连接方法:通过数据库连接池获取连接</p><p>​2，释放资源</p><p>​3，获取连接池的方法</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 105949.png)</p><p>![屏幕截图 2024-07-29 110019](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 110019.png)</p><p>![屏幕截图 2024-07-29 110039](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 110039.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 110101.png)</p><p>![屏幕截图 2024-07-29 110123](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 110123.png)</p><h4 id="运用工具类"><a href="#运用工具类" class="headerlink" title="运用工具类"></a>运用工具类</h4><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 110835.png)</p><h2 id="6，Spring-JDBC"><a href="#6，Spring-JDBC" class="headerlink" title="6，Spring JDBC"></a>6，Spring JDBC</h2><h3 id="①概念-2"><a href="#①概念-2" class="headerlink" title="①概念"></a>①概念</h3><p>Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发</p><h3 id="②步骤"><a href="#②步骤" class="headerlink" title="②步骤:"></a>②步骤:</h3><p>​1,导入jar包</p><p>​2,创建jdbcTemplate对象。依赖于数据源DataSource</p><p>​JdbcTemplate template &#x3D; new JdbcTempalte(ds);</p><p>​3,调用JdbcTemplate的方法来完成CRUD的操作</p><p>​update():执行DML语句。增删改语句</p><p>​queryForMap():查询结果将结果封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合</p><p>​注意:这个方法查询的结果集长度只能是1</p><p>​queryForList():查询结果将结果封装为list对象</p><p>​注意:将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 152734.png)</p><p>​query():查询结果，将结果封装为JavaBean对象</p><p>​注意:query的参数RowMapper</p><p>​一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装</p><p>​new BeanPropertyRowMapper&lt;类型&gt;(类型.class)</p><p>​</p><p>​querryFoObject:查询结果，将结果封装为对象</p><p>​一般用于聚合函数的查询</p><pre><code>             注:update(sql语句,参数）就不需要setString来赋值了</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE users SET name = ? WHERE id = ?&quot;</span>;</span><br><span class="line">   jdbcTemplate.update(sql, name, id);</span><br></pre></td></tr></table></figure><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 113034.png)</p><p>基本数据类型不能为null,只能为0</p><h1 id="十六-web-，web概述"><a href="#十六-web-，web概述" class="headerlink" title="十六(web)，web概述"></a>十六(web)，web概述</h1><h2 id="1，javaweb"><a href="#1，javaweb" class="headerlink" title="1，javaweb:"></a>1，javaweb:</h2><p>​使用Java语言开发基于互联网的项目</p><h2 id="2，软件架构"><a href="#2，软件架构" class="headerlink" title="2，软件架构"></a>2，软件架构</h2><h3 id="①C-s"><a href="#①C-s" class="headerlink" title="①C&#x2F;s:"></a>①C&#x2F;s:</h3><p>​Client&#x2F;Server客户端&#x2F;服务器架构</p><p>​在用户本地有一个客户端程序，在远程有一个服务器端程序</p><p>​如:qq,迅雷…</p><p>​优点:</p><p>​1，用户体验好</p><p>​缺点:</p><p>​1,开发，安装，部署，维护 麻烦</p><h3 id="②B-S"><a href="#②B-S" class="headerlink" title="②B&#x2F;S:"></a>②B&#x2F;S:</h3><p>​Browser&#x2F;Server 浏览器&#x2F;服务器端</p><p>​只需要一个浏览器，用户通过不同的网址(URL)，客户访问不同的服务器端程序</p><p>​优点:</p><p>​1,开发，安装，部署，维护 简单</p><p>​缺点:</p><p>​1,如果应用过大，用户的体验可能会收到影响</p><p>​ 2，对硬件要求过高</p><h2 id="3，B-S详解"><a href="#3，B-S详解" class="headerlink" title="3，B&#x2F;S详解:"></a>3，B&#x2F;S详解:</h2><p>​资源分类:</p><h3 id="①-静态资源-如新闻"><a href="#①-静态资源-如新闻" class="headerlink" title="①,静态资源(如新闻):"></a>①,静态资源(如新闻):</h3><p>​使用静态网页开发技术发布的资源</p><p>​特点:</p><p>​所有用户访问，得到的结果是一样的。</p><p>​如:文本，图片，音频，视频，HTML,CSS,JavaScript</p><p>​如果用户请求得是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</p><h3 id="②-动态资源"><a href="#②-动态资源" class="headerlink" title="②,动态资源:"></a>②,动态资源:</h3><p>​使用动态网页及时发布的资源</p><p>​特点:</p><p>​如果用户访问，得到的结果可能不一样。</p><p>​如:jsp&#x2F;servlet,php,asp…</p><p>​如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器</p><h3 id="③静态资源"><a href="#③静态资源" class="headerlink" title="③静态资源"></a>③静态资源</h3><p>​HTML:用于搭建基础网页，展示网页中的信息</p><p>​CSS:用于美化页面，布局页面</p><p>​JavaScript:控制页面的元素</p><h1 id="十七-web-，HTML"><a href="#十七-web-，HTML" class="headerlink" title="十七(web)，HTML"></a>十七(web)，HTML</h1><h2 id="1-概念-是最基础的网页开发语言"><a href="#1-概念-是最基础的网页开发语言" class="headerlink" title="1,概念:是最基础的网页开发语言"></a>1,概念:是最基础的网页开发语言</h2><p>​Hyper Text Mark Language 超文本标记语言</p><p>​超文本:</p><p>​超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本</p><p>​标记语言</p><p>​由标签构成的语言。&lt;标签名称&gt;如html,xml</p><p>​标记语言不是编程语言</p><h2 id="2，快速入门"><a href="#2，快速入门" class="headerlink" title="2，快速入门:"></a>2，快速入门:</h2><h3 id="①语法-4"><a href="#①语法-4" class="headerlink" title="①语法:"></a>①语法:</h3><p>​1,html文档后缀名 .html或者.hml</p><p>​2,标签分为</p><p>​1，围堵标签:有开始标签和结束标签。如&lt;html&gt;&lt;&#x2F;html&gt;</p><p>​3,标签可以嵌套:</p><p>​需要正确嵌套,不能你中有我，我中有你</p><p>​错误:&lt;a&gt;&lt;b&gt;&lt;&#x2F;a&gt;&lt;&#x2F;b&gt;</p><p>​正确:&lt;a&gt;&lt;b&gt;&lt;&#x2F;b&gt;&lt;&#x2F;a&gt;</p><p>​4, 在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</p><p>​5，html的标签不区分大小写，但是建议使用小写。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 193528.png)</p><h2 id="3，标签学习"><a href="#3，标签学习" class="headerlink" title="3，标签学习"></a>3，标签学习</h2><h3 id="①文件标签-构成html最基本的标签"><a href="#①文件标签-构成html最基本的标签" class="headerlink" title="①文件标签:构成html最基本的标签"></a>①文件标签:构成html最基本的标签</h3><p>自闭合（self-closing）是指在某些编程语言或标记语言中，元素或标签可以仅由一个标签表示，而不需要显式的结束标签。自闭合标签在XML中必须写&#x2F;，像这样需要显式地关闭标签，因此应该写作 <code>&lt;br /&gt;</code></p><p>现在我定义自闭合为1,有结束的定义为0</p><ul><li>html:html文档的跟标签</li><li>head:头标签。用于指定html文档的一些属性。引入外部的资源</li><li>title:标题标签。</li><li>body:体标签</li><li>&lt;!DOCTYPE&gt;:html5中定义该文档是html文档</li></ul><h3 id="②文本标签-和文本有关的标签"><a href="#②文本标签-和文本有关的标签" class="headerlink" title="②文本标签:和文本有关的标签"></a>②文本标签:和文本有关的标签</h3><h4 id="1-一定要加–和–否则会没用或者后面内容也成注释"><a href="#1-一定要加–和–否则会没用或者后面内容也成注释" class="headerlink" title="1&lt;!– 注释内容 –&gt;:一定要加–和–否则会没用或者后面内容也成注释"></a>1&lt;!– 注释内容 –&gt;:一定要加–和–否则会没用或者后面内容也成注释</h4><h4 id="0-到-标题标签-一般使用像这样你好，数字越大标题越小"><a href="#0-到-标题标签-一般使用像这样你好，数字越大标题越小" class="headerlink" title="0&lt;h1&gt; 到 &lt;h6&gt;标题标签:一般使用像这样&lt;h1&gt;你好&lt;&#x2F;h1&gt;，数字越大标题越小"></a>0&lt;h1&gt; 到 &lt;h6&gt;标题标签:一般使用像这样&lt;h1&gt;你好&lt;&#x2F;h1&gt;，数字越大标题越小</h4><h4 id="0-包裹段落，和其他段落分开-内容"><a href="#0-包裹段落，和其他段落分开-内容" class="headerlink" title="0&lt;p&gt;:包裹段落，和其他段落分开  &lt;p&gt;内容&lt;&#x2F;p&gt;"></a>0&lt;p&gt;:包裹段落，和其他段落分开  &lt;p&gt;内容&lt;&#x2F;p&gt;</h4><h4 id="1换行"><a href="#1换行" class="headerlink" title="1&lt;br&gt;换行:"></a>1&lt;br&gt;换行:</h4><h4 id="1显示一条水平线"><a href="#1显示一条水平线" class="headerlink" title="1&lt;hr&gt;显示一条水平线&lt;hr &#x2F;&gt;"></a>1&lt;hr&gt;显示一条水平线&lt;hr &#x2F;&gt;</h4><p>​属性 </p><p>​color:颜色</p><p>​width：长度</p><p>​size:高度</p><p>​align:对齐方式：center:居住left：左对齐right: 右对齐</p><h4 id="0-字体加粗"><a href="#0-字体加粗" class="headerlink" title="0&lt;b&gt;:字体加粗"></a>0&lt;b&gt;:字体加粗</h4><h4 id="0：字体斜体"><a href="#0：字体斜体" class="headerlink" title="0&lt;i&gt;：字体斜体"></a>0&lt;i&gt;：字体斜体</h4><h4 id="0：字体标签-过时的"><a href="#0：字体标签-过时的" class="headerlink" title="0&lt;font&gt;：字体标签 过时的"></a>0&lt;font&gt;：字体标签 过时的</h4><h4 id="0：文本居中"><a href="#0：文本居中" class="headerlink" title="0&lt;center&gt;：文本居中"></a>0&lt;center&gt;：文本居中</h4><p>​属性:</p><p>​color:颜色</p><p>​size:大小</p><p>​face:字体</p><h4 id="nbsp表示空格"><a href="#nbsp表示空格" class="headerlink" title="%nbsp表示空格"></a>%nbsp表示空格</h4><h4 id="属性定义："><a href="#属性定义：" class="headerlink" title="属性定义："></a>属性定义：</h4><p>​1，color:</p><p>​1，英文单词:red,green,blue</p><p>​2，rgb(值1，值2，值3)：值的范围：0~255 如rgb(0,0,255)</p><p>​3，#值1值2值3：值的范围：00~FF之间。如：color&#x3D;“#FF00FF”</p><p>​2,width:</p><p>​1,数值:width&#x3D;`20&#96;,数值的单位，默认是 px(像素)</p><p>​2,数组%：占比相对于父元素的比例 如%50</p><h3 id="③图片标签"><a href="#③图片标签" class="headerlink" title="③图片标签:"></a>③图片标签:</h3><p>​&lt;img src&#x3D;“路径”&#x2F; &gt;</p><p>​ 以.开头的路径</p><p>​.&#x2F;:代表当前目录    .&#x2F;image&#x2F;1.jpg            </p><p>​       </p><p>​..&#x2F;: 代表上一级目录</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-29 215309.png)</p><p>如，以HTML4来看day06代表上一级目录，html代表当前目录，而image明显是上一级目录</p><h3 id="④列表标签："><a href="#④列表标签：" class="headerlink" title="④列表标签："></a>④列表标签：</h3><p>​有序列表:</p><p>​0ol:自动排序</p><p>​0li:通常被ol包裹在一起代表一行。</p><p>​  无序列表:</p><p>​0ul:无序列表</p><p>​0        li：</p><h3 id="⑤链接标签："><a href="#⑤链接标签：" class="headerlink" title="⑤链接标签："></a>⑤链接标签：</h3><p>​0a:定义一个超链接</p><p>​属性:</p><p>​href:指定访问资源的URL(统一资源定位符)</p><p>​target:指定打开资源的方式</p><p>​_self:默认值,在当前页面打开</p><p>​_blank:在空白页面打开</p><p>​如![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-30 083214.png)</p><h3 id="⑥div和span"><a href="#⑥div和span" class="headerlink" title="⑥div和span:"></a>⑥div和span:</h3><p>​     0               div:每一个div占满一整行。块级标签</p><p>​     0                span:文本信息在一行展示，行内标签   内联标签</p><h3 id="⑦语义化标签："><a href="#⑦语义化标签：" class="headerlink" title="⑦语义化标签："></a>⑦语义化标签：</h3><p>​为了提高程序的可读性，提供了一些标签。</p><p>​1header:页眉</p><p>​1footer:页脚</p><h3 id="⑧表格标签"><a href="#⑧表格标签" class="headerlink" title="⑧表格标签:"></a>⑧表格标签:</h3><p>​0table:定义表格</p><p>​属性:border边框     width长度     cellpadding定义内容和单元格的距离            cellspacing:定义单元格之间的 距离。如果指定为0,则单元格的线会合为一条       bgcolor背景色   align对齐方式</p><p>​0tr:定义行</p><p>​他的属性只针对它包裹的那一行</p><p>​<strong>bgcolor</strong>:背景色  <strong>align</strong>:对齐方式</p><p>​0td:定义单 元格被包裹表示一个单元格</p><p>​属性 </p><p>​<strong>colspan</strong>:合并x列</p><p>​<strong>rowspan</strong>:合并x行</p><p>​0th:定义表头单元格被包裹表示一个表头单元格</p><p>​0  caption:表格标题</p><p>​0thead:表示表格的头部分</p><p>​0tbody:表示表格的体部分</p><p>​0tfoot:表示表格尾部分永远在下面</p><h2 id="4-表单标签"><a href="#4-表单标签" class="headerlink" title="4,表单标签:"></a>4,表单标签:</h2><h3 id="①表单概念"><a href="#①表单概念" class="headerlink" title="①表单概念:"></a>①表单概念:</h3><p>用于采集用户输入的数据的。用于和服务器进行交互</p><p>​使用的标签:</p><p>​0form:用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p><p>​属性:</p><p>​<strong>action</strong>:指定提交数据的URL</p><p>​<strong>method</strong>:指定提交方式   get和post是等号后的</p><p>​分类:一共7种，2种比较常见</p><p>​<strong>答案{</strong></p><p>​get:1，请求参数会在地址栏中显示。</p><p>​2，请求参数大小是有限制的。</p><p>​3，不太安全</p><p>​post:2，请求参数不会在地址栏中显示</p><p>​2，请求参数的大小没有限制</p><p>​3，安全</p><p>​<strong>}</strong></p><p>​表单中的数据要想被提交:必须指定其name属性</p><p>​用于定义</p><h3 id="②表单项标签"><a href="#②表单项标签" class="headerlink" title="②表单项标签:"></a>②表单项标签:</h3><h4 id="1input-可以通过type属性值，改变元素展示的样式"><a href="#1input-可以通过type属性值，改变元素展示的样式" class="headerlink" title="1input:可以通过type属性值，改变元素展示的样式"></a>1input:可以通过type属性值，改变元素展示的样式</h4><p>​属性:</p><p>​<strong>placeholder:</strong></p><p>​<strong>type</strong>:</p><p>​<strong>答案{</strong></p><p>​text:文本输入框 默认值 </p><p>​password:密码输入框</p><p>​radio:单选框 </p><p>​注意:</p><p>​1，要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样</p><p>​2，一般会给每一个单选框提供value属性，指定其被选择后提交的值</p><p>​3，checked属性，可以指定默认值</p><p>​checkbox:复选框</p><p>​注意:</p><p>​1,一般会给每一个单选框提供value属性，指定其被选中后提交的值</p><p>​2，checked属性，可以指定默认值</p><p>​file:文件选择框</p><p>​ hidden:隐藏域，用于提交一些信息</p><p>​submit:提交按钮</p><p>​button:普通按钮</p><p>​image:图片提交按钮</p><p>​注:src属性指定图片的路径</p><p>​</p><p>​<strong>}</strong></p><p>​0label:指定输入项的文字描述信息</p><p>​注:</p><p>​label的for属性一般会和 input的 id属性值对应，如果对应了，则点击label区域，会让input输入框获取焦点。 </p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-30 163111.png)</p><h4 id="0select-下拉列表"><a href="#0select-下拉列表" class="headerlink" title="0select:下拉列表"></a>0select:下拉列表</h4><p>​子元素: 0      option,指定列表项</p><h4 id="0-textarea，文本域"><a href="#0-textarea，文本域" class="headerlink" title="0                textarea，文本域"></a>0                textarea，文本域</h4><p>​<strong>{</strong></p><p>​**cols:**指定列数，每一行有多少</p><p>​<strong>rows</strong>:默认多少行</p><p>​<strong>}</strong></p><h4 id="C-Users-31502-Pictures-Screenshots-屏幕截图-2024-07-30-164158-png"><a href="#C-Users-31502-Pictures-Screenshots-屏幕截图-2024-07-30-164158-png" class="headerlink" title="![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-30 164158.png)"></a>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-30 164158.png)</h4><p>​</p><h1 id="十八-CSS页面美化和布局控制"><a href="#十八-CSS页面美化和布局控制" class="headerlink" title="十八.CSS页面美化和布局控制"></a>十八.CSS页面美化和布局控制</h1><h2 id="1-css概述"><a href="#1-css概述" class="headerlink" title="1,css概述"></a>1,css概述</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class=&quot;text&quot;&gt;This is a paragraph.&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>&lt;p&gt;</code> 元素具有 <code>text</code> 类名，所以我们可以在 <code>styles.css</code> 文件中定义一个 <code>.text</code> 类选择器，然后应用相应的样式。</p><p>​Cascading Style sheets 层叠样式表</p><p>​层叠:多个样式可以作用在同一个html的元素上，同时生效</p><h2 id="2，好处"><a href="#2，好处" class="headerlink" title="2，好处:"></a>2，好处:</h2><p>​1,功能强大</p><p>​2，将内容展示和样式控制分离</p><p>​降低耦合度。解耦</p><p>​让分工协作更容易</p><p>​提高工作效率</p><h2 id="3，CSS的使用"><a href="#3，CSS的使用" class="headerlink" title="3，CSS的使用:"></a>3，CSS的使用:</h2><p>​CSS与html结合方式:</p><h3 id="①内联样式（不推荐）"><a href="#①内联样式（不推荐）" class="headerlink" title="①内联样式（不推荐）:"></a>①内联样式（不推荐）:</h3><p>​在标签内使用style属性指定css代码</p><p>​如:&lt;div style&#x3D;“color:red”;&gt;hello css&lt;&#x2F;div&gt;</p><h3 id="②内部样式-只能在本html文件中使用"><a href="#②内部样式-只能在本html文件中使用" class="headerlink" title="②内部样式(只能在本html文件中使用):"></a>②内部样式(只能在本html文件中使用):</h3><p>​在head标签内，定义style标签，style标签的标签体内容就是css代码</p><p>​如![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-30 171901.png)</p><h2 id="③外部样式"><a href="#③外部样式" class="headerlink" title="③外部样式:"></a>③外部样式:</h2><p>​1，定义css资源文件</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-30 172329.png)</p><p>​2，在head标签内，定义link标签，引入外部的资源文件</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-30 172303.png)</p><p>​3,在body中使用</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-30 172452.png)</p><p>​注意:①②③种方式，css作用范围越来越大</p><p>​①,方式不常用，后期常用②,③</p><p>​第三种格式可写为</p><p>&lt;style&gt;</p><p>​@import “css&#x2F;a.css”;&#x2F;&#x2F;指的是路径&#x2F;文件</p><p>&lt;&#x2F;style&gt;</p><p>大多是用</p><p>.名字{方法体}</p><p>调用使用class&#x3D;“名字”</p><h2 id="4，css语法"><a href="#4，css语法" class="headerlink" title="4，css语法:"></a>4，css语法:</h2><p>​格式:</p><p>​选择器{</p><p>​属性名1:属性值1;</p><p>​属性名2:属性值2;</p><p>​….</p><p>​}</p><p>​选择器:筛选具有相似特征的元素</p><p>​注意:</p><p>​每一对属性需要使用;隔开，最后一对属性可以不加;</p><h2 id="5-选择器-筛选具有相似特征的元素"><a href="#5-选择器-筛选具有相似特征的元素" class="headerlink" title="5,选择器: 筛选具有相似特征的元素"></a>5,选择器: 筛选具有相似特征的元素</h2><p>​所谓选择器是定义了一个方法</p><p>​然后给其他语句做标记，做了标记的就用其中的方法</p><p>​元素指标签</p><p>​分类:</p><h3 id="①-基本选择器"><a href="#①-基本选择器" class="headerlink" title="①,基本选择器"></a>①,基本选择器</h3><h4 id="1-id选择器-选择器具体的id属性值的元素"><a href="#1-id选择器-选择器具体的id属性值的元素" class="headerlink" title="1,id选择器:选择器具体的id属性值的元素"></a>1,id选择器:选择器具体的id属性值的元素</h4><p>​语法:定义： #id属性值{}</p><p>​&lt;p id&#x3D;”A”&gt;段落1</p></p><pre><code>                              \&lt;p id=&quot;B&quot;&gt;段落1&lt;/p&gt;</code></pre><p>​      &lt;p id&#x3D;”C”&gt;段落1</p></p><p>​使用：id&#x3D;“id属性值”</p><p>​</p><h4 id="2-元素选择器-选择具有相同标签名称的元素"><a href="#2-元素选择器-选择具有相同标签名称的元素" class="headerlink" title="2,元素选择器:选择具有相同标签名称的元素"></a>2,元素选择器:选择具有相同标签名称的元素</h4><p>​语法:定义：标签名称{}</p><p>​</p><p>​注意:id选择器优先级高于元素选择器</p><h4 id="3-类选择器-选择具有相同class属性值的元素"><a href="#3-类选择器-选择具有相同class属性值的元素" class="headerlink" title="3,类选择器:选择具有相同class属性值的元素"></a>3,类选择器:选择具有相同class属性值的元素</h4><p>​语法:定义：.class属性值{}</p><p>​ &lt;p class&#x3D;”A”&gt;段落1</p></p><p>​        &lt;p class&#x3D;”B”&gt;段落1</p></p><p>​     &lt;p class&#x3D;”C”&gt;段落1</p></p><p>​使用: class&#x3D;“class属性值”</p><p>​  </p><p>​注意:类选择器优先级高于元素选择器</p><h3 id="②-扩展选择器："><a href="#②-扩展选择器：" class="headerlink" title="②,扩展选择器："></a>②,扩展选择器：</h3><h4 id="1，选择所有元素"><a href="#1，选择所有元素" class="headerlink" title="1，选择所有元素:"></a>1，选择所有元素:</h4><p>​语法: *{}</p><p>注:不需要像其他选择器那样指定元素类型</p><h4 id="2-并集选择器"><a href="#2-并集选择器" class="headerlink" title="2,并集选择器:"></a>2,并集选择器:</h4><p>​选择器1,选择器2{}</p><h4 id="3，子选择器-筛选选择器1元素下的选择器2元素"><a href="#3，子选择器-筛选选择器1元素下的选择器2元素" class="headerlink" title="3，子选择器:筛选选择器1元素下的选择器2元素"></a>3，子选择器:筛选选择器1元素下的选择器2元素</h4><p>​语法:  选择器1  选择器2{}</p><h4 id="4-父选择器-筛选选择器2的父元素选择器1"><a href="#4-父选择器-筛选选择器2的父元素选择器1" class="headerlink" title="4,父选择器:筛选选择器2的父元素选择器1"></a>4,父选择器:筛选选择器2的父元素选择器1</h4><p>​语法:   选择器1 &gt; 选择器2{} </p><p>​父套子成功</p><p>注:div p是选择div元素下的所有p元素（包括孙类），div&gt;p是只选择直接子类（一代子类），二代以上是不包含的</p><h4 id="5，属性选择器-选择元素名称-属性-属性值的元素"><a href="#5，属性选择器-选择元素名称-属性-属性值的元素" class="headerlink" title="5，属性选择器:选择元素名称,属性&#x3D;属性值的元素"></a>5，属性选择器:选择元素名称,属性&#x3D;属性值的元素</h4><p>​语法：元素名称[属性名&#x3D;“属性值”]{}</p><h4 id="6，伪类选择器-选择一些元素具有的状态"><a href="#6，伪类选择器-选择一些元素具有的状态" class="headerlink" title="6，伪类选择器:选择一些元素具有的状态"></a>6，伪类选择器:选择一些元素具有的状态</h4><p>​语法：元素:状态{}</p><p>​如:&lt;a&gt;</p><p>​状态:</p><p>​link：初始化的状态</p><p>​visited：被访问过的状态</p><p>​active：正咋访问状态</p><p>​hover：鼠标悬浮状态</p><p>​</p><h2 id="6-属性-选择器里面选项"><a href="#6-属性-选择器里面选项" class="headerlink" title="6,属性:(选择器里面选项)"></a>6,属性:(选择器里面选项)</h2><p>​1，字体，文本</p><p>​font-size:字体大小</p><p>​color:文本颜色</p><p>​text-align:对齐方式</p><p>​line-height:行高</p><p>​2，背景</p><p>​background:</p><p>​3，边框</p><p>​border:设置边框，符合属性</p><p>​4，尺寸</p><p>​width:宽度</p><p>​height:高度</p><p>​5，盒子模型:控制布局</p><p>​margin:外边距，盒子外部</p><p>​padding内边距，盒子内部</p><p>​默认情况下内边距会影响整个盒子的大小</p><p>​box-sizing:border-box;设置盒子属性，让width和height就是最终盒子的大小</p><p>在 CSS 中，每个元素都可以看作是一个矩形盒子，称为盒子模型。盒子模型包括元素的内容、内边距、边框和外边距。</p><h3 id="盒子模型组件"><a href="#盒子模型组件" class="headerlink" title="盒子模型组件"></a>盒子模型组件</h3><p>内容 (content)：元素的实际内容，如文本或图像。</p><p>内边距 (padding)：内容周围的空白区域，用于调整内容与边框的距离。</p><p>边框 (border)：围绕内容和内边距的线条，可以设置样式和厚度。</p><p>外边距 (margin)：边框之外的空白区域，用于与其他元素保持距离。</p><p>&lt;div&gt; 是一个 HTML 元素，它通常被视为一个矩形盒子</p><p>​float:浮动</p><p>​right  left</p><h1 id="十九，javascript基础"><a href="#十九，javascript基础" class="headerlink" title="十九，javascript基础"></a>十九，javascript基础</h1><h2 id="1-概述-一门客户端脚本语言"><a href="#1-概述-一门客户端脚本语言" class="headerlink" title="1,概述:一门客户端脚本语言"></a>1,概述:一门客户端脚本语言</h2><p>​运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</p><p>​脚本语言:不需要编译，直接就可以被浏览器解析执行了</p><h2 id="2，功能"><a href="#2，功能" class="headerlink" title="2，功能:"></a>2，功能:</h2><p>​可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验</p><h2 id="3，ECMAScript-客户端脚本语言的标准"><a href="#3，ECMAScript-客户端脚本语言的标准" class="headerlink" title="3，ECMAScript:客户端脚本语言的标准"></a>3，ECMAScript:客户端脚本语言的标准</h2><h3 id="①，基本语法"><a href="#①，基本语法" class="headerlink" title="①，基本语法:"></a>①，基本语法:</h3><h4 id="1，与html结合方式"><a href="#1，与html结合方式" class="headerlink" title="1，与html结合方式"></a>1，与html结合方式</h4><p>​内部Js:</p><p>​定义   0       &lt;script&gt;,标签体内容就是js代码</p><p>​外部Js:</p><p>​定义   0         &lt;script&gt;,通过src属性引入外部的Js文件</p><p>​注意:</p><p>​1，&lt;script&gt;可以定义在html页面的任何地方，但是定义的位置会影响执行顺序</p><p>​2，&lt;script&gt;可以定义多个。</p><h4 id="2，注释"><a href="#2，注释" class="headerlink" title="2，注释"></a>2，注释</h4><p>​1，单行注释:&#x2F;&#x2F;注释内容</p><p>​2，多行注释:&#x2F;*注释内容*&#x2F;</p><h4 id="3，数据类型"><a href="#3，数据类型" class="headerlink" title="3，数据类型"></a>3，数据类型</h4><p>​1，原始数据类型(基本数据类型):</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 081303.png)</p><p>​2，引用数据类型:对象</p><h4 id="4，变量-一小块存储数据的内存空间"><a href="#4，变量-一小块存储数据的内存空间" class="headerlink" title="4，变量:一小块存储数据的内存空间\"></a>4，变量:一小块存储数据的内存空间\</h4><p>​java是强类型，javascript是弱类型</p><p>​强类型:在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</p><p>​弱类型:在开辟变量存储空间时，不定义了空间将来存储的数据类型。只能存储任意类型的数据</p><p>​语法：</p><p>​var 变量名 &#x3D; 初始化值;</p><p>​typeof():输出数据类型</p><h4 id="5，运算符"><a href="#5，运算符" class="headerlink" title="5，运算符"></a>5，运算符</h4><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 090210.png)</p><p>​注意:在js中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换 如b+1</p><p>​其他类型转number:</p><p>​string转number: 按照字面值转换，如果字面值不是数字，则为NaN(不是数字的数字)</p><p>​boolean转number:true转为1，false转为0</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 090405.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 091546.png)</p><p>​比较方式</p><p>​1，类型相同:直接比较</p><p>​字符串:按照字典顺序比较。按位逐一比较，直到得出大小为止。</p><p>​2，类型相同:先进行类型转换，在比较</p><p>​&#x3D;&#x3D;&#x3D;   全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 091430.png)</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 094119.png)</p><p>​</p><p>​![ ](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 094412.png)</p><h4 id="6，流程控制语句"><a href="#6，流程控制语句" class="headerlink" title="6，流程控制语句:"></a>6，流程控制语句:</h4><p>​1，if..else…</p><p>​2，switch:</p><p>在java中,switch语句可以接受的数据类型:   byte  int  shor  char  ,枚举(1.5), string(1.7)</p><p>​switch(变量):</p><p>​case 值:</p><p>在javascript中,switch语句可以接受任意的原始数据类型 </p><p>​如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let str = &quot;Hello&quot;;</span><br><span class="line"></span><br><span class="line">switch (true) &#123;</span><br><span class="line">    case str == &quot;Hello&quot;:</span><br><span class="line">        console.log(&quot;Hello world&quot;);</span><br><span class="line">        break;</span><br><span class="line">    case str == &quot;Goodbye&quot;:</span><br><span class="line">        console.log(&quot;Goodbye moon&quot;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        console.log(&quot;Other&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​3，while</p><p>​4，do…while</p><p>​5，for</p><h4 id="7，JS特殊语法"><a href="#7，JS特殊语法" class="headerlink" title="7，JS特殊语法:"></a>7，JS特殊语法:</h4><p>​①，语句以;结尾，如果一行只有一条语句则；可以省略(不建议)</p><p>​②，变量的定义使用var关键字，也可以不使用</p><p>​用:定义的变量是局部变量</p><p>​不用:定义的变量是全局变量(不建议)</p><p>​如b&#x3D;4还要var b&#x3D;4</p><h3 id="②，基本对象"><a href="#②，基本对象" class="headerlink" title="②，基本对象"></a>②，基本对象</h3><h4 id="1，Array"><a href="#1，Array" class="headerlink" title="1，Array:"></a>1，Array:</h4><p>{</p><p>​1，创建</p><p>​①，var 对象名字 &#x3D; new Array(元素列表);</p><p>​②，var 对象名字 &#x3D; new Array(默认长度);</p><p>​③，var 对象名字 &#x3D; [元素列表]</p><p>​④，var 对象名字 &#x3D; new Array();</p><p>​</p><p>​方法:</p><p>​join(参数):将数组中的元素按照指定的分隔符拼接而成的字符串，参数就是分隔符</p><p>​push(参数):向数组的末尾添加一个或更多元素，并返回新的长度，参数为元素</p><p>​</p><p>​属性:</p><p>​length::数组的长度</p><p>​特点</p><p>​①Js中，数组元素的类型可变的。</p><p>​②js中，长度可变</p><p>}</p><h4 id="2-Boolean"><a href="#2-Boolean" class="headerlink" title="2,Boolean:"></a>2,Boolean:</h4><h4 id="3-Date"><a href="#3-Date" class="headerlink" title="3,Date:"></a>3,Date:</h4><p>​{</p><p>​1，创建</p><p>​var 对象名字 &#x3D; new Date()</p><p>​2，方法</p><p>​toLocaleString(无参数):返回当前date对象对应的时间本地字符串格式</p><p>​getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p><p>​}</p><h4 id="4-Math-数学"><a href="#4-Math-数学" class="headerlink" title="4,Math:数学"></a>4,Math:数学</h4><p>{</p><p>​1，创建:</p><p>​特点:Math对象不用创建，直接使用。Math.方法名;</p><p>​2，方法:</p><p>​random(无参数):返回0~1之间的随机数。含0不含1</p><p>​x指的是参数</p><p>​ceil(x);对数进行上舍入。如3.14-&gt;4</p><p>​floor(x);对数进行下舍入。如3.14-&gt;3</p><p>​round(x):把数四舍五入为最接近的整数。</p><p>​3，属性:</p><p>​PI</p><p>}</p><h4 id="5-Number"><a href="#5-Number" class="headerlink" title="5,Number:"></a>5,Number:</h4><h4 id="6-String"><a href="#6-String" class="headerlink" title="6,String:"></a>6,String:</h4><h4 id="7-RegExp"><a href="#7-RegExp" class="headerlink" title="7,RegExp:"></a>7,RegExp:</h4><p>{</p><p>​1，正则表达式:定义字符串的组成规则。</p><p>​①，单个字符:[]</p><p>​如：[a] [ab] [a-zA-Z0-9_]</p><p>​特殊符号代表特殊含义的单个字符:</p><p>​\d:单个数字字符[0-9]</p><p>​\w:单个单词字符    [a-zA-Z0-9_]</p><p>​②，量词符号:</p><p>​?:表示出现0次或1次</p><p>​*:表示出现0次或多次</p><p>​+:出现1次或多次</p><p>​{m,n}:表示 m&lt;&#x3D;数量&lt;&#x3D;n</p><p>​m如果缺省:{,n}:最多n次</p><p>​n如果缺省:{m,}最少m次</p><p>​^正则表达式开始，$正则表达式结束</p><p>​2，创建</p><p>​①var 对象名字 &#x3D; new RegExp(“正则表达式”)</p><p>​注:在字符串中\有转义功能所以\w应该为\\w</p><p>​②var reg &#x3D; &#x2F;正则表达式&#x2F;;</p><p>​3，方法</p><p>​test(x):验证指定的字符串是否符合正则定义的规范</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 161541.png)</p><h4 id="8-Global"><a href="#8-Global" class="headerlink" title="8,Global:"></a>8,Global:</h4><p>{</p><p>​1，特点:全局对象,这个Global中封装的方法不需要对象就可以直接调用。</p><p>​方法名():</p><p>​2,方法:</p><p>​encodeURI(字符串):url编码 返回值为utf码</p><p>​decodeURI(utf码):url解码 返回值为字符串</p><p>​</p><p>​encodeURIComponent():url编码，编码的字符更多</p><p>​decodeURIComponent():url解码</p><p>​</p><p>​parseInt():将字符串转为数字</p><p>​逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字转为number(是从最一开始判断，如果最开始就不是数字，那就不看后面)</p><p>​</p><p>​isNaN():判断一个值是不是NaN</p><p>​NaN六亲不认，连自己都不认。NaN参与的&#x3D;&#x3D;比较全部问false</p><p>​</p><p>​eval():将JavaScript字符串，并把它作为脚本代码来执行。</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 170350.png)</p><p>​</p><p>​}</p><h4 id="9-Function-函数对象"><a href="#9-Function-函数对象" class="headerlink" title="9,Function:函数对象"></a>9,Function:函数对象</h4><p>{ 1，创建:</p><p>​①，var fun &#x3D; new Function(形式参数列表，方法体)；（了解就行）</p><p>​②，function 方法名称(形式参数列表){方法体}（需要掌握）</p><p>​如 function fun2 ( a,b){  alert(a+b);}  </p><p>​③，var 方法名 &#x3D; function(形式参数列表){    方法体}        （需要掌握）</p><p>​如 var fun2 &#x3D; function (a,b){     alert(a+b);}</p><p>​2，调用方法</p><p>​对象名.方法名称(实际参数列表)</p><pre><code> 如  fun2(3,4);</code></pre><p>​3，特点:</p><p>​①,方法定义时，形参的类型不用写，返回值类型也不写</p><p>​②,方法是一个对象，如果定义名称相同的方法，会覆盖掉</p><p>​③,在JS中，方法的调用只与方法的名称有关，和参数列表无关</p><p>​④，在方法声明中有一个隐藏的内置对象(数组)，arguments,封装所有的实际参数</p><p>}</p><h2 id="4，BOM"><a href="#4，BOM" class="headerlink" title="4，BOM:"></a>4，BOM:</h2><h3 id="①-概念："><a href="#①-概念：" class="headerlink" title="①,概念："></a>①,概念：</h3><p>browser object model 浏览器模型</p><p>​将浏览器各个组成部分封装成对象</p><h3 id="②，组成"><a href="#②，组成" class="headerlink" title="②，组成:"></a>②，组成:</h3><p>​window:窗口对象</p><h4 id="1，创建"><a href="#1，创建" class="headerlink" title="1，创建"></a>1，创建</h4><h4 id="2，方法"><a href="#2，方法" class="headerlink" title="2，方法"></a>2，方法</h4><h5 id="①与弹出框有关的方法"><a href="#①与弹出框有关的方法" class="headerlink" title="①与弹出框有关的方法"></a>①与弹出框有关的方法</h5><p>​1，alert()    弹出警告框</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 191827.png)</p><p>​2，confirm()        显示带有一段消息以及确认按钮和取消按钮的对话框</p><p>​如果用户点击确认按钮，则方法返回true</p><p>​如果用户点击取消按钮，则方法返回false</p><p>防止误操作</p><p>confirm(“您确定要退出吗“)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 191814.png)</p><p>​3，prompt()        显示可提示用户输入的对话框</p><p>​返回值为用户输入的值</p><p>​prompt(“请输入用户名”)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 192520.png)</p><h5 id="②与打开关闭有关的方法"><a href="#②与打开关闭有关的方法" class="headerlink" title="②与打开关闭有关的方法"></a>②与打开关闭有关的方法</h5><p>​1,open(x) 打开一个新的浏览器窗口 参数为页面的网址、返回一个新的对象</p><p>​2,close(x)关闭窗口，谁调用我我关谁</p><h5 id="③与定时器有关的方式"><a href="#③与定时器有关的方式" class="headerlink" title="③与定时器有关的方式"></a>③与定时器有关的方式</h5><p>​setTimeout(x，y)      在指定的毫秒数后调用函数或计算表达式</p><p>​参数:</p><p>​1, js代码或者方法对象</p><p>​2，毫秒值</p><p>​返回值:唯一标识，用于取消定时器</p><p>​只会执行一次</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 195800.png)</p><p>​clearTimeout()       取消由setTimeout()方法设置的timeout</p><p>​setInterval(x,y)        按照指定的周期(以毫秒计)来调用函数或计算表达式</p><p>​参数:</p><p>​1, js代码或者方法对象</p><p>​2，毫秒值</p><p>​每几毫秒执行一次</p><p>​clearInterval()      取消由 setInterval()    设置的timeout.</p><h3 id="轮播图"><a href="#轮播图" class="headerlink" title="轮播图"></a>轮播图</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 201014.png)</p><p>![屏幕截图 2024-07-31 201025](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 201025.png)</p><h4 id="3，属性"><a href="#3，属性" class="headerlink" title="3，属性"></a>3，属性</h4><h5 id="①-获取其他BoM对象"><a href="#①-获取其他BoM对象" class="headerlink" title="①.获取其他BoM对象"></a>①.获取其他BoM对象</h5><p>​history</p><p>​location</p><p>​Navigator</p><p>​Screen：</p><h5 id="②-获取dom对象"><a href="#②-获取dom对象" class="headerlink" title="②,获取dom对象"></a>②,获取dom对象</h5><p>​document：在 HTML 中，文档指的是整个 HTML 文档，包括标签和标签内的内容</p><h4 id="4，特点"><a href="#4，特点" class="headerlink" title="4，特点"></a>4，特点</h4><p>​window对象不需要创建可以直接使用window使用。window.方法名</p><p>​window可以省略</p><p>​Navigator:浏览器对象</p><p>​Screen:显示器屏幕对象</p><p>​history:历史记录对象</p><h4 id="1，创建-获取"><a href="#1，创建-获取" class="headerlink" title="1，创建(获取):"></a>1，创建(获取):</h4><p>​1，window.history</p><p>​2,history</p><h4 id="2-方法"><a href="#2-方法" class="headerlink" title="2,方法:"></a>2,方法:</h4><p>back()加载历史列表中的上一个 URL（页面）。 </p><p>forward()加载历史列表中的下一个 URL（页面）。</p><p> go()从历史列表中加载特定的 URL（页面）。 </p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 212009.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 212032.png)</p><h4 id="3-属性"><a href="#3-属性" class="headerlink" title="3,属性"></a>3,属性</h4><p>​length 返回历史列表中的 URL（页面）数量</p><p>​Location:地址栏对象</p><h4 id="1，创建-获取-1"><a href="#1，创建-获取-1" class="headerlink" title="1，创建(获取):"></a>1，创建(获取):</h4><p>​1,window.location</p><p>​2,location</p><h4 id="2，方法-1"><a href="#2，方法-1" class="headerlink" title="2，方法"></a>2，方法</h4><p>​reload()重新加载当前文档。刷新</p><h4 id="3，属性-1"><a href="#3，属性-1" class="headerlink" title="3，属性"></a>3，属性</h4><p>​href  设置或返回完整的url</p><p><code>location.href</code> 是 <code>location</code> 对象的一个属性，用于获取或设置当前 URL。设置 <code>href</code> 可以实现页面跳转。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 204223.png)</p><p>自动跳转首页</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 205509.png)</p><h2 id="5，DOM"><a href="#5，DOM" class="headerlink" title="5，DOM:"></a>5，DOM:</h2><p>​功能:控制html文档的内容</p><p>​代码:获取页面标签(元素)对象 Element</p><p>​document.getElementById(“id值”):通过元素的id获取元素对象</p><p>​操作Element对象:</p><p>​1,修改属性值:</p><p>​1，明确获取的对象是哪一个?</p><p>​2,查看API文档，找其中有哪些属性可以设置</p><p>​2,修改标签体内容:</p><p>​属性:innerHTML</p><p>​1，获取元素对象</p><p>​2，使用innerHTML属性修改标签体内容</p><p>​</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 174547.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 174544.png)</p><p>事件简单学习</p><p>​功能:某些组件被执行了某些操作后，触发某些代码的执行</p><p>​如何绑定事件</p><p>​1,直接在html标签上，指定事件的属性(操作)，属性值就是js代码</p><p>​1,事件:onclick—单击事件</p><h5 id="直接添加属性和属性值"><a href="#直接添加属性和属性值" class="headerlink" title="直接添加属性和属性值"></a>直接添加属性和属性值</h5><p>​2，通过js获取元素对象，指定事件属性，设置一个函数。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 175629.png)</p><h3 id="①概念-3"><a href="#①概念-3" class="headerlink" title="①概念:"></a>①概念:</h3><p>​将标记语言文档的各个组成部分，封装成对象。可以使用这些对象，对标记语言文档进行CURD的动态操作</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 212448.png)</p><p>​核心Dom:针对任何结构化文档的标准模型</p><p>​Document:文档对象</p><p>​Element:元素对象</p><p>​Attribute:属性对象</p><p>​Text:文本对象</p><p>​Comment:注释对象</p><p>​</p><ul><li><p><code>Document</code> 是整个 HTML 文档。</p></li><li><p><code>Element</code> 是文档的一部分，包含属性、子元素和文本。</p></li><li><p><code>Attribute</code> 是元素的一部分，表示属性。</p></li><li><p><code>Text</code> 是元素的一部分，表示文本内容。</p></li><li><p><code>Comment</code> 是文档或元素的一部分，表示注释。</p></li></ul><p>​Node:节点对象,其他5个的父对象</p><p>​</p><h3 id="②核心DOM模型"><a href="#②核心DOM模型" class="headerlink" title="②核心DOM模型:"></a>②核心DOM模型:</h3><h3 id="Document-文档对象"><a href="#Document-文档对象" class="headerlink" title="Document:文档对象"></a>Document:文档对象</h3><h4 id="1-创建-在html-dom模型中可以使用window对象来获取"><a href="#1-创建-在html-dom模型中可以使用window对象来获取" class="headerlink" title="1,创建:在html dom模型中可以使用window对象来获取"></a>1,创建:在html dom模型中可以使用window对象来获取</h4><p>​1，window.document</p><p>​2，document</p><h4 id="2，方法-2"><a href="#2，方法-2" class="headerlink" title="2，方法:"></a>2，方法:</h4><h5 id="①获取Element对象"><a href="#①获取Element对象" class="headerlink" title="①获取Element对象:"></a>①获取Element对象:</h5><p>​1,getElementById():根据id属性值获取元素对象。id属性值一般唯一</p><p>​2，getElementByTagName():根据元素名称获取元素对象们。返回值是一个数组。</p><p>​3，getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组。</p><p>​4，getElementsByName():根据name属性值获取元素对象们。返回值是一个数组。</p><h5 id="②创建dom对象"><a href="#②创建dom对象" class="headerlink" title="②创建dom对象"></a>②创建dom对象</h5><p>​createAttribute(name)</p><p>​createComment()</p><p>​createElement()  </p><p>​createTextNode()</p><h4 id="3-属性-1"><a href="#3-属性-1" class="headerlink" title="3,属性"></a>3,属性</h4><h3 id="Element-元素对象"><a href="#Element-元素对象" class="headerlink" title="Element:元素对象"></a>Element:元素对象</h3><h4 id="1，获取-创建"><a href="#1，获取-创建" class="headerlink" title="1，获取&#x2F;创建:"></a>1，获取&#x2F;创建:</h4><p>​通过document来获取和创建</p><h4 id="2-方法-1"><a href="#2-方法-1" class="headerlink" title="2,方法:"></a>2,方法:</h4><p>​1,removeAttribute():删除属性</p><p>​2,setAttribute():设置属性</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-07-31 215941.png)</p><p>​</p><h4 id="Node-节点对象-其他5个的父对象"><a href="#Node-节点对象-其他5个的父对象" class="headerlink" title="Node:节点对象,其他5个的父对象"></a>Node:节点对象,其他5个的父对象</h4><h4 id="1，特点"><a href="#1，特点" class="headerlink" title="1，特点:"></a>1，特点:</h4><p>​所有dom对象都可认为是一个节点</p><p>​元素节点对应 HTML 标签</p><h4 id="2，方法-3"><a href="#2，方法-3" class="headerlink" title="2，方法:"></a>2，方法:</h4><p>​crud  dom树：</p><p>​appendChild():向节点的子节点列表的结尾添加新的子节点</p><p>​removeChild():删除(并返回)当前节点的指定子节点。</p><p>​replaceChild():用新节点替换一个子节点</p><h4 id="3，属性-2"><a href="#3，属性-2" class="headerlink" title="3，属性"></a>3，属性</h4><p>​parentNode :返回节点的父节点</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-01 073758.png)</p><h3 id="③html-dom模型"><a href="#③html-dom模型" class="headerlink" title="③html dom模型"></a>③html dom模型</h3><p>1，标签体的设置和获取：innerHTML 属性</p><p>​使用时给它赋值</p><p>2，使用html属性</p><p>3，控制元素样式</p><p>​1,使用元素的style属性来设置</p><p>​如：</p><p>​修改样式方式1</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-01 095750.png)</p><p>​2，提前定义好类选择器的样式，通过元素的className属性来设置属性值</p><p>而是:</p><h3 id="④事件"><a href="#④事件" class="headerlink" title="④事件"></a>④事件</h3><p>​概念:某些组件被执行了某些操作后，触发某些代码的执行</p><p>​事件:某些操作，如:单击，双击，键盘按下了，鼠标易懂了</p><p>​事件源:组件。如按钮 文本输入框…….</p><p>​监听器:代码。</p><p>​注册监听:将事件，事件源，监听器结合在一起。当事件源上发生了某个事件，则触发执行某个监听器代码。</p><p>​一般都是这么用</p><p>document.getElementById(“username”).onmouseover &#x3D; function(){</p><p>​alert(“鼠标来了”)}</p><p>​获取标签使用事件和函数对象绑定</p><p>​常见事件:</p><p>​1,点击事件:</p><p>​①onclick:单击事件</p><p>​②onblclick:双击事件</p><p>​2，焦点事件:</p><p>​①onblur:失去焦点</p><p>​一般用于表单校验</p><p>​②onfocus:获得焦点</p><p>​3，加载事件</p><p>​①onload:一张页面或一副图形完成加载。</p><p>​4，鼠标事件:</p><p>​①onmousedown    鼠标按钮被按下</p><p>​定义方法时指的是function(参数)，定义一个形参，接受event对象</p><p>​event对象的button属性可以获取鼠标按钮键被点击了</p><p>​②onmouseup          鼠标按键被松开</p><p>​③onmousemove      鼠标被移开</p><p>​④onmouseover       鼠标移到某元素之上。</p><p>​⑤onmouseout        鼠标从某元素移开</p><p>​5，键盘事件</p><p>​①，onkeydown      某个键盘按键被按下。</p><p>​②，onkeyup             某个键盘按键被松开。</p><p>​③，onkeypress       某个键盘按键被按下并松开，</p><p>​6，选中和改变</p><p>​①onchange       域的内容被改变</p><p>​②onselect      文本被选中</p><p>​7，表单事件：</p><p>​①onsubmit     确认按钮被点击</p><p>​②onreset        重置按钮被点击 </p><h1 id="二十，bootstrap框架"><a href="#二十，bootstrap框架" class="headerlink" title="二十，bootstrap框架"></a>二十，bootstrap框架</h1><h2 id="1，概念-1"><a href="#1，概念-1" class="headerlink" title="1，概念"></a>1，概念</h2><p>​:一个前端开发的框架，使web开发简洁<br>​框架:一个半成品软件，开发人员可以在框架基础上，</p><h2 id="2，好处-1"><a href="#2，好处-1" class="headerlink" title="2，好处"></a>2，好处</h2><p>​①，定义了很多的css样式和js插件。开发人员直接可以使用这些样式和插件得到丰富的页码效果</p><p>​②，响应式布局</p><p>​同一套页面可以兼容不同分辨率的设备。</p><h2 id="3，快速入门"><a href="#3，快速入门" class="headerlink" title="3，快速入门"></a>3，快速入门</h2><p>​ ①下载Bootstrap</p><p>​②在项目中将这三个文件夹复制</p><p>​③创建html页面，引入必要的资源文件</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-01 110049.png)</p><p>基本模版</p><h2 id="4，响应式布局"><a href="#4，响应式布局" class="headerlink" title="4，响应式布局"></a>4，响应式布局</h2><p>实现:依赖于栅格系统:将一行平均分成12个格子</p><p>步骤:</p><h4 id="1-定义容器。相当于之前的table"><a href="#1-定义容器。相当于之前的table" class="headerlink" title="1,定义容器。相当于之前的table"></a>1,定义容器。相当于之前的table</h4><p>​容器分类:</p><p>​1,container:两边留白</p><p>​2,container-fluid:每个设备都是100%宽度</p><p>​&lt;div class&#x3D;“container”&gt;</p><h4 id="2-定义行。相当于之前的tr-样式-row"><a href="#2-定义行。相当于之前的tr-样式-row" class="headerlink" title="2,定义行。相当于之前的tr        样式:row:"></a>2,定义行。相当于之前的tr        样式:row:</h4><p>​&lt;div class&#x3D;“row”&gt;</p><h4 id="3-定义元素。指定该元素在不同的设备上，所占的格子数目。-样式-col-设备代号-格子数目"><a href="#3-定义元素。指定该元素在不同的设备上，所占的格子数目。-样式-col-设备代号-格子数目" class="headerlink" title="3,定义元素。指定该元素在不同的设备上，所占的格子数目。 样式:col-设备代号-格子数目"></a>3,定义元素。指定该元素在不同的设备上，所占的格子数目。 样式:col-设备代号-格子数目</h4><p>​设备代号:</p><p>​1，xs:超小屏幕  手机(&lt;768px):col - xs - 12</p><p>​2,sm小屏幕 平板 (&gt;&#x3D;768px)  </p><p>​3,md:中等屏幕 桌面显示器 (&gt;&#x3D;992px)</p><p>​4,lg:大屏幕 大桌面显示器 (&gt;&#x3D;1200px)</p><p>​&lt;div class&#x3D;“col-lg-1 col-sm - 2 inner”&gt;栅格&lt;&#x2F;栅格&gt;</p><p>​<strong>在大屏幕中“栅格”占1&#x2F;12比例     而在平板中“栅格”占6&#x2F;1比例</strong></p><p>注意:</p><p>​1,一行中如果格子数目超过12自动换行</p><p>​2,栅格类可以向上兼容。比例不变，只会扩大，栅格类适用于与屏幕宽度大于或等于分界点大小的设备</p><p>​3，如果设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素占满一整行</p><p>比例扩大</p><h2 id="5，CSS样式和js插件"><a href="#5，CSS样式和js插件" class="headerlink" title="5，CSS样式和js插件"></a>5，CSS样式和js插件</h2><h3 id="①全局css样式"><a href="#①全局css样式" class="headerlink" title="①全局css样式:"></a>①全局css样式:</h3><p>​class类自己查</p><h4 id="1，按钮"><a href="#1，按钮" class="headerlink" title="1，按钮:"></a>1，按钮:</h4><p>​class&#x3D;“btn-default”</p><h4 id="2，图片"><a href="#2，图片" class="headerlink" title="2，图片:"></a>2，图片:</h4><p>​class &#x3D; “img-responsive”：图片在任意尺寸都占100%</p><p>​class &#x3D; “img-circle”:圆形</p><h4 id="3，表格"><a href="#3，表格" class="headerlink" title="3，表格"></a>3，表格</h4><p>​table</p><p>​table-bordered</p><p>​table-hover</p><p>​自己查看文档</p><h4 id="4，表单"><a href="#4，表单" class="headerlink" title="4，表单"></a>4，表单</h4><p>​给表单项添加:class&#x3D;“form-control”</p><h3 id="②组件"><a href="#②组件" class="headerlink" title="②组件:"></a>②组件:</h3><h4 id="1，导航条"><a href="#1，导航条" class="headerlink" title="1，导航条"></a>1，导航条</h4><h4 id="2，分页条"><a href="#2，分页条" class="headerlink" title="2，分页条"></a>2，分页条</h4><h3 id="③插件"><a href="#③插件" class="headerlink" title="③插件:"></a>③插件:</h3><h4 id="1-轮播图"><a href="#1-轮播图" class="headerlink" title="1,轮播图"></a>1,轮播图</h4><h1 id="二十一，xml"><a href="#二十一，xml" class="headerlink" title="二十一，xml"></a>二十一，xml</h1><h2 id="1，概念-Exterside-Markup-Language-可扩展标记语言"><a href="#1，概念-Exterside-Markup-Language-可扩展标记语言" class="headerlink" title="1，概念:Exterside Markup Language 可扩展标记语言"></a>1，概念:Exterside Markup Language 可扩展标记语言</h2><p>​可扩展:标签都是自定义的。&lt;user&gt;&lt;student&gt;</p><p>​</p><h3 id="②，功能"><a href="#②，功能" class="headerlink" title="②，功能"></a>②，功能</h3><p>​存储数据</p><p>​1，配置文件</p><p>​ 2，在网络中传输</p><p>​ </p><h3 id="③，xml与html的区别"><a href="#③，xml与html的区别" class="headerlink" title="③，xml与html的区别"></a>③，xml与html的区别</h3><p>​1，xml标签都是自定义的，html标签是预定义的</p><p>​2，xml的语法雅阁，html语法松散</p><p>​3，xml是存储数据的,html是展示数据的</p><h3 id="④，w3c万维网联盟"><a href="#④，w3c万维网联盟" class="headerlink" title="④，w3c万维网联盟"></a>④，w3c万维网联盟</h3><h2 id="2，语法："><a href="#2，语法：" class="headerlink" title="2，语法："></a>2，语法：</h2><p>基本语法:</p><p>​1，xml文档的后缀名 .xml</p><p>​2，xml第一行必须定义为文档声明</p><p>​3，xml文档中有且仅有一个根标签</p><p>​4，属性值必须使用引号(单双都可)引起来</p><p>​5，标签必须正确关闭</p><p>​6，<strong>xml标签区分大小写</strong></p><p>快速入门:</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-01 202544.png)</p><h2 id="3，组成部分"><a href="#3，组成部分" class="headerlink" title="3，组成部分:"></a>3，组成部分:</h2><h3 id="①-文档说明"><a href="#①-文档说明" class="headerlink" title="①,文档说明"></a>①,文档说明</h3><p>​格式:&lt;?xml 属性列表 ?&gt;</p><p>​属性列表:</p><p>​version:版本号，必须属性</p><p>​encoding:编码方式。告知解析引擎当前文档使用的字符集，默认值:ISO-8859-1</p><p>​standalone:是否独立</p><p>​取值：</p><p>​yes:不依赖其他文件</p><p>​no:依赖其他文件</p><p>&lt;? version &#x3D; “1.0 encoding &#x3D; utf-8” standalone &#x3D; “yes”?&gt;</p><h3 id="②-指令-了解-结合css的"><a href="#②-指令-了解-结合css的" class="headerlink" title="②,指令(了解):结合css的"></a>②,指令(了解):结合css的</h3><p>​如&lt;?xml-stylesheet type&#x3D;”text&#x2F;css” herf&#x3D;”a.css”?&gt;</p><h3 id="③-标签-标签名称自定义的"><a href="#③-标签-标签名称自定义的" class="headerlink" title="③,标签:标签名称自定义的"></a>③,标签:标签名称自定义的</h3><p>​规则:</p><p>​名称可以包含字母,数字以及其他的符号</p><p>​名称不能以数字或者标点符号开始</p><p>​名称不能以字母xml(或者 xml ,xml等等)开始</p><p>​名称不能包含空格 </p><h3 id="④-属性"><a href="#④-属性" class="headerlink" title="④,属性"></a>④,属性</h3><p>​id属性值唯一</p><h3 id="⑤-文本"><a href="#⑤-文本" class="headerlink" title="⑤,文本:"></a>⑤,文本:</h3><p>特殊字符需要转义</p><p>&lt;![CDATA[文本内容]]&gt;</p><p>如&lt;![CDATA[</p><p>​if(a&lt;b&amp;&amp;a&gt;c){}]]&gt;</p><p>​CDATA区:再该区域中的数据会被原样展示</p><h2 id="4，约束"><a href="#4，约束" class="headerlink" title="4，约束"></a>4，约束</h2><h3 id="①规定xml文档的书写规则"><a href="#①规定xml文档的书写规则" class="headerlink" title="①规定xml文档的书写规则"></a>①规定xml文档的书写规则</h3><p>​作为框架的使用者</p><p>​1，能够引入约束文档</p><p>​2，能够简单的读懂约束文档</p><h3 id="②分类"><a href="#②分类" class="headerlink" title="②分类"></a>②分类</h3><p>​1,DTD:一种简单的约束技术</p><p>​2,Schema:一种复杂的约束技术</p><p>约束文档:</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-01 211817.png)</p><h3 id="③DTD"><a href="#③DTD" class="headerlink" title="③DTD:"></a>③DTD:</h3><p>​引入dtd文档到xml文档中</p><p>​内部dtd:将约束规则定义在xml文档中</p><p>​外部dtd:将约束的规则定义在外部的dtd文件中</p><p>​本地：&lt;!DOCTYPE 根标签名 SYSTEM “dtd文件的位置”&gt;</p><p>​网络&lt;!DOCTYPE 根标签名 PUBLIC “dtd文件名字” “dtd文件中的位置URL”&gt;</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-01 213330.png)</p><h3 id="④schema"><a href="#④schema" class="headerlink" title="④schema"></a>④schema</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-01 214903.png)</p><h2 id="5，解析"><a href="#5，解析" class="headerlink" title="5，解析"></a>5，解析</h2><p>操作xml文档,将文档中的数据读取到内存中</p><h3 id="①操作xml文档"><a href="#①操作xml文档" class="headerlink" title="①操作xml文档"></a>①操作xml文档</h3><p>​1，解析(读取):将文档中的数据读取到内存中</p><p>​2，写入:将内存中的数据保存到xml文档中。持久化的存储</p><h3 id="②解析xml的方式"><a href="#②解析xml的方式" class="headerlink" title="②解析xml的方式:"></a>②解析xml的方式:</h3><p>​1,DOM将标记语言文档一次性加载进内存，在内存中形成一颗dom树</p><p>​优点:操作方便，可以对文档进行CRUD的所有操作</p><p>​缺点:占内存</p><p>​2,SAX:逐行读取，基于事件驱动的。读一行，释放一行</p><p>​优点:不占内存，适用于内存较小的设备</p><p>​缺点:只能读取，不能增删改</p><p>​</p><h3 id="③常见解析器"><a href="#③常见解析器" class="headerlink" title="③常见解析器:"></a>③常见解析器:</h3><p>1，JAxP:sun公司提供的解析器，支持dom和sax两种思想</p><p>2，DOM4J:一款非常优秀的解析器</p><p>3，Jsoup:java的html解析器</p><p>4，PULL:Android操作系统</p><h3 id="④Jsoup"><a href="#④Jsoup" class="headerlink" title="④Jsoup:"></a>④Jsoup:</h3><p>java的html解析器可直接解析某个URL地址，HTML文本内容。他提供了一套非常省力的API,可通过DOM,CSS以及类似于jquery的操作方式来取出和操作数据</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 075102.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 080542.png)</p><h2 id="6，对象的使用"><a href="#6，对象的使用" class="headerlink" title="6，对象的使用:"></a>6，对象的使用:</h2><h3 id="①-Jsoup"><a href="#①-Jsoup" class="headerlink" title="①,Jsoup:"></a>①,Jsoup:</h3><p>​工具类，可以解析html或xml文档，返回Document</p><p>​parse(File in,String CharsetName):解析xml或html文件</p><p>​parse(String html):解析xml或html字符串</p><p>​parse(Url url,int timeoutMillis)通过网络路径获取指定的html或xml的文档对象</p><p>​URL（Uniform Resource Locator）是统一资源定位符，用于标识互联网上的资源位置。它通常由协议、主机名、路径和查询参数组成。</p><p>​timeoutMillis:超时时间</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 083145.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 083348.png)</p><h3 id="②-Document"><a href="#②-Document" class="headerlink" title="②,Document:"></a>②,Document:</h3><p>​文档对象。代表内存中的dom树</p><p>​获取Element对象</p><p>​getElementsByTag(String tagName):根据标签名称获取元素对象集合</p><p>​getElementsByAttribute(String key):根据属性名称获取元素对象集合</p><p>​getElementsByAttributeValue(String key,String value):根据对应的属性名和属性值获取元素对象集合</p><p>​getElementsById(Stringid):根据id属性值获取唯一的element对象</p><p><code>getElementsByTagName()</code> 返回的是一个 <code>NodeList</code> 对象，它类似于数组，但不支持数组的方法。更像是一个列表</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 085256.png)</p><h3 id="③-Elements"><a href="#③-Elements" class="headerlink" title="③,Elements:"></a>③,Elements:</h3><p>​元素Element对象的集合。可以当做ArrayList&lt;Element&gt;来使用</p><h3 id="④-Element"><a href="#④-Element" class="headerlink" title="④,Element:"></a>④,Element:</h3><p>​1，获取子元素对象</p><p>​getElementsByTag(String tagName):根据标签名称获取元素对象集合</p><p>​getElementsByAttribute(String key):根据属性名称获取元素对象集合</p><p>​getElementsByAttributeValue(String key,String value):根据对应的属性名和属性值获取元素对象集合</p><p>​getElementsById(Stringid):根据id属性值获取唯一的element对象</p><p>​2，获取属性值</p><p>​String attr(String key):根据属性名称获取属性值</p><p>​3，获取文本内容</p><p>​String text():获取文本内容![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 091423.png)</p><p>​String html():获取标签体的所有内容(包括字标签的字符串内容)![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 091503.png)</p><h3 id="⑤-Node"><a href="#⑤-Node" class="headerlink" title="⑤,Node:"></a>⑤,Node:</h3><p>​节点对象</p><p>​是Document和Element的父类</p><h2 id="7，快捷查询方法"><a href="#7，快捷查询方法" class="headerlink" title="7，快捷查询方法"></a>7，快捷查询方法</h2><h3 id="①，selector-选择器没装"><a href="#①，selector-选择器没装" class="headerlink" title="①，selector:选择器没装"></a>①，selector:选择器没装</h3><p>​可以深度查询</p><p>​使用的方法:Elements select(String cssquery)</p><p>​cssquery：选择器</p><p>​语法:参考Selector类中定义的语法</p><p>​获取的是标签体的所有内容</p><h3 id="②，xpath-没装"><a href="#②，xpath-没装" class="headerlink" title="②，xpath:没装"></a>②，xpath:没装</h3><p>​使用jourp的Xpath需要额外导入jar包</p><p>​需要根据document对象，创建JXDocument对象</p><p>​JXDocument jxDocument &#x3D; new JXDocument(document);</p><p>查询w3cshool参考手册，使用xpath的语法完成查询</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 095331.png)</p><h1 id="二十二，tomcat"><a href="#二十二，tomcat" class="headerlink" title="二十二，tomcat"></a>二十二，tomcat</h1><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 101654.png)</p><h2 id="web服务器软件"><a href="#web服务器软件" class="headerlink" title="web服务器软件:"></a>web服务器软件:</h2><p>服务器:安装了服务器软件的计算机</p><p>服务器软件:接受用户的请求，处理请求，做出响应</p><p>​在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目</p><p>​web容器</p><p>常见的java相关的web服务器软件:</p><p>webLogic:oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费</p><p>webSphere:IBM公司大型的Javaee服务器</p><p>Jboss;收费</p><p>Tomcat:Apache基金组织仅仅支持少量的JavaEE规范，免费的</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 113351.png)</p><h2 id="1，失败原因"><a href="#1，失败原因" class="headerlink" title="1，失败原因"></a>1，失败原因</h2><p>1，一闪而过：正确配置javaHome环境变量</p><p>* netstat -ano</p><p>2，启动保错：</p><p>1，暴力：找到占用的端口号，并且找到对应的进程，杀死该进程</p><p>2，温柔：修改自身的端口号</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 150103.png)</p><h2 id="2，关闭"><a href="#2，关闭" class="headerlink" title="2，关闭:"></a>2，关闭:</h2><p>1，正常关闭：</p><p>​1，bin&#x2F;shutdown.bat</p><p>2，ctrl+c</p><p>2，强制关闭：</p><p>​点击启动窗口的x</p><h2 id="3，配置："><a href="#3，配置：" class="headerlink" title="3，配置："></a>3，配置：</h2><p>部署项目的方式：</p><p>​①直接将项目放到webapps目录下即可</p><p>​&#x2F;hello:项目的访问路径——&gt;虚拟目录</p><p>​简化部署:将项目打成war包，再将war包放置到WebApps目录下</p><p>​war包会自动解压缩</p><p>​②配置con&#x2F;server.xml文件</p><p>​在&lt;Host&gt;标签体中配置</p><p>​&lt;Context docBase&#x3D;“D:\hello” path &#x3D; “&#x2F;hehe”&#x2F;&gt;</p><p>​docBase:项目存放的路径</p><p>​path:虚拟目录</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 155308.png)</p><p>![屏幕截图 2024-08-02 155317](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 155317.png)</p><p>​③在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写</p><p>​&lt;Context docBase&#x3D;”D\hello”&#x2F;&gt;</p><p>​虚拟目录:xml文件的名称</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 155515.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 155616.png)</p><p>通过xml文件访问D盘中的Html文件</p><h2 id="4，项目"><a href="#4，项目" class="headerlink" title="4，项目"></a>4，项目</h2><p>静态项目和动态项目</p><p>​目录结构</p><p>​java动态项目的目录结构</p><p>​– 项目的根目录</p><p>​–web-inf目录:</p><p>​–web.xml:web项目的核心配置文件</p><p>​–classes目录:放置字节码文件的目录</p><p>​–lib目录:放置依赖的Jar包</p><h2 id="5，将tomcat集成到IDEA中，并且创建javaee的项目，部署项目"><a href="#5，将tomcat集成到IDEA中，并且创建javaee的项目，部署项目" class="headerlink" title="5，将tomcat集成到IDEA中，并且创建javaee的项目，部署项目"></a>5，将tomcat集成到IDEA中，并且创建javaee的项目，部署项目</h2><p> index:默认首页</p><h1 id="二十三-servlet"><a href="#二十三-servlet" class="headerlink" title="二十三,servlet:"></a>二十三,servlet:</h1><h2 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1,概念"></a>1,概念</h2><p> 运行在服务器端的小程序</p><p>​serblet就是一个接口，定义了Java类被浏览器访问到（Tomcat识别）的规则</p><p>​将来我们自定义一个类，识别Servlet接口，复习方法</p><h2 id="2，快速入门-1"><a href="#2，快速入门-1" class="headerlink" title="2，快速入门"></a>2，快速入门</h2><p>①，创建Javaee项目</p><p>②，定义一个类，实现Servle接口</p><p>③，实现接口中的抽象方法</p><p>④，配置Servlet</p><p>在web差面书写</p><h2 id="3-执行原理"><a href="#3-执行原理" class="headerlink" title="3,执行原理"></a>3,执行原理</h2><p><img src="/"></p><p>①当服务器接受到客户端浏览器的请求后，会解析请求URL路径,获取访问的Servlet的资源路径</p><p>②查找web.xml文件，是否有对应的&lt;url-pattern&gt;标签体内容</p><p>③如果有，则在找到对应的&lt;servlet-class&gt;全类名</p><p>④tomcat会将字节码文件加载进内存，并且创建其对象</p><p>⑤调用其方法</p><h2 id="4，servlet中的生命周期"><a href="#4，servlet中的生命周期" class="headerlink" title="4，servlet中的生命周期:"></a>4，servlet中的生命周期:</h2><h3 id="①，被创建：执行init方法，只执行一次"><a href="#①，被创建：执行init方法，只执行一次" class="headerlink" title="①，被创建：执行init方法，只执行一次"></a>①，被创建：执行init方法，只执行一次</h3><p>默认情况下，第一次被访问时，Servlet被创建</p><p>当然可以配置执行Servlet的创建时机</p><p>​在&lt;servlet&gt;标签下配置</p><p>​1，第一次被访问时，创建</p><p>​&lt;load-on-startup&gt;的值为为负数</p><p>​2，在服务器启动时，创建</p><p>​&lt;load-on-startup&gt;的值为0或正整数</p><p>Servlet的init只执行一次，说明Servlet只有一个对象，是单例的</p><p>​多个用户同时访问时，可能存在线程安全问题</p><p>​解决:尽量不要在Serylet中定义成员变量。即使定义了成员变量，也不用对其修改值</p><h3 id="②，提供服务：执行执行service方法，执行多次"><a href="#②，提供服务：执行执行service方法，执行多次" class="headerlink" title="②，提供服务：执行执行service方法，执行多次"></a>②，提供服务：执行执行service方法，执行多次</h3><p>每次访问Servlet时，service方法都会调用一次</p><h3 id="③，销毁方法：执行destroy方法，只执行一次"><a href="#③，销毁方法：执行destroy方法，只执行一次" class="headerlink" title="③，销毁方法：执行destroy方法，只执行一次"></a>③，销毁方法：执行destroy方法，只执行一次</h3><p>Servlet被销毁时执行。服务器关闭时，Servlet被销毁</p><p>方法在Servlet被销毁之前执行，一般用于释放资源</p><p>只有服务器正常关闭时，才会执行destroy方法</p><h2 id="5，Servlet3-0"><a href="#5，Servlet3-0" class="headerlink" title="5，Servlet3.0"></a>5，Servlet3.0</h2><p>好处:<br>    支持注解配置。可以不需要web.xml了</p><p>步骤</p><p>1，创建JavaEE项目，选择Sv的版本3,0以上，可以不创建web.xml</p><p>2,定义一个类，实现Servlet接口</p><p>3，复写方法</p><p>4，在类上使用@webServlet注解，进行配置</p><p>​@webServlet(“资源路经”)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 212135.png)</p><p>如demo2即为资源路径</p><p>6,idea和tomcat相关路径</p><p>1，idea会为每一个tomcat部署的项目单独建立一份配置文件</p><p>​查看控制台的log:Using CATALINA_BASE:![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 213935.png)</p><p>2，工作空间项目     和   tomcat部署的项目</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 214534.png)</p><h2 id="6，servlet体系结构"><a href="#6，servlet体系结构" class="headerlink" title="6，servlet体系结构"></a>6，servlet体系结构</h2><p>关系</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 215122.png)</p><p>GenericServlet:将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象</p><p>​将来定义Servlet类时，可以继承GenericServlet,实现service()方法即可</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-02 220003.png)</p><p>HttpServlet:对http协议的封装</p><p>1，定义类继承HttpServlet</p><p>2,复写doGet&#x2F;doPost方法</p><h2 id="7-Servlet相关配置"><a href="#7-Servlet相关配置" class="headerlink" title="7,Servlet相关配置"></a>7,Servlet相关配置</h2><h3 id="①，urpartten-Servlet访问路径"><a href="#①，urpartten-Servlet访问路径" class="headerlink" title="①，urpartten:Servlet访问路径"></a>①，urpartten:Servlet访问路径</h3><p>1，一个Servlet可以定义多个访问路径@WebServlet({“&#x2F;d4”,”&#x2F;dd4”})</p><p>访问路径 <code>/products/123</code> 可能对应一个Servlet，该Servlet负责处理产品详情请求，而不一定对应服务器上的物理文件。</p><p>URL资源访问路径由两部分构成：资源路径与资源名称。资源名称指的是要访问资源的直接名称，如show.html，或与要访问资源存在映射关系的间接名称，如show.do。而资源路径，则是通过该路径则可以定位到指定的资源，即资源路径是指在URL资源访问路径中除了资源名称以外的其它部分。<br> 根据以上规则，URI（统一资源标识符）, 也可以分为资源路径与资源名称两部分。<br> 一般情况下， 在URL或URI中，最后一个斜杠后的部分为资源名称，而其它部分则为资源路径</p><p>2,路径定义规则:</p><p>1，&#x2F;xxx</p><p>2,&#x2F;xxx&#x2F;xxx:多层路径，目录结构</p><p>3,&#x2F;*在网络路径随意填写都会访问到该页面</p><p>4，&#x2F;*.字符     资源名称就是&#x2F;随意.那个字符</p><h1 id="二十四，http"><a href="#二十四，http" class="headerlink" title="二十四，http"></a>二十四，http</h1><h2 id="1-概念-2"><a href="#1-概念-2" class="headerlink" title="1,概念"></a>1,概念</h2><p>Hyper Text Transfer Protocol超文本传输协议</p><p>​传输协议: 定义了客户端和服务器端通信时，发送数据的格式</p><p>特点:</p><p>​1,基于Tcp&#x2F;ip的高级协议</p><p>​2，默认端口号:80</p><p>​<a href="http://www.itcast.cn/">http://www.itcast.cn:80</a></p><p>​3,基于请求&#x2F;响应模型的一次请求对应一次响应</p><p>​4，无状态的:每次请求之间相互独立，不能交互数据</p><p>历史版本:</p><p>​1.0:每一次请求响应都会建立新的连接</p><p>​1.1:复用连接</p><h2 id="2，处理请求响应消息数据格式-GET和POST请求方式"><a href="#2，处理请求响应消息数据格式-GET和POST请求方式" class="headerlink" title="2，处理请求响应消息数据格式(GET和POST请求方式)"></a>2，处理请求响应消息数据格式(GET和POST请求方式)</h2><p>​1，请求行</p><p>​请求方式 请求url 请求协议&#x2F;版本</p><p>​GET&#x2F;login.html   HTTP&#x2F;1.1</p><p>![屏幕截图 2024-08-03 150041](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 150041.png)</p><p>​请求方式:</p><p>​http协议有7种请求方式，常用的有2种</p><p>​get：</p><p>​1，请求参数在请求行中，在Url后</p><p>​2，请求的url长度有限制的</p><p>​3，不太安全</p><p>​post:</p><p>​1，,请求参数在请求体中</p><p>​2，请求的url长度没有限制的</p><p>​3，相对安全</p><p>​2，请求头:客户端</p><p>​请求头名称:请求头值</p><p>​常见的请求头:</p><p>​1,User-Agent:浏览器告诉服务器，我访问你使用的浏览器版本信息</p><p>​可以在服务器端获取该头的信息，<strong>解决浏览器的兼容性问题</strong></p><p>​2，Referer:<a href="http://localhost/login.html">http://localhost/login.html</a></p><p>​告诉服务器我(当前请求)从哪里来</p><p>​作用：防盗链</p><p>​统计</p><p>​3，请求空行</p><p>​空行，用于分割POST请求的请求头，和请求体的</p><p>​4，请求体(正文):</p><p>​封装POST请求消息的请求参数的</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 085021.png)</p><h2 id="3-请求和响应消息数据格式-request和response-请求"><a href="#3-请求和响应消息数据格式-request和response-请求" class="headerlink" title="3,请求和响应消息数据格式(request和response):请求"></a>3,请求和响应消息数据格式(request和response):请求</h2><h3 id="①request对象和response对象的原理"><a href="#①request对象和response对象的原理" class="headerlink" title="①request对象和response对象的原理"></a>①request对象和response对象的原理</h3><p>​1，request和response对象是由服务器创建的。我们来使用他们</p><p>​2，request对象是来获取请求消息，response对象是来设置响应消息的</p><h3 id="②对象HttpServletRequest的方法"><a href="#②对象HttpServletRequest的方法" class="headerlink" title="②对象HttpServletRequest的方法"></a>②对象HttpServletRequest的方法</h3><p>对象HttpServletRequest</p><h4 id="1，获取请求行数据"><a href="#1，获取请求行数据" class="headerlink" title="1，获取请求行数据"></a>1，获取请求行数据</h4><p>​get &#x2F;day14&#x2F;demo1?name&#x3D;zhangsan HTTP&#x2F;1.1</p><p>​方法</p><p>​1，获取请求方式: GET</p><p>​String getMethod()</p><p>​<strong>2,获取虚拟目录:&#x2F;day14</strong></p><p>​String getContextPath()</p><p>​3,获取Servlet路径: &#x2F;demo1</p><p>​String getServletPath()</p><p>​4,获取get方式请求参数:name&#x3D;zhangsan</p><p>​String getQueryString()</p><p>​<strong>5,获取请求uri:&#x2F;day14&#x2F;demo15</strong></p><p>​String getRequestURI():        &#x2F;day14&#x2F;demo1     统一资源定位符</p><p>​StringBuffer getRequestURL：       <a href="http://localhost/day14/demo1">http://localhost/day14/demo1</a>          统一资源标识符</p><p>​6,获取协议及版本:HTTP&#x2F;1.1</p><p>​String getProtocol()</p><p>​7,获取客户机的IP地址 </p><p>​String getRemoteAdder()</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 150023.png)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 150041.png)</p><h4 id="2，获取请求头数据"><a href="#2，获取请求头数据" class="headerlink" title="2，获取请求头数据"></a>2，获取请求头数据</h4><p>​String getHeader(String name):通过请求头的名称获取请求头的值</p><p>当请求referer时</p><ol><li><strong>检查 Referer</strong>:<ul><li>服务器接收到请求后，首先检查请求头部中的 <code>Referer</code> 字段。</li><li>如果请求中没有 <code>Referer</code> 头部，或者 <code>Referer</code> 头部为空，服务器可以选择拒绝请求。</li></ul></li><li><strong>验证域名</strong>:<ul><li>服务器解析 <code>Referer</code> 头部中的域名部分。</li><li>检查该域名是否在允许的域名列表中。</li><li>如果不在允许的列表中，服务器可以选择拒绝请求。</li></ul></li><li><strong>返回资源</strong>:<ul><li>如果请求通过了验证，服务器会正常返回资源</li></ul></li></ol><p>​Enmeration&lt;String&gt; getHeaderNames(): 获取所有的请求头名称</p><p>注意检查的是超链接的url是否有referer</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 154506.png)</p><h4 id="3，获取请求体数据"><a href="#3，获取请求体数据" class="headerlink" title="3，获取请求体数据"></a>3，获取请求体数据</h4><p>​请求体:只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</p><p>步骤：</p><p>​1,获取流对象</p><p>​BufferedReader getReader():获取字符输入流，只能操作字符数据</p><p>​ServletInputStream getInputStream():获取字节输入流，可以操作所有类型数据</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 164229.png)</p><p>​2，再从流对象中拿数据</p><h4 id="4，其他功能"><a href="#4，其他功能" class="headerlink" title="4，其他功能:"></a>4，其他功能:</h4><h5 id="1-获取请求参数通用方式-不论get还是post方式都可以使用下列方法来获取请求"><a href="#1-获取请求参数通用方式-不论get还是post方式都可以使用下列方法来获取请求" class="headerlink" title="1, 获取请求参数通用方式:不论get还是post方式都可以使用下列方法来获取请求"></a>1, 获取请求参数通用方式:不论get还是post方式都可以使用下列方法来获取请求</h5><p>​String getParameter(String name):根据参数名称获取参数值 username&#x3D;zs&amp;password&#x3D;123</p><p>​String[] getParameterValues(String name):根据参数名称获取参数值的数组    hobby&#x3D;xx&amp;hobby&#x3D;game</p><p>​Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称</p><p>​Map&lt;String,String[]&gt; getParameterMap() :获取所有参数的map集合</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 193208.png)</p><p>post方式:出现乱码问题</p><p>解决:在获取参数之前，设置request的编码request.setCharacterEncoding(“utf-8”);</p><h5 id="2，请求转发-一种在服务器内部的资源跳转方式"><a href="#2，请求转发-一种在服务器内部的资源跳转方式" class="headerlink" title="2，请求转发:一种在服务器内部的资源跳转方式"></a>2，请求转发:一种在服务器内部的资源跳转方式</h5><p>​1，步骤</p><p>​①通过request对象获取请求转发器对象:RequestDispatcher getRequestDispatcher(String path)</p><p>​②使用RequestDispatchaer对象来进行转发:forward(ServletRequest request,ServletResponse response)</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 200114.png)</p><p>​2,特点</p><p>​①浏览器地址栏路径不发生改变</p><p>​②只能转发到当前服务器内部资源中</p><p>​③转发是一次请求</p><h5 id="3，共享数据"><a href="#3，共享数据" class="headerlink" title="3，共享数据"></a>3，共享数据</h5><p>​域对象:一个有作用范围的对象，可以在范围内共享数据</p><p>​request域:代表一次请求的范围，一般用于请求转发的多个资源中共享数据</p><p>​方法:</p><p>​1,setAttribute(String name,Object obj):存储数据</p><p>​2，Object getAttribute(String name):通过键获取值</p><p>​3，void removeAttribute(String name):通过键移除键值对</p><p>在Java Web应用中，当我们谈论请求转发时，确实不需要重新定义 <code>HttpServletRequest</code> 对象。实际上，在请求转发的过程中，原始的 <code>HttpServletRequest</code> 对象会被直接传递给转发的目标资源，而不需要重新定义或创建新的 <code>HttpServletRequest</code> 对象。</p><p>“请求转发”（Request Forwarding）是指服务器内部的一种机制，它允许服务器将一个请求从一个资源转发到另一个资源，而无需再次向客户端发送响应。</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 202307.png)</p><p>![屏幕截图 2024-08-03 202333](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-03 202333.png)</p><h5 id="4，获取ServletContext"><a href="#4，获取ServletContext" class="headerlink" title="4，获取ServletContext"></a>4，获取ServletContext</h5><p>ServletContext getServletContext()</p><h3 id="③request对象继承体系结构"><a href="#③request对象继承体系结构" class="headerlink" title="③request对象继承体系结构"></a>③request对象继承体系结构</h3><p>ServletRequest        - - 接口</p><p>|    继承 </p><p>HttpServletRequest    –接口</p><p>|    实现</p><p>org.apache.catalina.connector.RequestFacade  类(tomcat)</p><p><code>doGet</code> 方法本身并不直接获取请求信息，而是通过 <code>HttpServletRequest</code> 参数来访问这些信息。<code>HttpServletRequest</code> 才是真正提供访问请求信息的方法的接口。</p><p>在HTML表单中，<code>action</code> 属性用于指定表单数据提交的目标URL。当用户提交表单时，表单中的数据会被发送到由 <code>action</code> 属性指定的URL地址。 </p><h2 id="4，请求和响应消息数据格式-request和response-响应"><a href="#4，请求和响应消息数据格式-request和response-响应" class="headerlink" title="4，请求和响应消息数据格式(request和response):响应"></a>4，请求和响应消息数据格式(request和response):响应</h2><h3 id="①数据格式"><a href="#①数据格式" class="headerlink" title="①数据格式:"></a>①数据格式:</h3><h4 id="1-响应行"><a href="#1-响应行" class="headerlink" title="1,响应行"></a>1,响应行</h4><p>​1,组成:协议&#x2F;版本 响应状态码 状态码描述</p><p>​2,响应状态码: 服务器告诉客户端浏览器本次请求和响应的一个状态</p><p>​1，状态码都是3位数字</p><p>​2，分类:</p><p>​1,1xx:服务器接受客户端消息但没有完成。等待一段时间后，发送1xx多状态码</p><p>​2,2xx;成功。代表:200</p><p>​3,3xx重定向。代表302(重定向)给客户端另一个路径资源，304(访问缓存)让浏览器直接用自己已经有的资源</p><p>​4,4xx:客户端错误，代表404(请求路径没有对应的资源)</p><p>​405:请求方式没有对应的doxxx方法</p><p>​5,5xx:服务器端错误代表:代表：500(服务器内部出现异常)</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-05 160030.png)</p><h4 id="2-响应头"><a href="#2-响应头" class="headerlink" title="2,响应头"></a>2,响应头</h4><p>​1，格式:头名称:值</p><p>​2，常见响应头:</p><p>​1，Content-Type :服务器告诉客户端本次响应体数据格式已及编码格式</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-05 155825.png)</p><p>​2，Content-disposition:服务器告诉客户端以什么格式打开响应体数据</p><p>​值:</p><p>​in-line:默认值，在当前页面打开</p><p>​attachment;filenama&#x3D;xxx:以附件形式打开响应体。文件下载</p><h4 id="3-响应空行"><a href="#3-响应空行" class="headerlink" title="3,响应空行"></a>3,响应空行</h4><p>​</p><h4 id="4-响应体"><a href="#4-响应体" class="headerlink" title="4,响应体"></a>4,响应体</h4><p>​真实的传输数据</p><h3 id="②response对象"><a href="#②response对象" class="headerlink" title="②response对象"></a>②response对象</h3><h4 id="功能-设置响应消息"><a href="#功能-设置响应消息" class="headerlink" title="功能:设置响应消息"></a>功能:设置响应消息</h4><p>​1，设置响应行</p><p>​①格式:HTTP&#x2F;1.1 200 ok</p><p>​②设置状态码:setStatus(int sc)</p><p>​2，设置响应头</p><p>​setHeader(String name,String value)</p><p>​3，设置响应体:</p><p>​使用步骤;</p><p>​①获取输出流</p><p>​字符输出流：PrintWriter getWriter()</p><p>​字节输出流ServletOutputStream getoutputStream()</p><p>​②使用输出流，将数据输出到客户端浏览器</p><p>​</p><h4 id="重定向的特点-redirect"><a href="#重定向的特点-redirect" class="headerlink" title="重定向的特点:redirect"></a>重定向的特点:redirect</h4><p>​地址栏发生变化</p><p>​重定向可以访问其他站点(服务器)的资源</p><p>​重定向是两次请求。不能使用request对象来共享数据</p><h4 id="转发的特点：forward"><a href="#转发的特点：forward" class="headerlink" title="转发的特点：forward"></a>转发的特点：forward</h4><p>​转发地址栏路径不变</p><p>​转发只能访问当前服务器下的资源</p><p>​转发是一次请求，可以使用request对象来共享数据</p><p>​forward 和 redirect 区别</p><h4 id="路径写法"><a href="#路径写法" class="headerlink" title="路径写法:"></a>路径写法:</h4><p>​1，相对路径:通过相对路径不可以确定唯一资源</p><p>​如:.&#x2F;index.html</p><p>​不以&#x2F;开头，以.开头路径</p><p>​</p><p>​规则:确定访问当前资源和目标资源之间的相对位置关系</p><p>​.&#x2F;:当前目录</p><p>​..&#x2F;:后退一级目录</p><p>​<a href="http://localhost/day/response">http://localhost/day/response</a></p><p>​<a href="http://localhost/day/nihao">http://localhost/day/nihao</a></p><p>​用时可以直接.&#x2F;nihao</p><p>​2，绝对路径:通过绝对路径可以确定唯一资源 </p><p>​如<a href="http://localhost/day/response">http://localhost/day/response</a>&#x2F;day&#x2F;response</p><p>​以&#x2F;开头的路径</p><p>​.&#x2F;可以省略</p><p>​</p><p>​规则:判断定义的路径是给谁用的</p><p>​给客户端浏览器使用(重定向，超链接….):需要加上下文路径(项目的访问路径)</p><p>​给服务器使用(转发):不需要加上下文路径</p><p>​动态上下文路径</p><p>​String contextPath &#x3D; request.getContextPath();</p><p>​引用时</p><p>​如:response.sendRedirect(context+“&#x2F;responseDemo2”)</p><h4 id="1，服务器输出字符数据数据到浏览器"><a href="#1，服务器输出字符数据数据到浏览器" class="headerlink" title="1，服务器输出字符数据数据到浏览器"></a>1，服务器输出字符数据数据到浏览器</h4><p>​步骤:</p><p>​1,获取字符输出流</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter pw = response.getWriter();</span><br></pre></td></tr></table></figure><p>​2,输出数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pw.write(&quot;你好啊啊啊 response&quot;);</span><br></pre></td></tr></table></figure><p>​注意:</p><p>​乱码问题:</p><p>​1.PrintWriter pw &#x3D; response.getWriter();获取的流的默认编码是ISO-8859-1</p><p>​2,设置该流的默认编码</p><p>​3，告诉浏览器响应体使用的编码</p><p>​服务器编码客户端解码码型不一致的问题可以直接用一行代码解决</p><p>​response.setContentType(“text&#x2F;html;charset&#x3D;utf-8”)</p><h4 id="2，服务器输出字节数据到浏览器"><a href="#2，服务器输出字节数据到浏览器" class="headerlink" title="2，服务器输出字节数据到浏览器"></a>2，服务器输出字节数据到浏览器</h4><p>​步骤:</p><p>​1,获取字节输出流</p><p>​response.setContentType(“text&#x2F;html;charset&#x3D;utf-8”);</p><p>​ServletOutputStream sos &#x3D; response.getOutputStream();</p><p>​2,输出数据</p><p>​sos.write(“你好”.getBytes(“utf-8”));</p><p>​后缀名无所谓</p><h2 id="5-servletcontext对象"><a href="#5-servletcontext对象" class="headerlink" title="5,servletcontext对象"></a>5,servletcontext对象</h2><h3 id="①概念-4"><a href="#①概念-4" class="headerlink" title="①概念:"></a>①概念:</h3><p>代表整个web应用,可以和程序的容器(服务器)来通信</p><h3 id="②功能："><a href="#②功能：" class="headerlink" title="②功能："></a>②功能：</h3><h4 id="1，获取MIME类型"><a href="#1，获取MIME类型" class="headerlink" title="1，获取MIME类型:"></a>1，获取MIME类型:</h4><p>​MINE类型:在互联网通信过程中定义的一种文件数据类型</p><p>​格式:  大类型&#x2F;小类型      text&#x2F;html        image&#x2F;jpeg</p><p><img src="/"></p><p>​获取:String getMineType(String file)</p><h4 id="2-域对象-共享数据"><a href="#2-域对象-共享数据" class="headerlink" title="2,域对象:共享数据"></a>2,域对象:共享数据</h4><p>​1,setAttribute(String name,Object value)</p><p>​2,getAttribute(String name)</p><p>​3,removeAttribute(String name)</p><p>​一个页面用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ServletContext context = this.getServletContext();</span><br><span class="line"></span><br><span class="line">//设置数据</span><br><span class="line">context.setAttribute(&quot;msg&quot;,&quot;haha&quot;);</span><br></pre></td></tr></table></figure><p>​另一个页面用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ServletContext context = this.getServletContext();</span><br><span class="line"></span><br><span class="line">//获取数据</span><br><span class="line">Object msg = context.getAttribute(&quot;msg&quot;);</span><br><span class="line">System.out.println(msg);</span><br></pre></td></tr></table></figure><p>​输出结果为haha</p><p>ServletContext对象范围:所有用户所有请求的数据</p><h4 id="3，获取文件的真实-服务器-路径，电脑上的"><a href="#3，获取文件的真实-服务器-路径，电脑上的" class="headerlink" title="3，获取文件的真实(服务器)路径，电脑上的"></a>3，获取文件的真实(服务器)路径，电脑上的</h4><p>​1，方法 : String getRealPath(String path)</p><p>​      这个path是idea内的不包含上下文路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServletContext context = this.getServletContext();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> // 获取文件的服务器路径</span><br><span class="line"> String b = context.getRealPath(&quot;/b.txt&quot;);//web目录下资源访问</span><br><span class="line"> System.out.println(b);</span><br><span class="line">// File file = new File(realPath);</span><br><span class="line"></span><br><span class="line"> String c = context.getRealPath(&quot;/WEB-INF/c.txt&quot;);//WEB-INF目录下的资源访问</span><br><span class="line"> System.out.println(c);</span><br><span class="line"></span><br><span class="line"> String a = context.getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);//src目录下的资源访问</span><br><span class="line"> System.out.println(a);</span><br></pre></td></tr></table></figure><p>而获取的路径为全资源路径</p><p>src目录下的文件将来会放到web-inf目录下的class文件下</p><h3 id="③获取"><a href="#③获取" class="headerlink" title="③获取"></a>③获取</h3><p>​1，通过request对象获取</p><p>​request.getServletContext();</p><p>​2，通过HttpServlet获取</p><p>​this.getServletContext();</p><h1 id="二十五，会话技术"><a href="#二十五，会话技术" class="headerlink" title="二十五，会话技术"></a>二十五，会话技术</h1><h2 id="1，概念-2"><a href="#1，概念-2" class="headerlink" title="1，概念"></a>1，概念</h2><p>一次回话中包含多次请求和响应</p><p>​一次回话:浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止</p><h2 id="2，功能-1"><a href="#2，功能-1" class="headerlink" title="2，功能"></a>2，功能</h2><p>在一次会话的范围内的多次请求间，共享数据</p><h2 id="3，方式"><a href="#3，方式" class="headerlink" title="3，方式"></a>3，方式</h2><h3 id="①客户端会话技术-Cookie"><a href="#①客户端会话技术-Cookie" class="headerlink" title="①客户端会话技术:Cookie"></a>①客户端会话技术:Cookie</h3><h3 id="②服务器端会话技术-Session"><a href="#②服务器端会话技术-Session" class="headerlink" title="②服务器端会话技术:Session"></a>②服务器端会话技术:Session</h3><h2 id="4-cookie"><a href="#4-cookie" class="headerlink" title="4,cookie:"></a>4,cookie:</h2><h3 id="①概念-客户端会话技术，将数据保存到客户端"><a href="#①概念-客户端会话技术，将数据保存到客户端" class="headerlink" title="①概念:客户端会话技术，将数据保存到客户端"></a>①概念:客户端会话技术，将数据保存到客户端</h3><h3 id="②快速入门"><a href="#②快速入门" class="headerlink" title="②快速入门:"></a>②快速入门:</h3><p>​使用步骤:</p><p>​1,创建Cookie对象，绑定数据</p><p>​new Cookie(String name,String value)</p><p>​2，发送Cookie对象</p><p>​response.addCookie(Cookie cookie)</p><p>​3，获取Cookie,拿到数据</p><p>​Cookie[] request.getCookie()</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-06 173255.png)</p><p>![屏幕截图 2024-08-06 173717](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-06 173717.png)</p><h3 id="③实现原理"><a href="#③实现原理" class="headerlink" title="③实现原理:"></a>③实现原理:</h3><p>​基于响应体set-cookie和请求体cookie实现</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-06 172316.png)</p><ul><li><strong>Cookie仍然存在</strong>:<ul><li>如果请求成功发送，并且Cookie没有过期，那么客户端的Cookie仍然保留在浏览器中。</li><li>客户端的Cookie不会因为一次请求就被移除或改变，除非服务器显式地告诉客户端删除Cookie或更改其值。</li></ul></li></ul><h3 id="④cookie的细节"><a href="#④cookie的细节" class="headerlink" title="④cookie的细节"></a>④cookie的细节</h3><h5 id="1，一次可不可以发送多个cookie"><a href="#1，一次可不可以发送多个cookie" class="headerlink" title="1，一次可不可以发送多个cookie?"></a>1，一次可不可以发送多个cookie?</h5><p>​可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可</p><h5 id="2-cookie在浏览器中保存多长时间？"><a href="#2-cookie在浏览器中保存多长时间？" class="headerlink" title="2,cookie在浏览器中保存多长时间？"></a>2,cookie在浏览器中保存多长时间？</h5><p>​默认情况下，当浏览器关闭后，cookie数据被销毁</p><p>​②持久化存储:</p><p>​setMaxAge(int seconds)</p><p>​1,正数将Cookie数据写到硬盘的文件中。持久化存储。cookie存活时间。</p><p>​2负数:默认值</p><p>​3,零:删除cookie信息</p><h5 id="3-cookie能不能存中文"><a href="#3-cookie能不能存中文" class="headerlink" title="3,cookie能不能存中文?"></a>3,cookie能不能存中文?</h5><p>​在tomcat 8 之前 cookie中不能直接存储中文数据</p><p>​需要将中文数据装码—–一般采用URL编码(%E3)</p><p>​在tomcat 8 之后，cookie支持中文数据</p><h5 id="4-cookie获取范围多大"><a href="#4-cookie获取范围多大" class="headerlink" title="4,cookie获取范围多大?"></a>4,cookie获取范围多大?</h5><p>①假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享?</p><pre><code> 默认情况下不能共享</code></pre><p>​setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录(上下文路径)</p><p>​如果要同一个服务器部署的多个项目的cookie全部共享,则可以将path设置为“&#x2F;”</p><p>​c1.setPath(“&#x2F;”)</p><p>cookie存储和服务器无关，他只认主机地址，端口号，虚拟路径，只要这个三保持一致没影响</p><p>②不同的tomcat服务器的部署项目的cookie共享问题?</p><p>​setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享</p><p>​setDomain(“.baidu.com”),那么tieba.baidu.com和news.baidu.com中cookie可以共享</p><h3 id="⑤cookie的特点"><a href="#⑤cookie的特点" class="headerlink" title="⑤cookie的特点"></a>⑤cookie的特点</h3><pre><code>   1,cookie存储数据在客户端浏览器</code></pre><p>​2,浏览器对于单个cookie的大小有限制(4kb)以及 对同一个域名下的总cookie数量也有限制(20)</p><h3 id="⑥作用"><a href="#⑥作用" class="headerlink" title="⑥作用"></a>⑥作用</h3><p>​1，一般用于储存少量的不太敏感的数据</p><p>​2，在不登录的请求下完成服务器对客户端的身份识别</p><p>案例:记住上一次访问的时间</p><h2 id="5-session"><a href="#5-session" class="headerlink" title="5,session"></a>5,session</h2><h3 id="①-概念"><a href="#①-概念" class="headerlink" title="①,概念:"></a>①,概念:</h3><p>​服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession</p><h3 id="②快速入门-1"><a href="#②快速入门-1" class="headerlink" title="②快速入门"></a>②快速入门</h3><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-06 214641.png)</p><p>3，原理:</p><p>​session的实现是依赖于cookie的</p><p>4，细节</p><p>​①当客户端关闭后，服务器不关闭，两次session是一个吗?</p><p>​默认情况下，不是。</p><p>​如果需要相同，则可以创建cookie，键为JSESSIONID，设置最大存活时间，让cookie持久化保存</p><p>​Cookie c &#x3D; new Cookie(“JSESSIONID”,session.getId());</p><p>​c.setMaxAge(60*60);</p><p>​response.addCookie(c)</p><p>​②客户端不关闭，服务器关闭后，两次获取的session是同一个吗</p><p>​不是同一个</p><p>​session的钝化:</p><p>​在服务器正常关闭之前，将session对象系列化到硬盘上</p><p>​session的活化:</p><p>​在服务器启动后，将硬盘中的session文件转化到内存的session对象即可</p><p>​不过只在tomcat中部署才能成功，无法在idea中成功</p><p>​③session的失效时间</p><p>​1,服务器关闭</p><p>​2,session对象调用invalidate()</p><p>​3,session默认失效时间  30分钟(可以调)</p><p>​选择性修改session在tomcat的web.xml搜索session-timeout</p><p>5，session的特点</p><p>​①session用于存储一次会话的多次请求的数据,存在服务器端</p><p>​②session可以存储任意类型，任意大小的数据</p><p>​</p><p>​session与Cookie的区别:</p><p>​1,session存储数据在服务器端,cookie在客户端</p><p>​2,session没有数据大小限制,cookie有</p><p>​3,session数据安全，cookie相对于不安全</p><h1 id="二十六jsp"><a href="#二十六jsp" class="headerlink" title="二十六jsp"></a>二十六jsp</h1><h2 id="1概念"><a href="#1概念" class="headerlink" title="1概念:"></a>1概念:</h2><p>​Java Server Pages:java服务器端页面</p><p>​可以理解为:一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码</p><p>​用于简化书写</p><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2,原理"></a>2,原理</h2><p>JSP本质上就是一个servlet</p><p>是servlet利用write将标签输出到页面上</p><h2 id="3，脚本"><a href="#3，脚本" class="headerlink" title="3，脚本"></a>3，脚本</h2><p>定义Java代码的方式</p><p> 1，&lt;% 代码%&gt;:定义的java代码,在service方法中，service可以定义什么，该脚本中就可以定义什么。</p><p>2,&lt;%！代码 %&gt;:定义的java代码，在jsp转换后的java类的成员位置</p><p>3,&lt;%&#x3D;代码%&gt;:定义的java代码,会输出到页面上。输出语句中就可以定义什么，该脚本就可以定义什么，&lt;%&#x3D; code %&gt;不是简单地将代码字符串输出，而是先执行 code 表达式，得到结果之后再输出这个结果</p><h2 id="4内置对象"><a href="#4内置对象" class="headerlink" title="4内置对象"></a>4内置对象</h2><p>在jsp页面中不需要获取和创建，可以直接使用的对象</p><p>jsp有9个内置对象。</p><h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><h4 id="response"><a href="#response" class="headerlink" title="response"></a>response</h4><h4 id="out"><a href="#out" class="headerlink" title="out:"></a>out:</h4><p>​字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似</p><p>​response.getWriter()和out.write()的区别:</p><p>​在tomcat服务器真正给客户端做出响应之前，会找response缓冲区数据，在找out缓冲区数据。response.getWriter()数据输出永远在out.write()之前</p><p>response.getWriter().write(“”)</p><h4 id="真实类型"><a href="#真实类型" class="headerlink" title="真实类型"></a>真实类型</h4><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><table><thead><tr><th>变量名</th><th>真实类型</th><th>作用</th></tr></thead><tbody><tr><td>pageContext</td><td>PageContext</td><td>当前页面共享数据还可以获取其他八个内置对象</td></tr><tr><td>request</td><td>HttpServletRequest</td><td>一次请求访问的多个资源</td></tr><tr><td>session</td><td>HttpSession</td><td>一次会话的多个请求间</td></tr><tr><td>application</td><td>ServletContext</td><td>所有用户间共享数据</td></tr><tr><td>response</td><td>HttpServletResponse</td><td>响应对象</td></tr><tr><td>page</td><td>Object</td><td>当前页面(Servlet)的对象  this</td></tr><tr><td>out</td><td>JspWriter</td><td>输出对象,数据输出到页面上</td></tr><tr><td>config</td><td>ServletConfig</td><td>Servlet的配置对象</td></tr><tr><td>exception</td><td>Throwable</td><td>异常对象</td></tr></tbody></table><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h2 id="5-指令"><a href="#5-指令" class="headerlink" title="5,指令"></a>5,指令</h2><p>​作用:用于配置JSP页面，导入资源文件</p><p>​格式:</p><p>​&lt;%@ 指令名称 属性名1&#x3D;属性值1 属性值2&#x3D;属性值2…%&gt;</p><p>​分类:</p><p>​1.page :配置JSP页面的</p><p>​①contentType:等同于response.setContenType()</p><p>​1,设置响应体的mine类型以及字符集</p><p>​2,设置当前jsp页面的编码(只能是高级的IDE才能生效,如果使用低级工具,则需要设置pageEncoding属性设置当前页面的字符集)</p><p>​如  contentType&#x3D;“text&#x2F;html;charset&#x3D;UTF-8”</p><p>​②import:导包</p><p>​③errorPage:当前页面发生异常后，会自动跳转到另一个页面</p><p>​如errorPage&#x3D;“nihao.jsp”</p><p>​④isErrorPage:标识当前页面是否是错误页面(错误页面指的是原页面发生异常，跳转后的页面)</p><p>​true:是，可以使用内置对象exception</p><p>​false:否。默认值。不可以使用内置对象exception(包含了错误信息)</p><p>​2,include:页面包含的。导入页面的资源文件</p><p>​如&lt;%@include file&#x3D;“top.jsp”%&gt;</p><p>​3,taglib:导入资源如jar</p><p>​如&lt;%@ taglib prefix&#x3D;“c” uri&#x3D;“<a href="http://java.sun.com/jsp/jstl/core%E2%80%9D%%3E">http://java.sun.com/jsp/jstl/core”%&gt;</a></p><p>​prefix:是前缀，自定义</p><p>​</p><p>假设你已经手动部署了JSTL 1.2库，并将其放置在应用的 <code>WEB-INF/lib</code> 目录中。你仍然需要在JSP页面中声明JSTL标签库，使用正确的 <code>uri</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://xmlns.jcp.org/jsp/jstl/core&quot; %&gt;</span><br></pre></td></tr></table></figure><p>这里的 uri (<a href="http://xmlns.jcp.org/jsp/jstl/core">http://xmlns.jcp.org/jsp/jstl/core</a>) 指定了你想要使用的JSTL核心标签库的版本和位置。</p><ul><li>如果你直接部署到应用服务器，确保在WEB-INF&#x2F;lib目录中包含了JSTL的jar文件（如 <code>jstl-1.2.jar</code>）</li></ul><h2 id="6，注释"><a href="#6，注释" class="headerlink" title="6，注释"></a>6，注释</h2><p>​①html注释:</p><p>​&lt;!– –&gt;:只能注释html代码片段</p><p>​② jsp注释推荐使用</p><p>​&lt;%– –%&gt;:可以注释所有</p><h2 id="二十七，MVC开发模式"><a href="#二十七，MVC开发模式" class="headerlink" title="二十七，MVC开发模式"></a>二十七，MVC开发模式</h2><h2 id="1-JSP演变历史"><a href="#1-JSP演变历史" class="headerlink" title="1,JSP演变历史"></a>1,JSP演变历史</h2><p>​1，早期只有servlet,只能使用response输出标签数据</p><p>​2，后来有Jsp，简化了Servlet的开发</p><pre><code>         3,再后来,java的web开发，借鉴了mvc开发模式,使得程序的设计更加合理</code></pre><h2 id="2-具体内容"><a href="#2-具体内容" class="headerlink" title="2,具体内容"></a>2,具体内容</h2><p>​1,M:Model:模型   javabean</p><p>​完成具体的业务操作,如:查询数据库,封装对象</p><p>​3, V:View,视图      jsp</p><p>​展示数据</p><p>​4,C:Controller:控制器    servlet</p><p>​获取用户的输入</p><p>​调用模型</p><p>​将数据交个视图进行展示</p><p>​优点:①耦合度低,维护方便，分工协作，</p><p>​②重用性低</p><p>​缺点;</p><p>​①,使得项目架构变得复杂,对开发人员要求高</p><p>​小贴士</p><ol><li><strong>用户与视图交互</strong>：<ul><li>用户通过视图与应用程序进行交互，例如填写表单或点击按钮。</li></ul></li><li><strong>视图向控制器发送请求</strong>：<ul><li>当用户与视图交互时，视图会将请求发送给控制器。</li></ul></li><li><strong>控制器处理请求</strong>：<ul><li>控制器接收请求，并决定需要调用哪个模型来处理数据。</li><li>控制器也可以验证数据或执行其他业务逻辑。</li></ul></li><li><strong>模型处理数据</strong>：<ul><li>模型执行实际的数据处理工作，例如查询数据库或执行复杂的计算。</li><li>模型更新其状态，并返回结果给控制器。</li></ul></li><li><strong>控制器更新视图</strong>：<ul><li>控制器从模型获取更新后的数据，并决定使用哪个视图来显示数据。</li><li>控制器将数据发送给视图，并更新用户界面。</li></ul></li><li><strong>视图显示更新后的数据</strong>：<ul><li>视图负责显示更新后的数据给用户。</li></ul></li></ol><h2 id="3，EL表达式"><a href="#3，EL表达式" class="headerlink" title="3，EL表达式"></a>3，EL表达式</h2><h3 id="①概念-5"><a href="#①概念-5" class="headerlink" title="①概念:"></a>①概念:</h3><p>​Expression Language 表达式语言</p><h3 id="②作用"><a href="#②作用" class="headerlink" title="②作用:"></a>②作用:</h3><p>​替换和简化jsp页面中java代码的编写</p><h3 id="③语法"><a href="#③语法" class="headerlink" title="③语法:"></a>③语法:</h3><p>​${表达式}</p><h3 id="④注意"><a href="#④注意" class="headerlink" title="④注意:"></a>④注意:</h3><p>​jsp默认支持EL表达式</p><p>​如果要忽略el表达式的.如果要忽略el表达式</p><p>​1，设置jsp中page指令中:isELIgnored&#x3D;“true”会忽略当前jsp页面中所有的el表达式</p><p>​也可以</p><p>​2，\${表达式}:忽略当前这个el表达式</p><h3 id="⑤使用"><a href="#⑤使用" class="headerlink" title="⑤使用"></a>⑤使用</h3><h4 id="1，运算"><a href="#1，运算" class="headerlink" title="1，运算"></a>1，运算</h4><p>​运算符:</p><p>​①算数运算符:+ - * &#x2F;(div)%(mod)</p><p>​②比较运算符: &gt; &lt;  &gt;&#x3D;  &lt;&#x3D;     &#x3D;&#x3D;  !&#x3D;</p><p>​③逻辑运算符:&amp;&amp;(and) ||(or) !(not)</p><p>​④空运算符:empty</p><p>​功能强大:用于判断字符串,集合,数组对象是否为null并且长度是否为0</p><p>​${empty list};表示判断字符串,集合,数组对象是否为null或者长度为0</p><p>​${not empty str}:表示判断字符串,集合,数组对象是否不为null或者长度不为0</p><p>​括号里的是一个效果</p><h4 id="2，获取值"><a href="#2，获取值" class="headerlink" title="2，获取值"></a>2，获取值</h4><h5 id="1-el表达式只能从域对象中获取值"><a href="#1-el表达式只能从域对象中获取值" class="headerlink" title="1,el表达式只能从域对象中获取值"></a>1,el表达式只能从域对象中获取值</h5><h5 id="2，语法"><a href="#2，语法" class="headerlink" title="2，语法:"></a>2，语法:</h5><p>​1,${域名城.键名}：从指定域中获取指定键的值</p><p>​域名称:</p><p>​1,pageScope     –&gt;pageContext</p><p>​2,requestScope   –&gt;request</p><p>​3,sessionScope     –&gt;session</p><p>​4,applicationScope   –&gt;application(ServletContext)</p><p>​举例</p><p>​在request域中存储了name&#x3D;张三</p><p>​获取:</p><p>​${requestScope.name}</p><p>​2,${键名}：表示依次从最小的域中查找是否有改键队应的值,直到找到为止</p><pre><code>         3，获取对象,List集合,map集合的值</code></pre><p>​1，对象:${域名称.键名.属性名}</p><p>​如${requestScope.u.age}</p><p>​本质上会去调用对象的getter方法</p><p>​逻辑视图:并没有使用变量,而是仅仅定义方法让页面好看</p><p>​属性:setter或getter方法,去掉set或get,在将剩余部分,首字母变小写</p><p>​如setName–&gt;Name –&gt;name</p><p>​2,List集合:${域名称.键名[索引]}</p><p>​${requestScope.list[1]}</p><p>​3，map集合:${域名称.键名.key名称}</p><p>​${域名称.键名.[“key名称”]}</p><p>​如${requestScope.map.[“gender”]}{map.gender}</p><h4 id="3-隐式对象-不常用"><a href="#3-隐式对象-不常用" class="headerlink" title="3,隐式对象(不常用):"></a>3,隐式对象(不常用):</h4><p>​el表达式中有11个隐式对象</p><p>​pageContext:</p><p>​获取其他八个内置对象</p><p>​${pageContext.request.contextPath}:动态获取虚拟目录</p><ul><li>EL表达式默认只能访问特定的隐式对象（也称为内置对象），如 <code>requestScope</code>、<code>sessionScope</code> 等。</li></ul><h2 id="4-jstl标签"><a href="#4-jstl标签" class="headerlink" title="4,jstl标签"></a>4,jstl标签</h2><h3 id="①概念-6"><a href="#①概念-6" class="headerlink" title="①概念:"></a>①概念:</h3><p>​JavaServer Pages Tag Library JSP标准标签库</p><p>​是由Apache组织提供的开源的免费的jsp标签</p><h3 id="②作用-1"><a href="#②作用-1" class="headerlink" title="②作用:"></a>②作用:</h3><p>​用于简化和替换jsp页面上的java代码</p><h3 id="③步骤"><a href="#③步骤" class="headerlink" title="③步骤"></a>③步骤</h3><p>​1,导入jstl相关jar包</p><p>​2,引入标签库:tah</p><p>​3,使用标签</p><h3 id="④常用的JSTL标签"><a href="#④常用的JSTL标签" class="headerlink" title="④常用的JSTL标签"></a>④常用的JSTL标签</h3><p>​1,if:相当于java代码的if语句</p><p>​1,属性:</p><p>​test为必须属性,接受boolean表达式(必须为el表达式)</p><p>​如果表达式为true,则显示if标签内容,如果为false，则不显示标签体内容</p><p>​2,注意:</p><p>​c:if标签没有else情况</p><p>​2,choose:相当于java代码的switch语句</p><p>​![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-07 210552.png)</p><p>​①使用choose标签声明          相当于switch声明</p><p>​②使用when标签做判断 相当于case</p><p>​③使用otherwise标签做其他情况的声明  相当于default</p><p>​3，foreach:相当于java中的for语句</p><p>​<code>&lt;c:forEach&gt;</code> 标签的主要属性包括：</p><p>​items<strong>：指定要遍历的集合或数组。</strong></p><p>​var：指定一个变量名，用于保存每次迭代的当前元素。即临时变量</p><p>​begin：可选属性，指定开始索引（默认为0）。即开始值</p><p>​end：可选属性，指定结束索引（默认为集合长度减一）。即临时变量</p><p>​step：可选属性，指定每次迭代的步长（默认为1）。即步长</p><p>​varStatus:循环状态对象</p><p>​ index:容器索引,从0开始</p><p>​count:循环次数从1开始</p><p>​遍历相当于for(a:B) a就是var，B就是item</p><p>遍历容器：</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-07 212947.png)</p><p>完成重复操作</p><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-07 213637.png)</p><h2 id="5，三层架构-软件设计架构"><a href="#5，三层架构-软件设计架构" class="headerlink" title="5，三层架构:软件设计架构"></a>5，三层架构:软件设计架构</h2><p>​①界面层(表示层):用户看的的界面。用户可以通过界面上的组件和服务器进行交互</p><p>​②业务逻辑层：处理业务逻辑的。</p><p>​③数据访问层:操作数据存储文件</p><h1 id="二十八-filters-过滤器"><a href="#二十八-filters-过滤器" class="headerlink" title="二十八,filters:过滤器"></a>二十八,filters:过滤器</h1><h2 id="1，概念-3"><a href="#1，概念-3" class="headerlink" title="1，概念"></a>1，概念</h2><p>​权限控制登录验证</p><p>​1,生活中的过滤器:</p><p>​2,web中的过滤器:当访问服务器的资源是过滤器可以将请求拦截下来,完成一些特殊的功能</p><p>​过滤器作用:</p><p>​一般用于完成通过的操作。如:登录验证,统一编码处理,敏感字符过滤.。。</p><h2 id="2-快速入门-1"><a href="#2-快速入门-1" class="headerlink" title="2,快速入门"></a>2,快速入门</h2><p>​1，步骤:</p><p>​①定义一个类:实现接口Filter</p><p>​②复写方法</p><p>​③配置拦截路径</p><p>​2.注解加上@WebFilter(“路径”)</p><p>​3，细节:</p><p>​①web.xml配置 </p><p><img src="C:\Users\31502\AppData\Roaming\Typora\typora-user-images\image-20240808211351721.png" alt="image-20240808211351721"></p><p>​注:在web.xml文件中将FilterDemo1变成过滤器,那个url标签是拦截范围</p><h3 id="3，过滤器执行流程"><a href="#3，过滤器执行流程" class="headerlink" title="3，过滤器执行流程"></a>3，过滤器执行流程</h3><p>​a;</p><p>​chain.doFilter(request, response);</p><p>​b;</p><p>​先执行a在执行注解里的类的方法最后执行b</p><p>​执行过滤器</p><p>​执行放行后的资源</p><p>​回来执行过滤器放行代码下边的代码</p><h2 id="3，过滤器生命周期方法"><a href="#3，过滤器生命周期方法" class="headerlink" title="3，过滤器生命周期方法"></a>3，过滤器生命周期方法</h2><p>​1，init:在服务器启动后,会创建Filter对象,然后调用init方法只执行一次。用于加载资源</p><p>​2,doFilter方法会执行多次(刷新一次页面执行一次)每一次请求被拦截资源后</p><p>​3,destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭,则会执行destroy方法。只执行一次。用于释放资源</p><h3 id="2，过滤器配置详解"><a href="#2，过滤器配置详解" class="headerlink" title="2，过滤器配置详解"></a>2，过滤器配置详解</h3><h3 id="①配置拦截路径"><a href="#①配置拦截路径" class="headerlink" title="①配置拦截路径:"></a>①配置拦截路径:</h3><p>​具体资源路径:&#x2F;index.jsp     只有访问index.jsp资源时过滤器才会被执行</p><p>​拦截目录:&#x2F;user&#x2F;*       访问&#x2F;user下的所有资源时，过滤器都会被执行,user是自己定义的虚拟目录</p><p>​后缀名拦截:*.jsp         访问所有后缀名为jsp资源是过滤器都会被执行</p><p>​拦截所有资源:&#x2F;*        访问所有资源时,过滤器都会被执行</p><h3 id="②拦截方式配置-资源被访问的方式"><a href="#②拦截方式配置-资源被访问的方式" class="headerlink" title="②拦截方式配置:资源被访问的方式"></a>②拦截方式配置:资源被访问的方式</h3><h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置:"></a>注解配置:</h4><p>​设置dispatcherTypes属性:</p><p>​1,REQUEST:默认值。浏览器直接请求资源时会执行</p><p>​2,FORWARD:转发访问资源时会执行</p><p>​3,INCLUDE:包含访问资源时会执行</p><p>​4,ERROR:错误跳转资源时会执行</p><p>​5,ASYNC:异步访问资源时会执行</p><p>​当你想要直接请求index.jsp或者转发访问index.jsp时,过滤器才会执行时</p><p>​@WebFilter(value&#x3D;“&#x2F;*”,dispatcherTypes &#x3D; {DispatcherType.FORWARD,DispatcherType.REQUEST})</p><p>​注:过滤器被调用的次数取决于请求的具体路径以及转发的次数比如当你定义了上面的@WebFilter时你访问了一个转发的页面会执行2次过滤器,但当你只设置转发访问会执行1次</p><h4 id="web-xml配置"><a href="#web-xml配置" class="headerlink" title="web.xml配置:"></a>web.xml配置:</h4><p>​设置&lt;dispatcher&gt;&lt;dispatcher&gt;在filter-mapping标签即可</p><p>​</p><h2 id="5，过滤器链-配置多个过滤器"><a href="#5，过滤器链-配置多个过滤器" class="headerlink" title="5，过滤器链(配置多个过滤器)"></a>5，过滤器链(配置多个过滤器)</h2><h3 id="①执行顺序-如果有两个过滤器-过滤器1和过滤器2"><a href="#①执行顺序-如果有两个过滤器-过滤器1和过滤器2" class="headerlink" title="①执行顺序:如果有两个过滤器:过滤器1和过滤器2"></a>①执行顺序:如果有两个过滤器:过滤器1和过滤器2</h3><p>​1,过滤器1</p><p>​2,过滤器2</p><p>​3.资源执行</p><p>​4,过滤器2</p><p>​5,过滤器1</p><h3 id="②过滤器先后顺序问题"><a href="#②过滤器先后顺序问题" class="headerlink" title="②过滤器先后顺序问题"></a>②过滤器先后顺序问题</h3><p>​1,注解配置:按照类名的字符串比较规则比较,值小的先执行</p><p>​如 AFilter和 BFilter,AFilter先执行</p><p>​如         come6和come17,come17先执行</p><p>​2,web.xml配置:谁定义在上边，谁先执行</p><h2 id="6-增强对象的功能"><a href="#6-增强对象的功能" class="headerlink" title="6,增强对象的功能"></a>6,增强对象的功能</h2><p>​设计模式:一些通用的解决固定问题的方式</p><p>​1,装饰模式</p><p>​2,代理模式</p><p>​概念:</p><p>​1,真实对象:被代理的对象</p><p>​2,代理对象:</p><p>​3,代理模式:代理对象代理真实对象,达成增强真实对象的目的</p><p>​实现方式:</p><p>​1,静态代理:有一个类文件描述代理模式</p><p>​动态代理:在内存中形成代理类</p><p>​实现步骤</p><p>​1,代理对象和真实对象实现相同的接口</p><p>​2,代理对象&#x3D;Proxy.newInstance():</p><p>​3,使用代理对象调用方法。</p><p>​4,增强方法</p><h1 id="二十九-Listener-监听器"><a href="#二十九-Listener-监听器" class="headerlink" title="二十九:Listener:监听器"></a>二十九:Listener:监听器</h1><p>​1,概念:Web的三大组件</p><p>​事件监听机制</p><p>​事件 : 一件事情</p><p>​事件源:事件发生的地方</p><p>​监听器:一个对象</p><p>​注册监听:将事件,事件源,监听器绑定在一起。当事件源发生某个事件后,执行监听器代码</p><p>​</p><p>​ServletContextListener:监听ServletContext域对象的创建和销毁</p><p>​void contextDestroyed(ServletContextEven sce)：ServletContext对象被销毁之前会调用该方法</p><p>​void contextInitialized(ServletContextEvent sce)：ServletSontext对象创建后会调用该方法</p><p>​2,步骤:</p><p>​①定义一个类,实现ServletContextListener接口</p><p>​②复写方法</p><p>​③配置</p><p>​1,web.xml</p><p>​&lt;listener&gt;</p><p>​&lt;listener-class&gt;cn.itcast.web.listener.ContextLoaderListener&lt;&#x2F;listener-class&gt;</p><p>​&lt;&#x2F;listener&gt;</p><p>​指定初始化参数&lt;context-param&gt;</p><p>​2,注解</p><p>​@WebListener</p><p>​</p><h1 id="三十-MAVEN仓库"><a href="#三十-MAVEN仓库" class="headerlink" title="三十,MAVEN仓库"></a>三十,MAVEN仓库</h1><h2 id="1-MAVEN目录结构"><a href="#1-MAVEN目录结构" class="headerlink" title="1,MAVEN目录结构"></a>1,MAVEN目录结构</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-09 191932.png)</p><h2 id="2-MAVEN指令"><a href="#2-MAVEN指令" class="headerlink" title="2,MAVEN指令"></a>2,MAVEN指令</h2><p>![](C:\Users\31502\Pictures\Screenshots\屏幕截图 2024-08-09 194428.png)</p><h2 id="3-坐标-被Maven管理的资源的唯一标识"><a href="#3-坐标-被Maven管理的资源的唯一标识" class="headerlink" title="3,坐标:被Maven管理的资源的唯一标识"></a>3,坐标:被Maven管理的资源的唯一标识</h2><p>​groupld:组织名称</p><p>​atifactld:模块名称</p><p>​version:版本号</p><p>​</p><h1 id="三十一，json"><a href="#三十一，json" class="headerlink" title="三十一，json"></a>三十一，json</h1><h2 id="1-概念-javascript-object-notation"><a href="#1-概念-javascript-object-notation" class="headerlink" title="1,概念:javascript object notation"></a>1,概念:javascript object notation</h2><p>javaScript对象表示法</p><p>json是存储和交换文本信息的语法,类似xml</p><p>json比xml更小,更快,更易解析</p><h2 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2,如何使用"></a>2,如何使用</h2><p>var p &#x3D; {“name”:”张三”,”age”:23,”gender”:”男”};</p><h2 id="3-语法"><a href="#3-语法" class="headerlink" title="3,语法:"></a>3,语法:</h2><p>①基本规则</p><p>​数据在名称&#x2F;值对中:json数据是由键值对构成的</p><p>​键用引号(单双都行)引起来,也可以不使用引号</p><p>​值得取值类型:</p><p>​1,数字(整数或浮点数)</p><p>​2,字符串(在双引号中)</p><p>​3,逻辑值(true或false)</p><p>​4,数组(在方括号中)  {“persons”:[{},{}]}</p><p>​5,对象(在花括号中)  {“address”:{“province”:”陕西”……}}</p><p>​6,null</p><p>​数据由逗号分隔:多个键值对由逗号分隔</p><p>​花括号保存对象:使用{}定义json格式</p><p>​方括号保存数组:[]</p><p>②获取数据</p><p>​1.json对象.键名person.name</p><p>​2,json对象[“键名”]person[“name”]</p><p>​3,数组对象[索引]persons[2].name</p><p>注 key不代表键名 key代表“键名”</p><h2 id="4-json数据和java对象的相互转换"><a href="#4-json数据和java对象的相互转换" class="headerlink" title="4,json数据和java对象的相互转换"></a>4,json数据和java对象的相互转换</h2><p>客户端和服务器端进行传递数据时可传递json</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/09/06/hello-world/"/>
      <url>/2024/09/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
